{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"source/image/docker.jpg","path":"image/docker.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/next/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"source/image/java8Stream.jpg","path":"image/java8Stream.jpg","modified":0,"renderable":0},{"_id":"source/image/11.jpg","path":"image/11.jpg","modified":0,"renderable":0},{"_id":"source/image/kafka/kafka-download.png","path":"image/kafka/kafka-download.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/direct.png","path":"image/rabbit/direct.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/delay-mq.jpg","path":"image/rabbit/delay-mq.jpg","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-banding.jpg","path":"image/rabbit/mq-banding.jpg","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-basic.png","path":"image/rabbit/mq-basic.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-exchange.jpg","path":"image/rabbit/mq-exchange.jpg","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-login.jpg","path":"image/rabbit/mq-login.jpg","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-fanout.jpg","path":"image/rabbit/mq-fanout.jpg","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-kafka.png","path":"image/rabbit/mq-kafka.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-miaosha.png","path":"image/rabbit/mq-miaosha.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-order.png","path":"image/rabbit/mq-order.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-order-old.png","path":"image/rabbit/mq-order-old.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-p2p.png","path":"image/rabbit/mq-p2p.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-subPush.png","path":"image/rabbit/mq-subPush.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-rabbit.png","path":"image/rabbit/mq-rabbit.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-yibuchuanxing.png","path":"image/rabbit/mq-yibuchuanxing.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-yibu.png","path":"image/rabbit/mq-yibu.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-yibubingxing.png","path":"image/rabbit/mq-yibubingxing.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/p2p.png","path":"image/rabbit/p2p.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/pubsub.png","path":"image/rabbit/pubsub.png","modified":0,"renderable":0},{"_id":"source/image/rabbit/topic.png","path":"image/rabbit/topic.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/beian.png","path":"images/beian.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logox32.png","path":"images/logox32.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logox128.png","path":"images/logox128.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logox64.png","path":"images/logox64.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/headImage.jpg","path":"images/headImage.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/clicklove.js","path":"js/clicklove.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"source/image/jmeter/jmeter-create.jpg","path":"image/jmeter/jmeter-create.jpg","modified":0,"renderable":0},{"_id":"source/image/jvm/jvm-memory.png","path":"image/jvm/jvm-memory.png","modified":0,"renderable":0},{"_id":"source/image/jvm/jvm-memory-structure.jpg","path":"image/jvm/jvm-memory-structure.jpg","modified":0,"renderable":0},{"_id":"source/image/jvm/jvm-stack.jpg","path":"image/jvm/jvm-stack.jpg","modified":0,"renderable":0},{"_id":"source/image/jvm/mat-1.jpeg","path":"image/jvm/mat-1.jpeg","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-direct.jpg","path":"image/rabbit/mq-direct.jpg","modified":0,"renderable":0},{"_id":"source/image/rabbit/mq-topic.jpg","path":"image/rabbit/mq-topic.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/addwechat.jpg","path":"images/addwechat.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":1},{"_id":"source/image/rabbit/mq-yunzhuanliucheng.jpg","path":"image/rabbit/mq-yunzhuanliucheng.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"source/image/jmeter/jmeter-http.jpg","path":"image/jmeter/jmeter-http.jpg","modified":0,"renderable":0},{"_id":"source/image/jmeter/jmeter-language.jpg","path":"image/jmeter/jmeter-language.jpg","modified":0,"renderable":0},{"_id":"source/image/jmeter/jmeter-listen.jpg","path":"image/jmeter/jmeter-listen.jpg","modified":0,"renderable":0},{"_id":"source/image/jmeter/jmeter-main.jpg","path":"image/jmeter/jmeter-main.jpg","modified":0,"renderable":0},{"_id":"source/image/jmeter/jmeter-result.jpg","path":"image/jmeter/jmeter-result.jpg","modified":0,"renderable":0},{"_id":"source/image/jmeter/jmeter-interface.jpg","path":"image/jmeter/jmeter-interface.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"source/image/jmeter/jmeter-resulttree.jpg","path":"image/jmeter/jmeter-resulttree.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"source/image/docker/docker-util.jpg","path":"image/docker/docker-util.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"9b53fd715f2c36899372519d81671aeeb3806c7b","modified":1572001534248},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1571905061749},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1571905061749},{"_id":"themes/next/.gitignore","hash":"7b68ca7a46104cf9aa84ec0541a4856ab1836eca","modified":1571905061755},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1571905061749},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1571905061756},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1571905061756},{"_id":"themes/next/_config.yml","hash":"f118985dc3b44b5ca63c1365c61ae6509b636620","modified":1574747249030},{"_id":"themes/next/.travis.yml","hash":"3a69594e562f42c04b137093c61c9f2f10adf714","modified":1571905061756},{"_id":"themes/next/README.md","hash":"2b54a384b207d64ae407793949dc8eec3f136701","modified":1571905061756},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1571905061757},{"_id":"themes/next/gulpfile.js","hash":"72e6d5a6e32d5f95d82e4c4d0c963d39555bb760","modified":1571905061767},{"_id":"themes/next/package.json","hash":"5e218373ff6e676a54fe5f903a04e49324029908","modified":1571905061785},{"_id":"source/_posts/.DS_Store","hash":"da1183b5fc938ac2f998cd2bb78d7ef9dc44ea4d","modified":1571983123372},{"_id":"source/about/index.md","hash":"4e75c28e36e3f65aa031966513e032016bcd3541","modified":1571921612926},{"_id":"source/categories/index.md","hash":"9900a263336f1c5d8a5946cf571abd221ff8166b","modified":1571921651887},{"_id":"source/_posts/RabbitMQ.md","hash":"9c138c735be85c2a2b36bc8ca33a9020a7cf0f44","modified":1567654536116},{"_id":"source/image/docker.jpg","hash":"3e9e58e51a40d3a3b5508d1071e4583ae0e958c6","modified":1555661931266},{"_id":"source/tags/index.md","hash":"8899b6a603d30b25bf4f1e9e41aac92f6976cc7c","modified":1571921651878},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1571905061735},{"_id":"themes/next/.git/config","hash":"e78135eac1ede2f3ca79747839db482790e54b3c","modified":1571905061738},{"_id":"themes/next/.git/index","hash":"5bc71c397f1058e4b914fc6ce867cd11e2cc3ea7","modified":1574314870182},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1571905003811},{"_id":"themes/next/.git/packed-refs","hash":"04e55387373d850af7ef33a6c1e1072227ec68de","modified":1571905061732},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1571905061750},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"0928b4db7eabac1e41c82e297f16f217774bea25","modified":1571905061750},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"2a4ff75ccb91d9001032c08e22489096b850bf4f","modified":1571905061751},{"_id":"themes/next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1571905061751},{"_id":"themes/next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1571905061752},{"_id":"themes/next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1571905061752},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"b09c85aa449f46bc025317ed196ec33a877f7c23","modified":1571905061752},{"_id":"themes/next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1571905061752},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1571905061754},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1571905061753},{"_id":"themes/next/.github/stale.yml","hash":"941209526c2f7d916c76163c9e1ac1af9d956679","modified":1571905061755},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1571905061755},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1571905061758},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"5b4c013e0598b3211ebd899265936cfdaf7c139f","modified":1571905061758},{"_id":"themes/next/docs/DATA-FILES.md","hash":"d0d46cb265f0efceffce82214cd36d8b82ddce13","modified":1571905061760},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1571905061759},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1571905061760},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1571905061761},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"08cda41b4bcf687facfda19ab39718ec7a05ae54","modified":1571905061761},{"_id":"themes/next/docs/MATH.md","hash":"58a961498c55cf4f0c69cf3668c810b602a17529","modified":1571905061762},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"199e9ef3cb5928af0fe801d03d2d1aeea704cea4","modified":1571905061762},{"_id":"themes/next/languages/de.yml","hash":"3d8920676d89494d7d1c74d4238680151ea6d9df","modified":1571905061767},{"_id":"themes/next/languages/default.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1571905061767},{"_id":"themes/next/languages/en.yml","hash":"c13eda783f8717c62b7ad9e8a9b724314ae74e1a","modified":1571905061767},{"_id":"themes/next/languages/es.yml","hash":"7dc1d7d5ea1078ee3b9bc8e0e8d0f15f52a7a4aa","modified":1571905061767},{"_id":"themes/next/languages/fa.yml","hash":"269b5cb70774485d7dbbcf98eec72c9e84e135b2","modified":1571905061767},{"_id":"themes/next/languages/fr.yml","hash":"dfdcfa536c40d06125dff373d042c50e08fcafd8","modified":1571905061767},{"_id":"themes/next/languages/hu.yml","hash":"e4a5f43fb45acd992def3de3b600aa4df4c95ed7","modified":1571905061768},{"_id":"themes/next/languages/id.yml","hash":"5665dece8435964a27b5061d7283f339f84721f0","modified":1571905061768},{"_id":"themes/next/languages/ja.yml","hash":"4f929842b3d6aaed709ea99da679d3910ee184e5","modified":1571905061768},{"_id":"themes/next/languages/it.yml","hash":"311597c620059dbb99474f19b2110a4485ecf70b","modified":1571905061768},{"_id":"themes/next/languages/pt-BR.yml","hash":"13b579911e44a8b213e1860f9a50c341be1bf95e","modified":1571905061769},{"_id":"themes/next/languages/ko.yml","hash":"5f5194dd0f5a3c8484e7668bce6fbe23340e531a","modified":1571905061768},{"_id":"themes/next/languages/pt.yml","hash":"af9d9b581dca45ab9789ca41d3492883a911e383","modified":1571905061769},{"_id":"themes/next/languages/nl.yml","hash":"561c77ca68e9d51a5ce8c89d3361fdb033c96bba","modified":1571905061768},{"_id":"themes/next/languages/tr.yml","hash":"39caf8a3677fd6dfbd523e73f8482a509e87b603","modified":1571905061769},{"_id":"themes/next/languages/ru.yml","hash":"b485c57dd7b447406dafd0dcfdfc9356266708c9","modified":1571905061769},{"_id":"themes/next/languages/uk.yml","hash":"4cbdbb0ed09487c9b435be21ac35f62182f53283","modified":1571905061769},{"_id":"themes/next/languages/vi.yml","hash":"3c6bb816ee7278afcddac06998c9ebe47ee19aef","modified":1571905061770},{"_id":"themes/next/languages/zh-CN.yml","hash":"e92e1e07a89c9fab27f445f9ec0fa35049fef38c","modified":1571905061770},{"_id":"themes/next/languages/zh-HK.yml","hash":"93d10d6e448c519004b09b11fba980b5036c93af","modified":1571905061770},{"_id":"themes/next/layout/_layout.swig","hash":"e8df0fbab2b4299638e95931f39d02f486de0f55","modified":1571970185088},{"_id":"themes/next/languages/zh-TW.yml","hash":"ae2aa1c6ec1a5a01a3a3bde17bcc3a82f9a35fa7","modified":1571905061770},{"_id":"themes/next/layout/archive.swig","hash":"59155648f6306888077d1f1d635f63177b36148d","modified":1571905061784},{"_id":"themes/next/layout/index.swig","hash":"3bc6fb1e9707d74b96e1346d3f03fe6584f764f4","modified":1571905061784},{"_id":"themes/next/layout/category.swig","hash":"c55debb2588e4746b02d31ec249bf0a84fdea260","modified":1571905061784},{"_id":"themes/next/layout/page.swig","hash":"e61d64c055b6497a04affc143f47fdd0a6dc495b","modified":1571905061785},{"_id":"themes/next/layout/post.swig","hash":"382d9f9a9b35e1f369585f7f9f9b5dd6fa58d2f0","modified":1571905061785},{"_id":"themes/next/layout/tag.swig","hash":"7ff6e34d557a3da1c6a29ecd97842bf73ff213dc","modified":1571905061785},{"_id":"themes/next/scripts/renderer.js","hash":"09bc459acab93e5ff9e2636d2b9d2a99025aa16f","modified":1571905061790},{"_id":"themes/next/source/404.html","hash":"b5e6533bfe368e8ac136dde99b162c6b35ce9dc1","modified":1571985368680},{"_id":"themes/next/source/CNAME","hash":"898105f91480fcf9d5dad1f6d1aeecb7b67a6fdb","modified":1571985294245},{"_id":"source/image/java8Stream.jpg","hash":"7c28477dc1588daaf410ba6f288859bfbb12c443","modified":1558019702836},{"_id":"source/_posts/docker/Docker-创建mysql容器.md","hash":"e2eb2c827c2dda6d47a843e55f35531626e85388","modified":1574747634342},{"_id":"source/_posts/docker/Docker-安装常用镜像.md","hash":"e9257d2e6ee7c66c67f4c1d9278116f8ada8da36","modified":1574747634378},{"_id":"source/_posts/docker/Docker-介绍.md","hash":"227cccbc38fa1b2297efc2db6e2b9e6dcb10fd58","modified":1574747634372},{"_id":"source/_posts/java/使用Orika实现Java Bean映射.md","hash":"5858920c0dde1e1846f2807e6c6ba4be8afdf984","modified":1567653984270},{"_id":"source/_posts/docker/Docker-搭建es和kibana环境.md","hash":"c5c644727ba7b5ce6d74d865df48ad41b2e665c0","modified":1574747634376},{"_id":"source/_posts/git/Git回滚到分支指定版本.md","hash":"852711f9b0dfde6d11c347d4397ffe64ad4f5528","modified":1567653983283},{"_id":"source/_posts/java/Java8-Stream中常用操作.md","hash":"0893847e2f8a875af811e1450ae4b6b966c7535a","modified":1567653987609},{"_id":"source/_posts/java/使用Nexus搭建Maven私服.md","hash":"63f17fe05b9e4bee24e206ca0a9d799849ca1670","modified":1567654533482},{"_id":"source/_posts/jvm/JVM-内存结构.md","hash":"3a7e2b226f461dff87565e34be6fdca6ffa6d548","modified":1567653994588},{"_id":"source/_posts/jvm/JVM系列-JVM自带工具.md","hash":"6aa6a92dd2a1ba75736a454db1c27225c343dc0e","modified":1567653993462},{"_id":"source/_posts/jvm/JVM系列-垃圾回收(GC).md","hash":"85fd9a339e24bf8f2359b951243eb851deb80405","modified":1567653992692},{"_id":"source/_posts/jvm/一次Spring Security造成的内存泄露.md","hash":"817e4d86df8f0acd2d430b442368f07154c18038","modified":1567653990460},{"_id":"source/_posts/test/JMeter基础使用指南.md","hash":"18458126230bb5bc0889e14edd1bd359eebb601c","modified":1567654531291},{"_id":"source/_posts/linux/Vim详解.md","hash":"9fa02deaf0f1933ccde9a658ac61537e7ffab164","modified":1567653998249},{"_id":"source/image/11.jpg","hash":"ca343ba9238dfeb636769a56b6a7ba35c7744952","modified":1539241307000},{"_id":"source/image/kafka/kafka-download.png","hash":"a8548a56d5c003885729b69c59903a6cccde8ead","modified":1565166712912},{"_id":"source/image/rabbit/direct.png","hash":"0ba63de33dd09d3a1d6991e137d9ba2b86339e9f","modified":1543340300105},{"_id":"source/image/rabbit/delay-mq.jpg","hash":"8ca5da0d2fbe7101f549fccbd9e09a2585ccb2cf","modified":1543803092477},{"_id":"source/image/rabbit/mq-banding.jpg","hash":"518c0b6fdd25743ef8afbd0f6ef715011c5d183c","modified":1543424238102},{"_id":"source/image/rabbit/mq-basic.png","hash":"8dfef652adcbab142f3aa48e016d13638ad51108","modified":1543332258179},{"_id":"source/image/rabbit/mq-exchange.jpg","hash":"f385789ea47f8e12173f2f9ce685671904f6e2b0","modified":1543423659701},{"_id":"source/image/rabbit/mq-login.jpg","hash":"1383b024f759d4cf80345115076010eb2827aab6","modified":1555661435745},{"_id":"source/image/rabbit/mq-fanout.jpg","hash":"592b21617290d0fd5d4208ab1d7c1851092b347f","modified":1543652937916},{"_id":"source/image/rabbit/mq-kafka.png","hash":"be560f12df555a8757a7778f2661507b60223a48","modified":1543337322774},{"_id":"source/image/rabbit/mq-miaosha.png","hash":"7df0e1b286581f2a1f50b4edbe83b0173febceef","modified":1543336497865},{"_id":"source/image/rabbit/mq-order.png","hash":"8aa26063b4782184567dd42b8f6623bf2b086adb","modified":1543337143964},{"_id":"source/image/rabbit/mq-order-old.png","hash":"87be91fd0d02c3caf87a4c0fb1adf5ba358d92ae","modified":1543337267534},{"_id":"source/image/rabbit/mq-p2p.png","hash":"194a5782e42ccd73c2c301207674b6ba825cc054","modified":1543337565154},{"_id":"source/image/rabbit/mq-subPush.png","hash":"9f6ecf7551d172e4c4eaac3a9d67071cf6f3b22f","modified":1543337575464},{"_id":"source/image/rabbit/mq-rabbit.png","hash":"7582cae932ca99a85a28542f861781cf2e0f8ea3","modified":1543333148764},{"_id":"source/image/rabbit/mq-yibuchuanxing.png","hash":"30da36a811fbb3cf862dfdf16a2ae0ba70fb1760","modified":1543336125224},{"_id":"source/image/rabbit/mq-yibu.png","hash":"9d18af2ad27f0a032381e8140dc78de20081c25a","modified":1543336262327},{"_id":"source/image/rabbit/mq-yibubingxing.png","hash":"1e44d0091d38e075c7c1b3542f674a89575d468e","modified":1543336234041},{"_id":"source/image/rabbit/p2p.png","hash":"2b6a18e703af96042fb81c904f60615d5501f3cc","modified":1543337822632},{"_id":"source/image/rabbit/pubsub.png","hash":"582e814ea15a73daa11b55d1c7e235cfa4a58faf","modified":1543337884964},{"_id":"source/image/rabbit/topic.png","hash":"13921a1b47d658785fa568fb2d3d68ceaeb9fdb7","modified":1543370313534},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1571905003811},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1571905003812},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1571905003812},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1571905003813},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1571905003813},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1571905003812},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1571905003813},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1571905003813},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1571905003813},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1571905003812},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1571905003813},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1571905003814},{"_id":"themes/next/.git/logs/HEAD","hash":"1596393217efa9c1fe8165634b56ee3083df7a76","modified":1571905061736},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"12b7bc6dd248bb6ca6c837b05b3be5ab150d6e07","modified":1571905061750},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"ada85c07483f50b288fdbcca4d099c85adf3d719","modified":1571905061750},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"7c567f6496c81746d916f81137a03e8e59f48d7f","modified":1571905061751},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"3dabc7effd99d2de0e1a0fae853679a3a4f5e0ce","modified":1571905061751},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"3b4dbf0d2ca12ab442b7e0e227769ce100b8a444","modified":1571905061765},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"ebacdc94f6f9724a7c6ef7c3cdde41ff7c37931a","modified":1571905061764},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"4245fe9472647226692fcbdd5a52d6e6dcd251bc","modified":1571905061764},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1571905061765},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"264d131b8865bae069f8e4d78a33a0f59d28e36b","modified":1571905061766},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"c7df75363851f31ae7a3e7b93798070c5d8a3053","modified":1571905061766},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"8109a531d3a7f5a306e36d4304c11f0c7c180c87","modified":1571905061766},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"41c06240e349a885b640c6ba4a982e3b8e7762fe","modified":1571905061764},{"_id":"themes/next/docs/zh-CN/README.md","hash":"7a2f600df2b6efd679bedf6b8da2b180adcc5fdf","modified":1571905061766},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"2665f6a9d72090f9452a8811544ff2596e8899be","modified":1571905061763},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1571905061763},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"fe3f5cda1975114884d84bef384a562920d70335","modified":1571905061763},{"_id":"themes/next/docs/ru/README.md","hash":"f36644786d3ac30dea8fc456d54bbe3e1db6a7d6","modified":1571905061763},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"815676d904f92748ddf4f529bed2baf066997bc6","modified":1571905061771},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1116597ae81c391981f3a8b80fa6febe5796583d","modified":1571905061771},{"_id":"themes/next/layout/_macro/post.swig","hash":"49286525140edeb79ba5aaf3162df38a1ebd3a44","modified":1571905061771},{"_id":"themes/next/layout/_partials/footer.swig","hash":"f99573abfaa30d240da46f12762b1c46cf68d0f7","modified":1571985195497},{"_id":"themes/next/layout/_partials/comments.swig","hash":"479286b378b027224c600f6bdd9ed51126086993","modified":1571981146562},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1571905061777},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"b9d3f6534efb9e637ac46318fa07c2e5607bf830","modified":1571905061775},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1571905061778},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1571905061777},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"9675acc599ffa546f05a60375c1637b0327be4fd","modified":1571905061778},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1571905061779},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1571905061779},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"8627c8c8b031ecee16c522433b66fa4d6979b8ea","modified":1571905061780},{"_id":"themes/next/layout/_third-party/index.swig","hash":"5affd16974528a1065d8b4aa799282d861db5362","modified":1571981187233},{"_id":"themes/next/layout/_third-party/facebook-sdk.swig","hash":"c6bfa6f00703d483af741b0de3e2cbc6a874fa75","modified":1571905061781},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"4abfcb5dae0e6dec5e288baa3a9fe4065829b392","modified":1571905061782},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"da6a9d14ed10203e378c6e2c00a7b5e7afabca58","modified":1571905061783},{"_id":"themes/next/layout/_third-party/vkontakte-api.swig","hash":"e0d012bdbae5545d90143030116114c34219bd37","modified":1571905061784},{"_id":"themes/next/scripts/events/index.js","hash":"ac2945693791e62a3046248f2a511afadcaebc16","modified":1571905061785},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1571905061788},{"_id":"themes/next/scripts/filters/locals.js","hash":"ffa0e122c1cdf9c86ddca104ddb2dfbaccaa1bb5","modified":1571905061789},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1571905061789},{"_id":"themes/next/scripts/filters/post.js","hash":"3c1e483c2c4a1c5a2f9a99b81ce0fda5fd21926b","modified":1571905061789},{"_id":"themes/next/scripts/helpers/engine.js","hash":"5519d233a2fed77379f6b5989b0cfa155b3f14e2","modified":1571905061789},{"_id":"themes/next/scripts/helpers/font.js","hash":"32268fb4c59c5b37c1eb1c9582ab630e09e5cc7d","modified":1571905061790},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"e60e6c0aaa979d42b01685ba2a03a76fa6e059e2","modified":1571905061790},{"_id":"themes/next/scripts/tags/button.js","hash":"1d1d25f7e579d92fa563778dd0f163e8eda190da","modified":1571905061790},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"20e392b8583ba6ae5037449c2c7e191d3927641b","modified":1571905061790},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1571905061790},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"8fc05f22b88553bc1d96e0c925799cd97920fc6a","modified":1571905061791},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"fad54f0e9e225a70390209f63d9b3cc566a5ebcb","modified":1571905061791},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1571905061791},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1571905061791},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1571905061791},{"_id":"themes/next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1571905061791},{"_id":"themes/next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1571905061792},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1571905061792},{"_id":"themes/next/source/css/main.styl","hash":"68c3377b643162aeaae2b60c196486fdb3b509c3","modified":1571905061810},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1571905061810},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1571905061810},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1571905061811},{"_id":"themes/next/source/images/beian.png","hash":"29c400bc3b89f6085766dac4e0330ded5cb73d52","modified":1571984446540},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1571905061811},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1571905061811},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1571905061811},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1571905061812},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1571905061812},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1571905061811},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1571905061812},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1571905061812},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1571905061812},{"_id":"themes/next/source/images/logox32.png","hash":"bcbd7d7d9e26f2499b5a692dd8d64adbd0faa88d","modified":1574314207000},{"_id":"themes/next/source/images/logox128.png","hash":"afb06ae0c436c4b92b24b9c01c05ee405ae9136c","modified":1574314251000},{"_id":"themes/next/source/images/logox64.png","hash":"9486ee278462af9612434eca0a19d70ec9ccb9c8","modified":1574314229000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1571905061813},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1571905061813},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1571905061813},{"_id":"themes/next/source/images/headImage.jpg","hash":"22fe9c31602ffe60aacb9f219937e6e63f970377","modified":1558773533000},{"_id":"themes/next/source/js/clicklove.js","hash":"effa770d8085f7e7fb903de217ce521dff163780","modified":1571970218165},{"_id":"themes/next/source/js/bookmark.js","hash":"c9acb262acf0cf127497b570fa9479fb32f34547","modified":1571905061813},{"_id":"themes/next/source/js/algolia-search.js","hash":"813afcc30feee11d59f297f2d5a96f98fbbd4743","modified":1571905061813},{"_id":"themes/next/source/js/local-search.js","hash":"fda0f761ae20577f22c1528dde7ae059368fe9a8","modified":1571905061813},{"_id":"themes/next/source/js/motion.js","hash":"71e5caff1d87b1b7256f61e6b318bedf495f9e75","modified":1571905061814},{"_id":"themes/next/source/js/next-boot.js","hash":"a6a82905c6abb8e0ec418ef6b0509b946b955807","modified":1571905061814},{"_id":"themes/next/source/js/utils.js","hash":"a2984bf0631756a904cd43f8e3a8f6fb15b9ceb5","modified":1571905061814},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1571905061815},{"_id":"source/image/jmeter/jmeter-create.jpg","hash":"62834370caa091c008329b1e4bafd9cdf29aaeae","modified":1561110141557},{"_id":"source/image/jvm/jvm-memory.png","hash":"861c58b56291e4f60e67fc431770d80df6a3e66b","modified":1558026568130},{"_id":"source/image/jvm/jvm-memory-structure.jpg","hash":"8d7295afb3e973ddf53c15ba812b8477dcd35c02","modified":1562749925947},{"_id":"source/image/jvm/jvm-stack.jpg","hash":"904615dca2c5d782400116a786e7ff3ebb905045","modified":1562750180453},{"_id":"source/image/jvm/mat-1.jpeg","hash":"5a98afd3ffd0d88916d302636db0df9b16c30d59","modified":1561691899735},{"_id":"source/image/rabbit/mq-direct.jpg","hash":"52b9ba59d94f1976ffe4aa592daf7c695b1a6121","modified":1543424560234},{"_id":"source/image/rabbit/mq-topic.jpg","hash":"d94534e876eea78ee4a4a22586fa35a4e136b93b","modified":1543425218792},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1571905061805},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1571905061805},{"_id":"themes/next/source/images/addwechat.jpg","hash":"5ad41d062bad9130b079b864e59148fbe8561984","modified":1558802898000},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"e43cbf5fd13e86d6176a18458e8345b27e5320b7","modified":1558773533000},{"_id":"source/image/rabbit/mq-yunzhuanliucheng.jpg","hash":"d310f1143d9191c985d5b296d31152da42f725e3","modified":1543422975284},{"_id":"themes/next/.git/objects/52/56f10d55a38208ed24137f76426f67f1af7098","hash":"1b1b2213b3e62474c5fe603e3ac41ecbcf7d04a2","modified":1574314862695},{"_id":"themes/next/.git/objects/45/779ef58a6068e262b3391efbe7d89b08a37b2e","hash":"7e381072682da27b4bdf055effcacf3d4f294cca","modified":1574314870181},{"_id":"themes/next/.git/objects/ec/574d37fe8fb399e64bbb03aed5d52c2bf14128","hash":"4857628cf186e44c4c0f3f88fb00098c2ac65ba8","modified":1574314852387},{"_id":"themes/next/.git/refs/heads/master","hash":"40e37e5b098a4bd03a6dbbd805f3c4fc91fc3baa","modified":1571905061736},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"3463de139574250bb84e58d7995d2839617a4296","modified":1571905061774},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"f5d2c5a3421ae52888be62e2c837459d1175cc93","modified":1571905061774},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"7487ca8f0e4b16351ea0d6b35dc52b0d32176d57","modified":1571905061774},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"ff33b5797f5e4b5cbcb3c222c17bc636c6b88df6","modified":1571905061774},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d488664bc16608b5f829f959c2058b4381be244a","modified":1571905061775},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"30528a8da30994b1ef9355a72b09b2cd85a7c0e9","modified":1571905061774},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"fbec9f77139e1f300509c38446416b4b26350cfa","modified":1571905061775},{"_id":"themes/next/layout/_partials/analytics/firestore.swig","hash":"67e63c25d509f02a6057ee9724f1b6efd647f72f","modified":1571905061772},{"_id":"themes/next/layout/_partials/analytics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1571905061772},{"_id":"themes/next/layout/_partials/analytics/busuanzi-counter.swig","hash":"d7258d02bcf0dac6c0fd8377c0909ddecb09d1d4","modified":1571905061772},{"_id":"themes/next/layout/_partials/analytics/tencent-mta.swig","hash":"198813a3f382bda4278fe3759bf0f18a5769bb33","modified":1571905061773},{"_id":"themes/next/layout/_partials/analytics/tencent-analytics.swig","hash":"493a1ef6c8f475d4dd3156a6ab37690dc75695ea","modified":1571905061773},{"_id":"themes/next/layout/_partials/analytics/lean-analytics.swig","hash":"fb7729b69ef443db1f3f2755506ee998cfe4b973","modified":1571905061773},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"a56e4f6ad95c106f361d354f828d1ef4810b1d76","modified":1571905061775},{"_id":"themes/next/layout/_partials/analytics/index.swig","hash":"ac6a3995c1330d2d73300b2427006509d0f8dba5","modified":1571905061772},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1571905061775},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"becfa683c3e5409e20cdb7b1dc8a6db331bddefe","modified":1571905061775},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"b654d63d2ed221a8b642223e220392e5172d8f4d","modified":1571905061776},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1571905061776},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"bebf630963c1c65fd152859a1ba316b03be17cce","modified":1571905061776},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"2edfaf1579ea58e15cb5583fb7962dfee9af2257","modified":1571905061776},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"2afd85181eaefcd68c4db71b0526ee26e2146477","modified":1571905061777},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"7fa01334a0ba84500e920bb9202baa08067d2ee1","modified":1571905061776},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"733d6874aa4f50d1071e670a554508a5a0094eb3","modified":1571905061777},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"d6fa9e4432b87004c5678dfe2d4b2c1f4a702b93","modified":1571905061776},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"246ff123cbaa507f23514c0c51c6cc006685898e","modified":1571905061778},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1571905061778},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1571905061778},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1571905061778},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1571905061778},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"7fd0459d2f1cfe1254f2c2b8087dc094c8cb0e84","modified":1571905061779},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"194201cce870c1af6f5123a62cb766cd24e46217","modified":1571905061779},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1571905061779},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"42aa3022f7739a552c7a55de316d8c0994b2fdc1","modified":1571905061780},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"20fcbed44aede1b908bd17d7a0279b03639068b1","modified":1571905061780},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"fdcf006e1ba2e53eab65e901b6c63159538307ef","modified":1571905061780},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1571905061780},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"1130b8bd60f3b84397974486e6586d7f0afaf836","modified":1571905061780},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"fe3cdd70224bd0c8171513a5dfed7b85deb7f23d","modified":1571905061781},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"4e240e6877afc7c6fd4374edd5059a294b7f618e","modified":1571905061781},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f95bc4d7ffaddc3c0df0ef3eeeaac58ff83f560","modified":1571905061781},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"8063f65cdaae80840fcf427b875ae606f678dfa5","modified":1571981146557},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"a9c8e7987b63b9ef66e47b966aea05ac77ff920a","modified":1571905061781},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"fc84b53b690399ca8e0f5395f0dc9f96eb559350","modified":1571905061782},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1571905061782},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"fb27a38f9a4b8fcba4f637b03904f7a83cc73416","modified":1571905061782},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1571905061783},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1571905061783},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"e456d7a2aaabe55447f78cd952b30d70a6c1e742","modified":1571905061783},{"_id":"themes/next/scripts/events/lib/config.js","hash":"246e55d48f2f3ef510c11594c7c08ddb93ac0928","modified":1571905061786},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"4958fa997ff6df2b2ce05341f40cc3a81b0f91bb","modified":1571905061783},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1571905061786},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"7fa72dc60c078842979861622839b109683e05a3","modified":1571905061783},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"311a54c0a0b6192502e68ce8c0b20e77aed3b996","modified":1571905061786},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"1fc2a94b94108175848ba9541d05898c071386d0","modified":1571905061786},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"0803d4f4d3d02c24417c163ad0b27b60fda79250","modified":1571905061786},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1571905061787},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"d2ce60980fc148bfb877981aabd07bf45d2cdcda","modified":1571905061787},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"c081166868e6428a07c51c5674b86b7a4cc9c2a8","modified":1571905061787},{"_id":"themes/next/scripts/filters/comment/facebook-comments-plugin.js","hash":"6e3f84d561d61f1be7248860049655b89c8825e2","modified":1571905061787},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1571905061787},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"3c4bdc2a682f9889a532e1cb856bc5caeb4208e1","modified":1571905061788},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"5201cd09a5e263282ccbf205f07d46f4c6d3f700","modified":1571905061788},{"_id":"themes/next/scripts/filters/comment/vkontakte.js","hash":"031337c2e2157628a15a5f4d96fa6e3fcf2733fe","modified":1571905061788},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2315dd8a7a2c7aabd29efa6193df08e805cb15fc","modified":1571905061805},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0a25f3df1b5c39794365efde387647da81da884a","modified":1571905061805},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"644c1f0b02be9bf59955ebdf496136b3fa4b660b","modified":1571905061805},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"52550138127ae9ebbe049bcdacd94d767c003855","modified":1571905061809},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"b9d7058db61df7bbd2b58779efe45621a06ffc18","modified":1571905061809},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c261d685c5ed0df34718d94bb2ba977c0ed443e6","modified":1571905061809},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"50bc57e66331c0f15a4527010b4ca3316ac92403","modified":1571905061809},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e76e0e411c9892004e73e1bb7b3c1cca2191eedc","modified":1571905061810},{"_id":"themes/next/source/images/alipay.jpg","hash":"6f0b5f75575300e4387a3e83a7fccf271e4cf691","modified":1558773533000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"dccbb1be3938050e13277251ab5d88c736edf396","modified":1571905061814},{"_id":"themes/next/source/js/schemes/muse.js","hash":"792f4522a3b0b96584a041a4aca20fcded410079","modified":1571905061814},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1571905061815},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1571905061815},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1571905061815},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1571905061816},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1571905061816},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1571905061824},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1571905061823},{"_id":"source/image/jmeter/jmeter-http.jpg","hash":"737d0f4512bb46025e796a72b6ac98ecb6c10966","modified":1561110738919},{"_id":"source/image/jmeter/jmeter-language.jpg","hash":"64975383455239799e6e7159d11b34b7c5207d3c","modified":1561105713461},{"_id":"source/image/jmeter/jmeter-listen.jpg","hash":"3e73262c7969b8f526e29a70827cd6e5cd9e7f58","modified":1561111135960},{"_id":"source/image/jmeter/jmeter-main.jpg","hash":"cfd24d5ae5baefe91b1183be2d6bbdfc370cc729","modified":1561105441936},{"_id":"source/image/jmeter/jmeter-result.jpg","hash":"d3002be1f4d6c951115f93938956bf7d33cc2fd5","modified":1561112278944},{"_id":"source/image/jmeter/jmeter-interface.jpg","hash":"b6c3c91da79e2c700baa30855d7877697385db41","modified":1561111545766},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1571905061734},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"1596393217efa9c1fe8165634b56ee3083df7a76","modified":1571905061736},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"80d359661d08b80ad561b97f8508766b3e1f6d01","modified":1571905061792},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"47ee915d7b0a97e74140a25fbfc01c04d6781534","modified":1571905061792},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"65a38b8a443c7da0f9492d10b3d9c9bf1e82c649","modified":1571905061793},{"_id":"themes/next/source/css/_common/components/rainbow.styl","hash":"41c7cd1b63d49476ed5fbdd26ab9411d8f44bd05","modified":1571905061796},{"_id":"themes/next/source/css/_common/components/scrollbar.styl","hash":"b6cd686e4a9848252fb73262c6a21a9bd25c3179","modified":1571905061796},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"990bd301ce2de0a6b936781c58318f3945d81bc2","modified":1571905061799},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"170c4598cbbe49cd1527f94158d97d2320a6b906","modified":1571905061796},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"44fe82eadbdbb2f66adda37ac83ebd0f85876bfc","modified":1571905061799},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"3faa8a7cdb05ef3f3b02920d381773dfd54270a5","modified":1571905061801},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"2067e15799a3a3cda8bfe7782d67a4dc42f1ef79","modified":1571905061801},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1571905061802},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"d8ba44b8e1a0332c5c1079ff65fc83d2918a5865","modified":1571905061801},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f3c5f1dadc01042381444102d35174dacc6f079a","modified":1571905061803},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1571905061802},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1571905061804},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1571905061803},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"08c2679a31f195940fe1e6c76e64799fb21cda99","modified":1571905061806},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4341f0e057b42e8c47629bb3196fca3b49f0cc19","modified":1571905061806},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"24a086a6904bbf5355a354403c9b0e6069f7eb01","modified":1571905061806},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e321bd62f5e04d1fdc101a470ec13604e99816a5","modified":1571905061806},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1571905061807},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"48743ac61af37a4de2026667e15a65de5e8cf542","modified":1571905061806},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1571905061807},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"3646e915b0a55f3b66e41d802b082aba88a76e06","modified":1571905061807},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"316ee13fc26d327c8862c2455211144c180cf9c1","modified":1571905061807},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"eeab294e14abbae231107e1a327e907b25323136","modified":1571905061807},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1571905061807},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1571905061808},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f5abb2ea7746586738fb4e82107fceed041708ee","modified":1571905061808},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"f1f81bca31e82ccbd375f0cb9fb8dbb3beac810d","modified":1571905061808},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"c0ed534696ed86560c95ab2a3541b2b42a41ed39","modified":1571905061808},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"c59226767164285d6708d8762f937f93bab264ca","modified":1571905061808},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0424a1fcffa1ae82fe70935972a894aca885bf9a","modified":1571905061809},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1571905061809},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1571905061816},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1571905061816},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1571905061817},{"_id":"source/image/jmeter/jmeter-resulttree.jpg","hash":"e79f9b07e5dfadce5ddab7893b4985bb818aff5a","modified":1561112142317},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1571905061821},{"_id":"source/image/docker/docker-util.jpg","hash":"930f68cef819c8ca5ad9f55f45f19c36431ddaa1","modified":1557930096099},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1571905061822},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"1596393217efa9c1fe8165634b56ee3083df7a76","modified":1571905061734},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1571905061793},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1571905061793},{"_id":"themes/next/.git/objects/pack/pack-57f9fd710c5e62ea8c9f3a5c03dc1e3487ad71c2.idx","hash":"4c81913b64bea4dc1db78e5161c4d0e5896938cc","modified":1571905061702},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1571905061793},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6336c2b129db802221b1fd75e5fbe8aab85c0a1f","modified":1571905061793},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"98227b4de364b48b11e21efcf4f1beb2ed3ab329","modified":1571905061794},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"7ddb7453bf9b85b01bff136e9d10a7f06baac9e8","modified":1571905061793},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"602a3c3d2785965b23412b5c219dfe74b5fb0844","modified":1571905061794},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"d557a0de91a428330b43cdae9f1ec7167d24e2e4","modified":1571905061794},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"4b84f35e7040f9adb5cc540c366d7f9eb4c48bcc","modified":1571905061794},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"e3ade812b5541eca5b863ad3ff234ea95925bf31","modified":1571905061794},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"3566136c06d96b34e1e7a3eca72fb0f40a63af80","modified":1571905061794},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"f8ba308231cf81453e41457796e94f1ce886d855","modified":1571905061795},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1571905061795},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2e2a09dddd2a394a635bcefb6207b6cddcb784c7","modified":1571905061795},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1571905061795},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"265e6fd7b3a76616ef00f3e3c0feeb93e70ee27c","modified":1571905061795},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1571905061796},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"5248880398c1318624bdab95109c1c9fdb8eec02","modified":1571905061796},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1571905061797},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1571905061797},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2d9d68a431a334626d463bb1bdfbcd2ea8242e94","modified":1571905061797},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"4525465f40f82bd66e5f34e986440c75a9e2d2b2","modified":1571905061797},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"5528a755b180312d008054653633d857aeeb6780","modified":1571905061797},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"4b237e2344f35e9d1f6dbc3842d5e432d478ebfd","modified":1571905061798},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"0672ea2acf28dcc2cfc5244da36d3387d71a17cb","modified":1571905061798},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e02b1097a72a7d2ddc45ea8d53aa6d77c25ac407","modified":1571905061798},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1571905061798},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"d5d85d3646d184e0340924addcfd2523fb289d00","modified":1571905061798},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"a7ed54e2f52185a7b6bb9a8201f6c3aa74b0cb00","modified":1571905061799},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b5ba1b3d5535ccf1e5df6f4cd8ee0147d7278be9","modified":1571905061799},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1571905061799},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"95339b71ac90553fb1634c536c9749055e0c788a","modified":1571905061800},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"9b3ff4aa24069eab0e9771437013f45e450d4217","modified":1571905061799},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"1db4ce981fe9fcb9ee4279395c29553efbb43947","modified":1571905061800},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"cc4beedb56c37246d9e0f74e4b2cc34231dabc65","modified":1571905061800},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1571905061800},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"e2ad7ccf1865a45548e3f31c70fac2c65d6ef534","modified":1571905061800},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1571905061800},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"eaa62b5de4ddb18378c1a4049a172d4fa4b655d8","modified":1571905061801},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"9a18b186b08ec220d1b17cf83812bcdd06077814","modified":1571905061801},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"2b536832cfc81667dadd9603c8c700e44d458261","modified":1571905061801},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1571905061802},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"4b980363822c24b3ad85c271719210a8ad2b646e","modified":1571905061802},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1571905061802},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"5bf28a03ef021c27cfd713971caca5a0b9466fd1","modified":1571905061803},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"7213e3d0ad7c95717ecd4e701d6ee9248ef2bf9f","modified":1571905061803},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"068b304be305fbfd0220276d56b93cefd968f0b6","modified":1571905061804},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"879f9cec9c88d65b2e31af4346b2bc0f6941f05d","modified":1571905061803},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"419fa6cfc103d08dfd6a385ab7f24468c644d581","modified":1571905061804},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"2dc2a5b7becb11de1d4bdab6b5195588ae878cfc","modified":1571905061804},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1571905061804},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1571905061819},{"_id":"themes/next/.git/objects/pack/pack-57f9fd710c5e62ea8c9f3a5c03dc1e3487ad71c2.pack","hash":"4420f76fc1eb451c9dd7eb4949df4639a0741cb1","modified":1571905061696},{"_id":"public/search.xml","hash":"de28e96013f75aabe55a418522b775457c7e19b9","modified":1574748307221},{"_id":"public/about/index.html","hash":"3e07327284ef2beed4ffbb542c722ca485b2d84d","modified":1574748307221},{"_id":"public/categories/index.html","hash":"ed785da885b83d9ad9f33e4d456cbf166407fb71","modified":1574748307221},{"_id":"public/tags/index.html","hash":"4b5601ee99d259c05ffa140727757033dd92791a","modified":1574748307221},{"_id":"public/categories/消息队列/index.html","hash":"6aef081820be63f7729c9f6f7744d83618a6b3bc","modified":1574748307221},{"_id":"public/categories/docker/index.html","hash":"625619dbfd5ff5fecbdcf6a8562475b090d52323","modified":1574748307221},{"_id":"public/categories/java/index.html","hash":"0b05dc48f3efb4124bc86b0ea9970079bae0b4a0","modified":1574748307221},{"_id":"public/categories/Git/index.html","hash":"73ac287a701244b3ce6f7dd595415f9159724bb0","modified":1574748307221},{"_id":"public/categories/Maven/index.html","hash":"b3a2cabae868f6aa34962b7cc1b5a93ddbbe628c","modified":1574748307221},{"_id":"public/categories/JVM/index.html","hash":"5ea9608964af804b9fe527d11d3af60b7e47abd8","modified":1574748307221},{"_id":"public/categories/测试/index.html","hash":"fc61f6cd1b529906262fe0c726c5735310276ad4","modified":1574748307221},{"_id":"public/categories/Linux/index.html","hash":"ef1cb931c01c186a60ad21bc40d85567c9e67b1c","modified":1574748307221},{"_id":"public/tags/RabbitMQ/index.html","hash":"4463aaf71c02ef657a62cb321f81b1b7e7d9e9e6","modified":1574748307221},{"_id":"public/tags/消息队列/index.html","hash":"7c1e8b5281d0ef82023a84421510036133a328af","modified":1574748307221},{"_id":"public/tags/docker/index.html","hash":"f5af72857876ff9ba34fcb83dc00a63d7a322df6","modified":1574748307221},{"_id":"public/tags/es/index.html","hash":"843389cd62b0c7979ac50e7ae381a8c2c8da0074","modified":1574748307221},{"_id":"public/tags/Bean映射/index.html","hash":"576b19d8053055bac1370d3cfd897b664eb394f3","modified":1574748307221},{"_id":"public/tags/Orika/index.html","hash":"3df90cfcb29b299198cc887877cc759b0ea596db","modified":1574748307221},{"_id":"public/tags/Java/index.html","hash":"c7d43b0a5be7416ce3a5ac9ab6ce96e8f9d621b8","modified":1574748307221},{"_id":"public/tags/Git/index.html","hash":"e93515f994e4e5e297d091168a850daf7d2986d1","modified":1574748307221},{"_id":"public/tags/mysql/index.html","hash":"e5ca13447b62dd1ab9186dd04de5afb51c9bc3eb","modified":1574748307221},{"_id":"public/tags/Java8/index.html","hash":"9e3363ef0a7c7c4c8d18238f35c9536f033521bc","modified":1574748307221},{"_id":"public/tags/stream/index.html","hash":"7e6769efdd3097fdc1fb8ba5de111ff753fdf01a","modified":1574748307221},{"_id":"public/tags/Maven/index.html","hash":"f83d9a29ec405cffaac3d72c328e27d3425f0910","modified":1574748307221},{"_id":"public/tags/Nexus/index.html","hash":"03a0d941d2814c890baac112aa0f97c094f09ddf","modified":1574748307221},{"_id":"public/tags/JVM/index.html","hash":"9e16c78fe4e5e11b6517ea25525f141072fabbbe","modified":1574748307221},{"_id":"public/tags/JVM内存结构/index.html","hash":"c087701faf3e66ffa82bc30843aae5a44f02cdc7","modified":1574748307221},{"_id":"public/tags/工具/index.html","hash":"2d35a02a3d08b137472305bfdcc9c2affbeedc2e","modified":1574748307221},{"_id":"public/tags/GC/index.html","hash":"10e20362847ac5008fe6fff1afa2c93031d764f6","modified":1574748307221},{"_id":"public/tags/垃圾回收/index.html","hash":"7901a751c87f479f86995452cbcf3c945a83e251","modified":1574748307221},{"_id":"public/tags/实战/index.html","hash":"ef5631377199fb83e1ab3efe8279511860f67572","modified":1574748307221},{"_id":"public/tags/内存泄露/index.html","hash":"b7bacd543ae5c0ef00d8a9ddb8be989c7fe53f1d","modified":1574748307221},{"_id":"public/tags/JMeter/index.html","hash":"8c3ee1c9101df9f50b74d4b6dea81a3ebaed5fdd","modified":1574748307221},{"_id":"public/tags/测试/index.html","hash":"072be87c6de52a704577db295ac1672b6d41f64f","modified":1574748307221},{"_id":"public/tags/Linux/index.html","hash":"7ab4129fbcfc289e036258928c2b452849dae489","modified":1574748307221},{"_id":"public/tags/Vim/index.html","hash":"e9d9fa9941febe2dd115cd3a09088196bdb0a96a","modified":1574748307221},{"_id":"public/archives/page/2/index.html","hash":"9a4d2c5a3278413e8a03f36fda519b01400f04e1","modified":1574748307221},{"_id":"public/archives/2018/index.html","hash":"66a568fce4e06ad1abf86da391f7ebffd8801add","modified":1574748307221},{"_id":"public/archives/2018/09/index.html","hash":"6398c0255f1843af0938ea56f93a230a13eb0256","modified":1574748307221},{"_id":"public/archives/2018/11/index.html","hash":"cdb9866ddfc38db58b3ff1ebcd4b7d81f8322b95","modified":1574748307221},{"_id":"public/archives/2019/page/2/index.html","hash":"7e5fb68ecb3d11ca8a7141dacf697fd0bcee7e06","modified":1574748307221},{"_id":"public/archives/2019/03/index.html","hash":"ba0521e65dd857795bf1adffc5e50293d3e2016e","modified":1574748307221},{"_id":"public/archives/2019/05/index.html","hash":"6c7b285d1dfcde4767e800cc64b009db42156aa2","modified":1574748307221},{"_id":"public/archives/2019/06/index.html","hash":"19f2c908969bb340450a3167c7abe965e68e8e69","modified":1574748307221},{"_id":"public/archives/2019/07/index.html","hash":"3476a5c82f50aa7410433730e32e13c447504791","modified":1574748307221},{"_id":"public/2019/07/10/linux/Vim详解/index.html","hash":"cb6ae9a254c75e9343111f4c0034bd7a249e352e","modified":1574748307221},{"_id":"public/2019/07/08/git/Git回滚到分支指定版本/index.html","hash":"ebf2162fb59a102ccf37cf0388783795e50ef5f1","modified":1574748307221},{"_id":"public/2019/07/05/docker/Docker-搭建es和kibana环境/index.html","hash":"bc6b46807aaec74b90cd2f7527d565d9f7281d50","modified":1574748307221},{"_id":"public/2019/06/28/jvm/一次Spring Security造成的内存泄露/index.html","hash":"61ca0afb4d161ed7ec14b7a8f487efa966166072","modified":1574748307221},{"_id":"public/2019/06/27/java/使用Nexus搭建Maven私服/index.html","hash":"f666eb6d63979d936e85d3a3b706121a29f0e356","modified":1574748307221},{"_id":"public/2019/06/27/jvm/JVM系列-JVM自带工具/index.html","hash":"286aad74426bca9ad7a4e7cb68028db787639f22","modified":1574748307221},{"_id":"public/2019/06/21/test/JMeter基础使用指南/index.html","hash":"03167a3ece82b4c6fd024747d572aa926c0d692d","modified":1574748307221},{"_id":"public/2019/05/29/java/使用Orika实现Java Bean映射/index.html","hash":"bf318e865a310b59f3adabe39df396568cce8475","modified":1574748307221},{"_id":"public/2019/05/27/jvm/JVM系列-垃圾回收(GC)/index.html","hash":"39f0513adbf78988aa87192a3282bd7acada936a","modified":1574748307221},{"_id":"public/2019/05/28/jvm/JVM-内存结构/index.html","hash":"b0060dd24c7efc611404d47204c9662d03050e01","modified":1574748307221},{"_id":"public/2019/05/16/java/Java8-Stream中常用操作/index.html","hash":"4a9e6c87487b75715c15cdb78f04d34c3fbaff53","modified":1574748307221},{"_id":"public/2019/05/15/docker/Docker-安装常用镜像/index.html","hash":"4db1943809acdd55f136f11d7219fa7179d89f68","modified":1574748307221},{"_id":"public/2019/03/10/docker/Docker-创建mysql容器/index.html","hash":"8b0950549dabdbd40769500caeb546069aae675d","modified":1574748307221},{"_id":"public/2018/11/27/RabbitMQ/index.html","hash":"71943b1dbd26109e38c65ed62e298276e5b392c2","modified":1574748307221},{"_id":"public/2018/09/19/docker/Docker-介绍/index.html","hash":"7fd1c1b662d6e3804fc0d65fecbf108909096329","modified":1574748307221},{"_id":"public/index.html","hash":"507746f97e05d2d7b830ccb7afcfc97402afe80c","modified":1574748307221},{"_id":"public/page/2/index.html","hash":"045c8dbc1b1b7d8a60965d5bcdf8018dd1ab481a","modified":1574748307221},{"_id":"public/archives/index.html","hash":"a63362fcc35c7a849fe15881fce848ba91844bd3","modified":1574748307221},{"_id":"public/archives/2019/index.html","hash":"6d68800b675dd9ff25f4fb5b6f44f6c43a39cbd7","modified":1574748307221},{"_id":"public/images/logox32.png","hash":"bcbd7d7d9e26f2499b5a692dd8d64adbd0faa88d","modified":1574748307221},{"_id":"public/images/logox128.png","hash":"afb06ae0c436c4b92b24b9c01c05ee405ae9136c","modified":1574748307221},{"_id":"public/images/logox64.png","hash":"9486ee278462af9612434eca0a19d70ec9ccb9c8","modified":1574748307221}],"Category":[{"name":"消息队列","_id":"ck38agcn60003jfus5224e1l8"},{"name":"docker","_id":"ck38agcok000cjfus1av5gw1d"},{"name":"java","_id":"ck38agcot000tjfus90ly0mlz"},{"name":"Git","_id":"ck38agcov000zjfusgl4gdrfz"},{"name":"Maven","_id":"ck38agcp10019jfusc0e0dgw8"},{"name":"JVM","_id":"ck38agcp1001djfus0rvxfngi"},{"name":"测试","_id":"ck38agcp4001ujfusb7qh5rm8"},{"name":"Linux","_id":"ck38agcp5001zjfusagsj0oga"}],"Data":[],"Page":[{"title":"关于","type":"about","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ntype: about\nlayout: \"about\"\ncomments: false\n---","date":"2019-10-24T12:53:32.928Z","updated":"2019-10-24T12:53:32.926Z","path":"about/index.html","_id":"ck38agcn00000jfuscvrg1j44","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","type":"categories","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: categories\nlayout: \"categories\"\ncomments: false\n---","date":"2019-10-24T12:54:11.888Z","updated":"2019-10-24T12:54:11.887Z","path":"categories/index.html","_id":"ck38agcn40002jfusbv8308np","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","type":"tags","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntype: tags\nlayout: \"tags\"\ncomments: false\n---","date":"2019-10-24T12:54:11.884Z","updated":"2019-10-24T12:54:11.878Z","path":"tags/index.html","_id":"ck38agcny0009jfusdw9l31yq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RabbitMQ实战","date":"2018-11-27T12:31:16.000Z","notshow":true,"_content":"![RabbitMQ](/image/rabbit/mq-login.jpg)\n# 1.消息中间件\n## 1.1 什么是消息中间\n`消息` (Message) 是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、\nJSON 等，也可以很复杂，比如内嵌对象。\n\n`消息队列中间件` (Message Queue Middleware，简称为 MQ) 是指利用高效可靠的消息传递 机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传 递和消息排队模型，它可以在分布式环境下扩展进程间的通信。\n\n消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:\n- `点对点` (P2P, Point-to-Point) 模式\n- `发布/订阅` (Pub/Sub) 模式。\n<!--more -->\n`点对点`是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的步传输成为可能。`发布订阅`定义了如何向一个内容节点发布和订阅消息，这个内容节点称为`主题`(topic)，`主题`可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而`消息订阅者`则从主题中订阅消息。`主题`使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消 息的传递，发布/订阅模式在消息的一对多广播时采用 。\n\n目前开源的消息中间件有很多，比较主流的有 `RabbitMQ`、 `Kafka`、 `ActiveMQ`、 `RocketMQ`等。\n\n## 1.2 消息中间件的作用\n消息中间件凭借其独到的特性，在不同的应用场景下可以展现不同的作用。总的来说，消息中间件的作用可以概括如下:\n### 1.2.1 `解耦`\n在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它 们遵守同样的接口约束即可。\n\n### 1.2.2 `冗余〈存储)`\n有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保 存直到你使用完毕。\n\n### 1.2.3 `扩展性`\n因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。\n\n### 1.2.4 `削峰`\n在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。\n\n### 1.2.5 `可恢复性`\n当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。\n\n### 1.2.6 `顺序保证`\n在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。\n\n### 1.2.7 `缓冲`\n在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制 和优化数据流经过系统的速度。\n\n### 1.2.8 `异步通信`\n在很多时候应用不想也不需要立即处理消息 。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。\n\n# 2.RabbitMQ入门\n## 2.1 RabbitMQ介绍\n`RabbitMQ`是采用`Erlang`语言实现`AMQP`(Advanced Message Queuing Protocol，高级消息\n队列协议)的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。并且支持多种客户端 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。在易用性、扩展性、高可用性等方面表现不俗。\n\nRabbitMQ主要是为了实现系统之间的`双向解耦`而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。\n\n`AMQP`是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是 **面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全**。\n\n## 2.2 RabbitMQ安装\n- 使用`docker`安装(3-management版本自带管理后台)\n```bash\n$ docker pull rabbitmq:3-management \n```\n- 启动RabbitMQ并且启动管理后台\n```bash\n$ docker run -d -p 15672:15672  -p  5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin --name rabbitmq --hostname=rabbitmqhostone  rabbitmq:3-management\n\n$ docker start rabbitmq\n```\n- 查看管理后台\n在浏览器打开 [http://localhost:15672/](http://localhost:15672/) 输入用户名:admin 密码:admin 可进入管理后台\n\n\n## 2.3 相关概念介绍\n### 2.3.1 生产者和消费者\n- `Producer`:生产者，就是投递消息的一方。\n生产者创建消息，然后发布到RabbitMQ中。消息一般可以包含2个部分:`消息体和标签(Label)`。消息体也可以称之为payload，在实际应用中，**消息体一般是一个带有业务逻辑结构的数据**，比如一个JSON字符串。当然可以进一步对这个消息体进行序列化操作。消息的标签用来表述这条消息，比如一个交换器的名称和一个路由键。生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签把消息发送给感兴趣的消费者(Consumer)。\n\n- `Consumer`:消费者，就是接收消息的一方。\n消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体(payload)在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体，也就不知道消息的生产者是谁，当然消费者也不需要知道。\n\n- `Broker`:消息中间件的服务节点。\n对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个`RabbitMQ服务节点`，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。\n\n**RabbitMQ运转流程**\n![RabbitMQ运转流程](/image/rabbit/mq-yunzhuanliucheng.jpg)\n\n### 2.3.2 交换器Exchange，路由RoutingKey，绑定Binding\n- `Exchange`:交换器\n![交换器](/image/rabbit/mq-exchange.jpg)\nMQ中我们暂时可以理解成 **生产者将消息投递到队列中**，但是实际上这个在RabbitMQ中不会发生。真实情况是，**生产者将消息发送到`Exchange(交换器)`，由交换器将消息路由到一个或者多个`队列`中。如果路由不到，或许会返回给生产者，或许直接丢弃**。\nRabbitMQ中的交换器有四种类型，下面将会一一介绍，并且会附上代码详细说明。\n\n- `RoutingKey`:路由键\n生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键(BindingKey)固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。\n\n- `Binding`:绑定\nRabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键(BindingKey)，这样RabbitMQ就知道如何正确地将消息路由到队列了，如下图所示:\n![绑定](/image/rabbit/mq-banding.jpg)\n\n### 2.3.3 交换器类型\nRabbitMQ常用的交换器类型有`fanout`、`direct`、`topic`和`headers`这四种。AMQP协议里其实还提\n到另外两种类型:`System`和`自定义`，在这里就不作详细介绍了。\n#### 2.3.3.1 `fanout`\n就是我们熟悉的广播模式或者订阅模式，它会把所有发送到该ExChange的消息全部路由到所有与该交换器绑定的队列中。如下图：\n![fanout](/image/rabbit/mq-fanout.jpg)\n#### 2.3.3.2 `direct`(RabbitMQ默认的交换器类型)\ndirect类型的交换器路由规则也很简单，它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。如下图：\n![direct](/image/rabbit/mq-direct.jpg)\n#### 2.3.3.3 topic\n上面讲到`direct类型`的交换器路由规则是完全匹配BindingKey和RoutingKey，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。`topic类型`的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定:\n- RoutingKey为一个点号`.`分隔的字符串(被点号`.`分隔开的每一段独立的字符串称为一个单词)，如\"com.rabbitmq.client\"，\"java.util.concurrent\",\"com.hidden.client\"等\n- BindingKey也是点号`.`分隔\n- BindingKey中可以存在两种特殊字符串`*`和`#`，用于做模糊匹配，其中`*`用于匹配一个单词，`#`用于匹配多规格单词(可以是零个)。\n如下图：\n![topic](/image/rabbit/mq-topic.jpg)\n思考: \n1.路由建 \"com.rabbitmq.client\"会路由到哪一个队列？\n2.路由建 \"com.hidden.client\"会路由到哪一个队列？\n3.路由建 \"com.hidden.demo\"会路由到哪一个队列？\n4.路由建 \"java.util.concurrent\"会路由到哪一个队列？\n5.路由建 \"java.rabbitmq.demo\"会路由到哪一个队列？\n\n#### 2.3.3.4 headers(不常用)\n`headers类型`的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers(也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。**headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在** 所以对于headers类型交换器我们只需要了解即可，知道有这么个类型存在。\n\n\n## 2.4 交换器类型详解\n### 2.4.1 新建\n新建rabbit-demo工程，在其中新建两个mudle 一个为rabbit-consumer 另一个为rabbit-producer\npom.xml\n```POM\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n  </dependency>\n\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n  </dependency>\n```\nrabbit-producer/application.properties\n```\nserver.port=1180\n# 端口 1181 消费者  1180 生产者\n\nspring.rabbitmq.host=127.0.0.1\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=admin\nspring.rabbitmq.port=5672\n```\nrabbit-producer/application.properties\n```\nserver.port=1181\n# 端口 1181 消费者  1180 生产者\n\nspring.rabbitmq.host=127.0.0.1\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=admin\nspring.rabbitmq.port=5672\n```\n项目创建完成\n\n### 2.4.2 声明一个队列各个参数的意义\n- `name`: 队列的名称 字符串;\n- `durable`: 是否持久化, 队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库;\n- `exclusive`: 是否排外的，有两个作用，一：当连接关闭时connection.close()该队列是否会自动删除；二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常，一般等于true的话用于一个队列只能有一个消费者来消费的场景。\n- `autoDelete`: 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除\n- `arguments`: 队列中的消息什么时候会自动被删除？ 是一个Map<String, Object>，它有如下参数:\n   - \"x-message-ttl\": 1000  设置队列中的所有消息的生存周期\n   - \"x-expires\": 1000  当队列在指定的时间没有被访问就会被删除\n   - \"x-max-length\": 10  限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉\n   - \"x-max-length-bytes\":  限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小\n   - \"x-dead-letter-exchange\": \"\" 当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉\n   - \"x-dead-letter-routing-key\": \"\"  将删除的消息推送到指定交换机的指定路由键的队列中去\n   - \"x-max-priority\":  优先级队列，声明队列时先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费\n   - \"x-queue-mode\": \"lazy\" 先将消息保存到磁盘上，不放在内存中，当消费者开始消费的时候才加载到内存中\n   - \"x-queue-master-locator\"\n\n### 2.4.3 fanout代码实现\n#### 2.4.3.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.fanout;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.FanoutExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author liuyi\n * @date 2018/12/1 4:35 PM\n */\n@Configuration\npublic class FanoutConfig {\n\n    // 声明一个队列，后面有很多属性\n    @Bean\n    public Queue fanoutQueue1(){\n        return new Queue(\"fanout.queue1\");\n    }\n\n    @Bean\n    public Queue fanoutQueue2(){\n        return new Queue(\"fanout.queue2\");\n    }\n\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange(\"fanout_exchange\");\n    }\n\n    @Bean\n    public Binding fanoutBinding1(){\n        return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());\n    }\n\n    @Bean\n    public Binding fanoutBinding2(){\n        return BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange());\n    }\n\n}\n```\n#### 2.4.3.2 在消费者项目中添加一个消息监听类\n```JAVA\npackage com.jiafly.rabbit.consumer.fanout;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author liuyi\n * @date 2018/12/1 4:40 PM\n */\n@Component\n@Slf4j\npublic class FanoutConsumer {\n\n    @RabbitListener(queues = \"fanout.queue1\")\n    @RabbitHandler\n    public void fanoutConsumer1(String msg){\n        log.info(\"1fanoutConsumer 接收消息msg: {}\", msg);\n    }\n\n\n    @RabbitListener(queues = \"fanout.queue2\")\n    @RabbitHandler\n    public void fanoutConsumer2(String msg){\n        log.info(\"2fanoutConsumer 接收消息msg: {}\", msg);\n    }\n\n}\n```\n#### 2.4.3.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/11/28 11:50 AM\n * 生产者\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class FanoutProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * fanout类型\n     * @param msg 消息内容\n     * @return 消息内容\n     * 虽然fanout类型下不需要routingKey 但是在调用convertAndSend方法时还是需要配置routingKey\n     * 只是routingKey可以任意指定\n     */\n    @RequestMapping(\"/fanout/{msg}\")\n    public String fanoutProducer(@PathVariable(\"msg\") String msg){\n        log.info(\"fanout生产消息 msg:{}\", msg);\n        // 第一个参数是交换器名称 第二个参数是routingKey名称，fanout模式写任何key都会被无视 第三个是要发送的消息\n        template.convertAndSend(\"fanout_exchange\",\"\", msg);\n        return msg;\n    }\n}\n```\n#### 2.4.3.4 测试\n分别启动这两个项目，在浏览器的路径上输入[http://localhost:1180/fanout/测试消息](http://localhost:1180/fanout/测试消息)，就可在消费者项目控制台中看到绑定这个fanout模式交换器的队列接收到的消息在控制台打印出来了。\n\n### 2.4.4 direct代码实现\n#### 2.4.4.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.direct;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.DirectExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author liuyi\n * @date 2018/11/29 1:40 AM\n */\n@Configuration\npublic class DirectConfig {\n\n    /**\n     * 定义两个队列\n     * @return\n     */\n    @Bean\n    public Queue directQueue1() {\n        return new Queue(\"direct.queue1\",true);\n    }\n\n    @Bean\n    public Queue directQueue2() {\n        return new Queue(\"direct.queue2\", true);\n    }\n\n    @Bean\n    public Queue directQueue3() {\n        Map<String, Object> map = new HashMap<>(16);\n        return new Queue(\"direct.queue3\",true,true, true, map);\n    }\n\n\n    /**\n     * 定义 exchange\n     * @return\n     */\n    @Bean\n    public DirectExchange directExchange() {\n        return new DirectExchange(\"direct_exchange\",true,true);\n    }\n\n    /**\n     * 队列1 绑定 exchange 并且设置routingKey为direct.1\n     * @return\n     */\n    @Bean\n    public Binding directBinding1(){\n        return BindingBuilder.bind(directQueue1()).to(directExchange()).with(\"direct.routing.key1\");\n    }\n\n    /**\n     * 队列2 绑定 exchange 并且设置routingKey为direct.2\n     * @return\n     */\n    @Bean\n    public Binding directBinding2(){\n        return BindingBuilder.bind(directQueue2()).to(directExchange()).with(\"direct.routing.key2\");\n    }\n\n    @Bean\n    public Binding directBinding3(){\n        return BindingBuilder.bind(directQueue3()).to(directExchange()).with(\"direct.routing.key1\");\n    }\n}\n```\n#### 2.4.4.2 在消费者项目中添加一个消息监听类\n```JAVA\n和fanout相同，只是监听的队列不同而已\n```\n#### 2.4.4.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/11/28 11:50 AM\n * 生产者\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class DirectProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * direct类型\n     * @param msg 消息内容\n     * @return 消息内容\n     */\n    @RequestMapping(\"/direct/queue1/{msg}\")\n    public String directProducerOne(@PathVariable(\"msg\") String msg) {\n        log.info(\"生产者生产消息:\" + msg);\n        // 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息\n        template.convertAndSend(\"direct_exchange\", \"direct.routing.key1\", msg);\n        return msg;\n    }\n\n    @RequestMapping(\"/direct/queue2/{msg}\")\n    public String directProducerTwo(@PathVariable(\"msg\") String msg) {\n        log.info(\"生产者生产消息:\" + msg);\n        // 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息\n        template.convertAndSend(\"mq-direct_exchange\", \"direct.routing.key2\", msg);\n        return msg;\n    }\n}\n```\n#### 2.4.4.4 测试\n分别启动两个项目，在浏览器的路径上输入 http://localhost:1180/direct/queue1/测试消息1 ，就可在消费者项目中看到打印的信息。\n如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey设置为一样即可\n\n### 2.4.5 topic代码实现\n#### 2.4.5.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.topic;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.core.TopicExchange;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author liuyi\n * @date 2018/11/29 8:42 AM\n */\n@Configuration\npublic class TopicConfig {\n\n    /**\n     * 创建队列\n     *\n     * @return\n     */\n    @Bean\n    public Queue topicQueue1() {\n        return new Queue(\"topic.queue1\", true);\n    }\n\n    @Bean\n    public Queue topicQueue2() {\n        return new Queue(\"topic.queue2\", true);\n    }\n\n    /**\n     * 创建交换器\n     */\n    @Bean\n    public TopicExchange topicExchange() {\n        return new TopicExchange(\"topic_exchange\");\n    }\n\n    /**\n     * 绑定\n     */\n    @Bean\n    public Binding topicBinding1() {\n        return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(\"*.jiafly.*\");\n    }\n\n    @Bean\n    public Binding topicBinding2() {\n        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(\"com.jiafly.*\");\n    }\n}\n```\n#### 2.4.5.2 在消费者项目中添加一个消息监听类\n```JAVA\n// 和fanout类型相同，只是监听的队列不同而已\n```\n#### 2.4.5.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/11/28 11:50 AM\n * 生产者\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class TopicProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * topic类型\n     * @param msg 消息内容\n     * @return 消息内容\n     */\n    @RequestMapping(\"/topic/{msg}\")\n    public String topicProducerOne(@PathVariable(\"msg\") String msg) {\n        log.info(\"topic:生产消息:\" + msg);\n        template.convertAndSend(\"topic_exchange\", \"com.jiafly.test\", msg);\n        return msg;\n    }\n}\n```\n#### 2.4.5.4 测试\n分别启动两个项目，在浏览器的路径上输入[http://localhost:1180/topic/测试消息](http://localhost:1180/topic/测试消息) ，就可在消费者项目中看到打印的信息。\n如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey使用`*`或者`#`表示\n\n\n## 2.5 延时队列\n### 2.5.1 延时队列能做什么\n- 订单业务：在电商/点餐中，都有下单后 30 分钟内没有付款，就自动取消订单。\n- 短信通知：下单成功后 60s 之后给用户发送短信通知。\n- 失败重试：业务操作失败后，间隔一定的时间进行失败重试\n\n这类业务的特点就是：非实时的，需要延迟处理，需要进行失败重试。一种比较笨的方式是采用定时任务，轮训数据库，方法简单好用，但性能底下，在高并发情况下容易弄死数据库，间隔时间不好设置，时间过大，影响精度，过小影响性能，而且做不到按超时的时间顺序处理。另一种就是用Java中的DelayQueue 位于java.util.concurrent包下，本质是由PriorityQueue和BlockingQueue实现的阻塞优先级队列。，这玩意最大的问题就是不支持分布式与持久化。\n\n在 AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面 所介绍的 DLX 和 TTL 模拟出延迟队列的功能。所以在介绍延时队列之前，首先介绍下DLX(Dead-Letter-Exchange)和TTL(Time to Live)。\n![延时队列](/image/rabbit/delay-mq.jpg)\n### 2.5.2 死信交换器DLX(Dead-Letter-Exchange)\nDLX：死信队列，用来存储有超时时间信息的消息， 并且可以设置当消息超时时，转发到另一个指定队列(此处设置转发到router), 无消费者，当接收到客户端消息之后，等待消息超时，将消息转发到指定的Router队列。\n\nRouter: 转发队列，用来接收死信队列超时消息， 如上示例消息，在接收到之后，消费者将消息解析，获取queueName，body,再向所获取的queueName队列发送一条消息，内容为body.\n\n具体代码实现:\n#### 2.5.2.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.delay;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.DirectExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\n\n/**\n * @author liuyi\n * @date 2018/12/2 12:44 AM\n */\n@Configuration\npublic class DelayConfig {\n\n    /**\n     * 定义一个交换机\n     *\n     * @return\n     */\n    @Bean\n    public DirectExchange delayExchange() {\n        return new DirectExchange(\"delay_exchange\", true, false);\n    }\n\n    /**\n     * 转发队列\n     *\n     * @return\n     */\n    @Bean\n    public Queue routerQueue() {\n        return new Queue(\"router.queue\", true, false, false);\n    }\n\n    /**\n     * 转发队列绑定交换机\n     *\n     * @return\n     */\n    @Bean\n    public Binding routerBinding() {\n        return BindingBuilder.bind(routerQueue()).to(delayExchange()).with(\"router.routing.key\");\n    }\n\n\n    /**\n     * 死信队列\n     *\n     * @return\n     */\n    @Bean\n    public Queue deadLetterQueue() {\n        HashMap<String, Object> arguments = new HashMap(16);\n        arguments.put(\"x-dead-letter-exchange\", \"delay_exchange\");\n        arguments.put(\"x-dead-letter-routing-key\", \"router.routing.key\");\n        return new Queue(\"dead.letter.queue\", true, false, false, arguments);\n    }\n\n\n    /**\n     * 死信队列绑定交换机\n     *\n     * @return\n     */\n    @Bean\n    public Binding deadLetterBinding() {\n        return BindingBuilder.bind(deadLetterQueue()).to(delayExchange()).with(\"dead.letter.routing.key\");\n    }\n}\n```\n#### 2.5.2.2 在消费者项目中添加一个消息监听类\n```JAVA\npackage com.jiafly.rabbit.consumer.delay;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author liuyi\n * @date 2018/12/3 6:13 PM\n */\n@Component\n@Slf4j\npublic class DelayConsumer {\n\n    @RabbitListener(queues = \"router.queue\")\n    @RabbitHandler\n    public void delayConsumer(String msg) {\n        log.info(\"delay.queue1接收消息:{}\", msg);\n    }\n}\n```\n#### 2.5.2.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.amqp.support.converter.AbstractJavaTypeMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/12/3 7:17 PM\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class DelayProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * 延迟队列\n     * @param msg 消息内容\n     * @return 消息内容\n     */\n    @RequestMapping(\"/delay/{msg}\")\n    public String delayProducerOne(@PathVariable(\"msg\") String msg) {\n        log.info(\"delay:生产消息:\" + msg);\n        template.convertAndSend(\"delay_exchange\", \"dead.letter.routing.key\", msg, message -> {\n            message.getMessageProperties().setExpiration(30 * 1000 + \"\");\n            return message;\n        });\n        return msg;\n    }\n}\n```\n#### 2.5.2.4 测试\n分别启动两个项目，在浏览器的路径上输入[http://localhost:1180/delay/测试消息](http://localhost:1180/delay/测试消息)，就可在消费者项目中看到打印的信息。30秒后可以看到消费者管理后台有刚刚发送的消息被打印出来了。\n\n\n## 2.6 消息的持久化\n为了保证RabbitMQ在重启、奔溃等异常情况下数据没有丢失，除了对消息本身持久化为，还需要将消息传输经过的队列(queue)，交互机进行持久化(exchange)，持久化以上元素后，消息才算真正RabbitMQ重启不会丢失。\n创建时候的参数:\n- `durable` \n是否持久化，如果true，则此种队列叫持久化队列（Durable queues）。此队列会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。 \n- `execulusive` \n表示此对应只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable \n- `autoDelete` \n当没有生成者/消费者使用此队列时，此队列会被自动删除。 \n(即当最后一个消费者退订后即被删除)\n\n\n**设置消息持久化必须先设置队列持久化**，要不然队列不持久化，消息持久化，队列都不存在了，消息存在还有什么意义。`消息持久化需要将交换机持久化、队列持久化、消息持久化，才能最终达到持久化的目的`。其实在前面就已经使用持久化了。我们在管理后台去看一下。\n\n\n## 2.7 消息的确认与拒绝\n消费者在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题，对于此AMQP有两种处理方式：\n- `自动确认模式`:\n当RabbbitMQ将消息发送给应用后，消费者端自动回送一个确认消息，此时RabbitMQ删除此消息。\n\n- `显式确认模式`:\n消费者收到消息后，可以在执行一些逻辑后，消费者自己决定什么时候发送确认回执（acknowledgement），RabbitMQ收到回执后才删除消息，这样就保证消费端不会丢失消息\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那么消息会被重新放入队列，并且在还有其他消费者存在于此队列的前提下，立即投递给另外一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。RabbitMQ里的消息是不会过期。当消费者挂掉后，RabbitMQ会不断尝试重推。所有单个消息的推送可能花费很长的时间。\n\n\n\n","source":"_posts/RabbitMQ.md","raw":"---\ntitle: RabbitMQ实战\ndate: 2018-11-27 20:31:16\ntags:\n    - RabbitMQ\n    - 消息队列\ncategories: \n    - 消息队列\nnotshow: true\n---\n![RabbitMQ](/image/rabbit/mq-login.jpg)\n# 1.消息中间件\n## 1.1 什么是消息中间\n`消息` (Message) 是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、\nJSON 等，也可以很复杂，比如内嵌对象。\n\n`消息队列中间件` (Message Queue Middleware，简称为 MQ) 是指利用高效可靠的消息传递 机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传 递和消息排队模型，它可以在分布式环境下扩展进程间的通信。\n\n消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:\n- `点对点` (P2P, Point-to-Point) 模式\n- `发布/订阅` (Pub/Sub) 模式。\n<!--more -->\n`点对点`是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的步传输成为可能。`发布订阅`定义了如何向一个内容节点发布和订阅消息，这个内容节点称为`主题`(topic)，`主题`可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而`消息订阅者`则从主题中订阅消息。`主题`使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消 息的传递，发布/订阅模式在消息的一对多广播时采用 。\n\n目前开源的消息中间件有很多，比较主流的有 `RabbitMQ`、 `Kafka`、 `ActiveMQ`、 `RocketMQ`等。\n\n## 1.2 消息中间件的作用\n消息中间件凭借其独到的特性，在不同的应用场景下可以展现不同的作用。总的来说，消息中间件的作用可以概括如下:\n### 1.2.1 `解耦`\n在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它 们遵守同样的接口约束即可。\n\n### 1.2.2 `冗余〈存储)`\n有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保 存直到你使用完毕。\n\n### 1.2.3 `扩展性`\n因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。\n\n### 1.2.4 `削峰`\n在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。\n\n### 1.2.5 `可恢复性`\n当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。\n\n### 1.2.6 `顺序保证`\n在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。\n\n### 1.2.7 `缓冲`\n在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制 和优化数据流经过系统的速度。\n\n### 1.2.8 `异步通信`\n在很多时候应用不想也不需要立即处理消息 。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。\n\n# 2.RabbitMQ入门\n## 2.1 RabbitMQ介绍\n`RabbitMQ`是采用`Erlang`语言实现`AMQP`(Advanced Message Queuing Protocol，高级消息\n队列协议)的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。并且支持多种客户端 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。在易用性、扩展性、高可用性等方面表现不俗。\n\nRabbitMQ主要是为了实现系统之间的`双向解耦`而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。\n\n`AMQP`是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是 **面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全**。\n\n## 2.2 RabbitMQ安装\n- 使用`docker`安装(3-management版本自带管理后台)\n```bash\n$ docker pull rabbitmq:3-management \n```\n- 启动RabbitMQ并且启动管理后台\n```bash\n$ docker run -d -p 15672:15672  -p  5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin --name rabbitmq --hostname=rabbitmqhostone  rabbitmq:3-management\n\n$ docker start rabbitmq\n```\n- 查看管理后台\n在浏览器打开 [http://localhost:15672/](http://localhost:15672/) 输入用户名:admin 密码:admin 可进入管理后台\n\n\n## 2.3 相关概念介绍\n### 2.3.1 生产者和消费者\n- `Producer`:生产者，就是投递消息的一方。\n生产者创建消息，然后发布到RabbitMQ中。消息一般可以包含2个部分:`消息体和标签(Label)`。消息体也可以称之为payload，在实际应用中，**消息体一般是一个带有业务逻辑结构的数据**，比如一个JSON字符串。当然可以进一步对这个消息体进行序列化操作。消息的标签用来表述这条消息，比如一个交换器的名称和一个路由键。生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签把消息发送给感兴趣的消费者(Consumer)。\n\n- `Consumer`:消费者，就是接收消息的一方。\n消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体(payload)在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体，也就不知道消息的生产者是谁，当然消费者也不需要知道。\n\n- `Broker`:消息中间件的服务节点。\n对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个`RabbitMQ服务节点`，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。\n\n**RabbitMQ运转流程**\n![RabbitMQ运转流程](/image/rabbit/mq-yunzhuanliucheng.jpg)\n\n### 2.3.2 交换器Exchange，路由RoutingKey，绑定Binding\n- `Exchange`:交换器\n![交换器](/image/rabbit/mq-exchange.jpg)\nMQ中我们暂时可以理解成 **生产者将消息投递到队列中**，但是实际上这个在RabbitMQ中不会发生。真实情况是，**生产者将消息发送到`Exchange(交换器)`，由交换器将消息路由到一个或者多个`队列`中。如果路由不到，或许会返回给生产者，或许直接丢弃**。\nRabbitMQ中的交换器有四种类型，下面将会一一介绍，并且会附上代码详细说明。\n\n- `RoutingKey`:路由键\n生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键(BindingKey)固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。\n\n- `Binding`:绑定\nRabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键(BindingKey)，这样RabbitMQ就知道如何正确地将消息路由到队列了，如下图所示:\n![绑定](/image/rabbit/mq-banding.jpg)\n\n### 2.3.3 交换器类型\nRabbitMQ常用的交换器类型有`fanout`、`direct`、`topic`和`headers`这四种。AMQP协议里其实还提\n到另外两种类型:`System`和`自定义`，在这里就不作详细介绍了。\n#### 2.3.3.1 `fanout`\n就是我们熟悉的广播模式或者订阅模式，它会把所有发送到该ExChange的消息全部路由到所有与该交换器绑定的队列中。如下图：\n![fanout](/image/rabbit/mq-fanout.jpg)\n#### 2.3.3.2 `direct`(RabbitMQ默认的交换器类型)\ndirect类型的交换器路由规则也很简单，它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。如下图：\n![direct](/image/rabbit/mq-direct.jpg)\n#### 2.3.3.3 topic\n上面讲到`direct类型`的交换器路由规则是完全匹配BindingKey和RoutingKey，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。`topic类型`的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定:\n- RoutingKey为一个点号`.`分隔的字符串(被点号`.`分隔开的每一段独立的字符串称为一个单词)，如\"com.rabbitmq.client\"，\"java.util.concurrent\",\"com.hidden.client\"等\n- BindingKey也是点号`.`分隔\n- BindingKey中可以存在两种特殊字符串`*`和`#`，用于做模糊匹配，其中`*`用于匹配一个单词，`#`用于匹配多规格单词(可以是零个)。\n如下图：\n![topic](/image/rabbit/mq-topic.jpg)\n思考: \n1.路由建 \"com.rabbitmq.client\"会路由到哪一个队列？\n2.路由建 \"com.hidden.client\"会路由到哪一个队列？\n3.路由建 \"com.hidden.demo\"会路由到哪一个队列？\n4.路由建 \"java.util.concurrent\"会路由到哪一个队列？\n5.路由建 \"java.rabbitmq.demo\"会路由到哪一个队列？\n\n#### 2.3.3.4 headers(不常用)\n`headers类型`的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers(也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。**headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在** 所以对于headers类型交换器我们只需要了解即可，知道有这么个类型存在。\n\n\n## 2.4 交换器类型详解\n### 2.4.1 新建\n新建rabbit-demo工程，在其中新建两个mudle 一个为rabbit-consumer 另一个为rabbit-producer\npom.xml\n```POM\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n  </dependency>\n\n  <dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <optional>true</optional>\n  </dependency>\n```\nrabbit-producer/application.properties\n```\nserver.port=1180\n# 端口 1181 消费者  1180 生产者\n\nspring.rabbitmq.host=127.0.0.1\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=admin\nspring.rabbitmq.port=5672\n```\nrabbit-producer/application.properties\n```\nserver.port=1181\n# 端口 1181 消费者  1180 生产者\n\nspring.rabbitmq.host=127.0.0.1\nspring.rabbitmq.username=admin\nspring.rabbitmq.password=admin\nspring.rabbitmq.port=5672\n```\n项目创建完成\n\n### 2.4.2 声明一个队列各个参数的意义\n- `name`: 队列的名称 字符串;\n- `durable`: 是否持久化, 队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库;\n- `exclusive`: 是否排外的，有两个作用，一：当连接关闭时connection.close()该队列是否会自动删除；二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常，一般等于true的话用于一个队列只能有一个消费者来消费的场景。\n- `autoDelete`: 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除\n- `arguments`: 队列中的消息什么时候会自动被删除？ 是一个Map<String, Object>，它有如下参数:\n   - \"x-message-ttl\": 1000  设置队列中的所有消息的生存周期\n   - \"x-expires\": 1000  当队列在指定的时间没有被访问就会被删除\n   - \"x-max-length\": 10  限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉\n   - \"x-max-length-bytes\":  限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小\n   - \"x-dead-letter-exchange\": \"\" 当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉\n   - \"x-dead-letter-routing-key\": \"\"  将删除的消息推送到指定交换机的指定路由键的队列中去\n   - \"x-max-priority\":  优先级队列，声明队列时先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费\n   - \"x-queue-mode\": \"lazy\" 先将消息保存到磁盘上，不放在内存中，当消费者开始消费的时候才加载到内存中\n   - \"x-queue-master-locator\"\n\n### 2.4.3 fanout代码实现\n#### 2.4.3.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.fanout;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.FanoutExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author liuyi\n * @date 2018/12/1 4:35 PM\n */\n@Configuration\npublic class FanoutConfig {\n\n    // 声明一个队列，后面有很多属性\n    @Bean\n    public Queue fanoutQueue1(){\n        return new Queue(\"fanout.queue1\");\n    }\n\n    @Bean\n    public Queue fanoutQueue2(){\n        return new Queue(\"fanout.queue2\");\n    }\n\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange(\"fanout_exchange\");\n    }\n\n    @Bean\n    public Binding fanoutBinding1(){\n        return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());\n    }\n\n    @Bean\n    public Binding fanoutBinding2(){\n        return BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange());\n    }\n\n}\n```\n#### 2.4.3.2 在消费者项目中添加一个消息监听类\n```JAVA\npackage com.jiafly.rabbit.consumer.fanout;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author liuyi\n * @date 2018/12/1 4:40 PM\n */\n@Component\n@Slf4j\npublic class FanoutConsumer {\n\n    @RabbitListener(queues = \"fanout.queue1\")\n    @RabbitHandler\n    public void fanoutConsumer1(String msg){\n        log.info(\"1fanoutConsumer 接收消息msg: {}\", msg);\n    }\n\n\n    @RabbitListener(queues = \"fanout.queue2\")\n    @RabbitHandler\n    public void fanoutConsumer2(String msg){\n        log.info(\"2fanoutConsumer 接收消息msg: {}\", msg);\n    }\n\n}\n```\n#### 2.4.3.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/11/28 11:50 AM\n * 生产者\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class FanoutProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * fanout类型\n     * @param msg 消息内容\n     * @return 消息内容\n     * 虽然fanout类型下不需要routingKey 但是在调用convertAndSend方法时还是需要配置routingKey\n     * 只是routingKey可以任意指定\n     */\n    @RequestMapping(\"/fanout/{msg}\")\n    public String fanoutProducer(@PathVariable(\"msg\") String msg){\n        log.info(\"fanout生产消息 msg:{}\", msg);\n        // 第一个参数是交换器名称 第二个参数是routingKey名称，fanout模式写任何key都会被无视 第三个是要发送的消息\n        template.convertAndSend(\"fanout_exchange\",\"\", msg);\n        return msg;\n    }\n}\n```\n#### 2.4.3.4 测试\n分别启动这两个项目，在浏览器的路径上输入[http://localhost:1180/fanout/测试消息](http://localhost:1180/fanout/测试消息)，就可在消费者项目控制台中看到绑定这个fanout模式交换器的队列接收到的消息在控制台打印出来了。\n\n### 2.4.4 direct代码实现\n#### 2.4.4.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.direct;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.DirectExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @author liuyi\n * @date 2018/11/29 1:40 AM\n */\n@Configuration\npublic class DirectConfig {\n\n    /**\n     * 定义两个队列\n     * @return\n     */\n    @Bean\n    public Queue directQueue1() {\n        return new Queue(\"direct.queue1\",true);\n    }\n\n    @Bean\n    public Queue directQueue2() {\n        return new Queue(\"direct.queue2\", true);\n    }\n\n    @Bean\n    public Queue directQueue3() {\n        Map<String, Object> map = new HashMap<>(16);\n        return new Queue(\"direct.queue3\",true,true, true, map);\n    }\n\n\n    /**\n     * 定义 exchange\n     * @return\n     */\n    @Bean\n    public DirectExchange directExchange() {\n        return new DirectExchange(\"direct_exchange\",true,true);\n    }\n\n    /**\n     * 队列1 绑定 exchange 并且设置routingKey为direct.1\n     * @return\n     */\n    @Bean\n    public Binding directBinding1(){\n        return BindingBuilder.bind(directQueue1()).to(directExchange()).with(\"direct.routing.key1\");\n    }\n\n    /**\n     * 队列2 绑定 exchange 并且设置routingKey为direct.2\n     * @return\n     */\n    @Bean\n    public Binding directBinding2(){\n        return BindingBuilder.bind(directQueue2()).to(directExchange()).with(\"direct.routing.key2\");\n    }\n\n    @Bean\n    public Binding directBinding3(){\n        return BindingBuilder.bind(directQueue3()).to(directExchange()).with(\"direct.routing.key1\");\n    }\n}\n```\n#### 2.4.4.2 在消费者项目中添加一个消息监听类\n```JAVA\n和fanout相同，只是监听的队列不同而已\n```\n#### 2.4.4.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/11/28 11:50 AM\n * 生产者\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class DirectProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * direct类型\n     * @param msg 消息内容\n     * @return 消息内容\n     */\n    @RequestMapping(\"/direct/queue1/{msg}\")\n    public String directProducerOne(@PathVariable(\"msg\") String msg) {\n        log.info(\"生产者生产消息:\" + msg);\n        // 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息\n        template.convertAndSend(\"direct_exchange\", \"direct.routing.key1\", msg);\n        return msg;\n    }\n\n    @RequestMapping(\"/direct/queue2/{msg}\")\n    public String directProducerTwo(@PathVariable(\"msg\") String msg) {\n        log.info(\"生产者生产消息:\" + msg);\n        // 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息\n        template.convertAndSend(\"mq-direct_exchange\", \"direct.routing.key2\", msg);\n        return msg;\n    }\n}\n```\n#### 2.4.4.4 测试\n分别启动两个项目，在浏览器的路径上输入 http://localhost:1180/direct/queue1/测试消息1 ，就可在消费者项目中看到打印的信息。\n如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey设置为一样即可\n\n### 2.4.5 topic代码实现\n#### 2.4.5.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.topic;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.core.TopicExchange;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author liuyi\n * @date 2018/11/29 8:42 AM\n */\n@Configuration\npublic class TopicConfig {\n\n    /**\n     * 创建队列\n     *\n     * @return\n     */\n    @Bean\n    public Queue topicQueue1() {\n        return new Queue(\"topic.queue1\", true);\n    }\n\n    @Bean\n    public Queue topicQueue2() {\n        return new Queue(\"topic.queue2\", true);\n    }\n\n    /**\n     * 创建交换器\n     */\n    @Bean\n    public TopicExchange topicExchange() {\n        return new TopicExchange(\"topic_exchange\");\n    }\n\n    /**\n     * 绑定\n     */\n    @Bean\n    public Binding topicBinding1() {\n        return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(\"*.jiafly.*\");\n    }\n\n    @Bean\n    public Binding topicBinding2() {\n        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(\"com.jiafly.*\");\n    }\n}\n```\n#### 2.4.5.2 在消费者项目中添加一个消息监听类\n```JAVA\n// 和fanout类型相同，只是监听的队列不同而已\n```\n#### 2.4.5.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/11/28 11:50 AM\n * 生产者\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class TopicProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * topic类型\n     * @param msg 消息内容\n     * @return 消息内容\n     */\n    @RequestMapping(\"/topic/{msg}\")\n    public String topicProducerOne(@PathVariable(\"msg\") String msg) {\n        log.info(\"topic:生产消息:\" + msg);\n        template.convertAndSend(\"topic_exchange\", \"com.jiafly.test\", msg);\n        return msg;\n    }\n}\n```\n#### 2.4.5.4 测试\n分别启动两个项目，在浏览器的路径上输入[http://localhost:1180/topic/测试消息](http://localhost:1180/topic/测试消息) ，就可在消费者项目中看到打印的信息。\n如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey使用`*`或者`#`表示\n\n\n## 2.5 延时队列\n### 2.5.1 延时队列能做什么\n- 订单业务：在电商/点餐中，都有下单后 30 分钟内没有付款，就自动取消订单。\n- 短信通知：下单成功后 60s 之后给用户发送短信通知。\n- 失败重试：业务操作失败后，间隔一定的时间进行失败重试\n\n这类业务的特点就是：非实时的，需要延迟处理，需要进行失败重试。一种比较笨的方式是采用定时任务，轮训数据库，方法简单好用，但性能底下，在高并发情况下容易弄死数据库，间隔时间不好设置，时间过大，影响精度，过小影响性能，而且做不到按超时的时间顺序处理。另一种就是用Java中的DelayQueue 位于java.util.concurrent包下，本质是由PriorityQueue和BlockingQueue实现的阻塞优先级队列。，这玩意最大的问题就是不支持分布式与持久化。\n\n在 AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面 所介绍的 DLX 和 TTL 模拟出延迟队列的功能。所以在介绍延时队列之前，首先介绍下DLX(Dead-Letter-Exchange)和TTL(Time to Live)。\n![延时队列](/image/rabbit/delay-mq.jpg)\n### 2.5.2 死信交换器DLX(Dead-Letter-Exchange)\nDLX：死信队列，用来存储有超时时间信息的消息， 并且可以设置当消息超时时，转发到另一个指定队列(此处设置转发到router), 无消费者，当接收到客户端消息之后，等待消息超时，将消息转发到指定的Router队列。\n\nRouter: 转发队列，用来接收死信队列超时消息， 如上示例消息，在接收到之后，消费者将消息解析，获取queueName，body,再向所获取的queueName队列发送一条消息，内容为body.\n\n具体代码实现:\n#### 2.5.2.1 在消费者项目中添加一个配置类\n```JAVA\npackage com.jiafly.rabbit.consumer.delay;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.DirectExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.util.HashMap;\n\n/**\n * @author liuyi\n * @date 2018/12/2 12:44 AM\n */\n@Configuration\npublic class DelayConfig {\n\n    /**\n     * 定义一个交换机\n     *\n     * @return\n     */\n    @Bean\n    public DirectExchange delayExchange() {\n        return new DirectExchange(\"delay_exchange\", true, false);\n    }\n\n    /**\n     * 转发队列\n     *\n     * @return\n     */\n    @Bean\n    public Queue routerQueue() {\n        return new Queue(\"router.queue\", true, false, false);\n    }\n\n    /**\n     * 转发队列绑定交换机\n     *\n     * @return\n     */\n    @Bean\n    public Binding routerBinding() {\n        return BindingBuilder.bind(routerQueue()).to(delayExchange()).with(\"router.routing.key\");\n    }\n\n\n    /**\n     * 死信队列\n     *\n     * @return\n     */\n    @Bean\n    public Queue deadLetterQueue() {\n        HashMap<String, Object> arguments = new HashMap(16);\n        arguments.put(\"x-dead-letter-exchange\", \"delay_exchange\");\n        arguments.put(\"x-dead-letter-routing-key\", \"router.routing.key\");\n        return new Queue(\"dead.letter.queue\", true, false, false, arguments);\n    }\n\n\n    /**\n     * 死信队列绑定交换机\n     *\n     * @return\n     */\n    @Bean\n    public Binding deadLetterBinding() {\n        return BindingBuilder.bind(deadLetterQueue()).to(delayExchange()).with(\"dead.letter.routing.key\");\n    }\n}\n```\n#### 2.5.2.2 在消费者项目中添加一个消息监听类\n```JAVA\npackage com.jiafly.rabbit.consumer.delay;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author liuyi\n * @date 2018/12/3 6:13 PM\n */\n@Component\n@Slf4j\npublic class DelayConsumer {\n\n    @RabbitListener(queues = \"router.queue\")\n    @RabbitHandler\n    public void delayConsumer(String msg) {\n        log.info(\"delay.queue1接收消息:{}\", msg);\n    }\n}\n```\n#### 2.5.2.3 在生产者项目中添加一个消息发送controller\n```JAVA\npackage com.jiafly.rabbit.producer;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.amqp.support.converter.AbstractJavaTypeMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * @author liuyi\n * @date 2018/12/3 7:17 PM\n */\n@RestController\n@RequestMapping()\n@Slf4j\npublic class DelayProducer {\n\n    @Autowired\n    private AmqpTemplate template;\n\n    /**\n     * 延迟队列\n     * @param msg 消息内容\n     * @return 消息内容\n     */\n    @RequestMapping(\"/delay/{msg}\")\n    public String delayProducerOne(@PathVariable(\"msg\") String msg) {\n        log.info(\"delay:生产消息:\" + msg);\n        template.convertAndSend(\"delay_exchange\", \"dead.letter.routing.key\", msg, message -> {\n            message.getMessageProperties().setExpiration(30 * 1000 + \"\");\n            return message;\n        });\n        return msg;\n    }\n}\n```\n#### 2.5.2.4 测试\n分别启动两个项目，在浏览器的路径上输入[http://localhost:1180/delay/测试消息](http://localhost:1180/delay/测试消息)，就可在消费者项目中看到打印的信息。30秒后可以看到消费者管理后台有刚刚发送的消息被打印出来了。\n\n\n## 2.6 消息的持久化\n为了保证RabbitMQ在重启、奔溃等异常情况下数据没有丢失，除了对消息本身持久化为，还需要将消息传输经过的队列(queue)，交互机进行持久化(exchange)，持久化以上元素后，消息才算真正RabbitMQ重启不会丢失。\n创建时候的参数:\n- `durable` \n是否持久化，如果true，则此种队列叫持久化队列（Durable queues）。此队列会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。 \n- `execulusive` \n表示此对应只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable \n- `autoDelete` \n当没有生成者/消费者使用此队列时，此队列会被自动删除。 \n(即当最后一个消费者退订后即被删除)\n\n\n**设置消息持久化必须先设置队列持久化**，要不然队列不持久化，消息持久化，队列都不存在了，消息存在还有什么意义。`消息持久化需要将交换机持久化、队列持久化、消息持久化，才能最终达到持久化的目的`。其实在前面就已经使用持久化了。我们在管理后台去看一下。\n\n\n## 2.7 消息的确认与拒绝\n消费者在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题，对于此AMQP有两种处理方式：\n- `自动确认模式`:\n当RabbbitMQ将消息发送给应用后，消费者端自动回送一个确认消息，此时RabbitMQ删除此消息。\n\n- `显式确认模式`:\n消费者收到消息后，可以在执行一些逻辑后，消费者自己决定什么时候发送确认回执（acknowledgement），RabbitMQ收到回执后才删除消息，这样就保证消费端不会丢失消息\n\n如果一个消费者在尚未发送确认回执的情况下挂掉了，那么消息会被重新放入队列，并且在还有其他消费者存在于此队列的前提下，立即投递给另外一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。RabbitMQ里的消息是不会过期。当消费者挂掉后，RabbitMQ会不断尝试重推。所有单个消息的推送可能花费很长的时间。\n\n\n\n","slug":"RabbitMQ","published":1,"updated":"2019-09-05T03:35:36.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcn20001jfusgeu8a1um","content":"<p><img src=\"/image/rabbit/mq-login.jpg\" alt=\"RabbitMQ\"></p>\n<h1 id=\"1-消息中间件\"><a href=\"#1-消息中间件\" class=\"headerlink\" title=\"1.消息中间件\"></a>1.消息中间件</h1><h2 id=\"1-1-什么是消息中间\"><a href=\"#1-1-什么是消息中间\" class=\"headerlink\" title=\"1.1 什么是消息中间\"></a>1.1 什么是消息中间</h2><p><code>消息</code> (Message) 是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、<br>JSON 等，也可以很复杂，比如内嵌对象。</p>\n<p><code>消息队列中间件</code> (Message Queue Middleware，简称为 MQ) 是指利用高效可靠的消息传递 机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传 递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p>\n<p>消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:</p>\n<ul>\n<li><code>点对点</code> (P2P, Point-to-Point) 模式</li>\n<li><code>发布/订阅</code> (Pub/Sub) 模式。<a id=\"more\"></a>\n<code>点对点</code>是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的步传输成为可能。<code>发布订阅</code>定义了如何向一个内容节点发布和订阅消息，这个内容节点称为<code>主题</code>(topic)，<code>主题</code>可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而<code>消息订阅者</code>则从主题中订阅消息。<code>主题</code>使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消 息的传递，发布/订阅模式在消息的一对多广播时采用 。</li>\n</ul>\n<p>目前开源的消息中间件有很多，比较主流的有 <code>RabbitMQ</code>、 <code>Kafka</code>、 <code>ActiveMQ</code>、 <code>RocketMQ</code>等。</p>\n<h2 id=\"1-2-消息中间件的作用\"><a href=\"#1-2-消息中间件的作用\" class=\"headerlink\" title=\"1.2 消息中间件的作用\"></a>1.2 消息中间件的作用</h2><p>消息中间件凭借其独到的特性，在不同的应用场景下可以展现不同的作用。总的来说，消息中间件的作用可以概括如下:</p>\n<h3 id=\"1-2-1-解耦\"><a href=\"#1-2-1-解耦\" class=\"headerlink\" title=\"1.2.1 解耦\"></a>1.2.1 <code>解耦</code></h3><p>在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它 们遵守同样的接口约束即可。</p>\n<h3 id=\"1-2-2-冗余〈存储\"><a href=\"#1-2-2-冗余〈存储\" class=\"headerlink\" title=\"1.2.2 冗余〈存储)\"></a>1.2.2 <code>冗余〈存储)</code></h3><p>有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保 存直到你使用完毕。</p>\n<h3 id=\"1-2-3-扩展性\"><a href=\"#1-2-3-扩展性\" class=\"headerlink\" title=\"1.2.3 扩展性\"></a>1.2.3 <code>扩展性</code></h3><p>因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</p>\n<h3 id=\"1-2-4-削峰\"><a href=\"#1-2-4-削峰\" class=\"headerlink\" title=\"1.2.4 削峰\"></a>1.2.4 <code>削峰</code></h3><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。</p>\n<h3 id=\"1-2-5-可恢复性\"><a href=\"#1-2-5-可恢复性\" class=\"headerlink\" title=\"1.2.5 可恢复性\"></a>1.2.5 <code>可恢复性</code></h3><p>当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</p>\n<h3 id=\"1-2-6-顺序保证\"><a href=\"#1-2-6-顺序保证\" class=\"headerlink\" title=\"1.2.6 顺序保证\"></a>1.2.6 <code>顺序保证</code></h3><p>在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</p>\n<h3 id=\"1-2-7-缓冲\"><a href=\"#1-2-7-缓冲\" class=\"headerlink\" title=\"1.2.7 缓冲\"></a>1.2.7 <code>缓冲</code></h3><p>在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制 和优化数据流经过系统的速度。</p>\n<h3 id=\"1-2-8-异步通信\"><a href=\"#1-2-8-异步通信\" class=\"headerlink\" title=\"1.2.8 异步通信\"></a>1.2.8 <code>异步通信</code></h3><p>在很多时候应用不想也不需要立即处理消息 。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。</p>\n<h1 id=\"2-RabbitMQ入门\"><a href=\"#2-RabbitMQ入门\" class=\"headerlink\" title=\"2.RabbitMQ入门\"></a>2.RabbitMQ入门</h1><h2 id=\"2-1-RabbitMQ介绍\"><a href=\"#2-1-RabbitMQ介绍\" class=\"headerlink\" title=\"2.1 RabbitMQ介绍\"></a>2.1 RabbitMQ介绍</h2><p><code>RabbitMQ</code>是采用<code>Erlang</code>语言实现<code>AMQP</code>(Advanced Message Queuing Protocol，高级消息<br>队列协议)的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。并且支持多种客户端 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。在易用性、扩展性、高可用性等方面表现不俗。</p>\n<p>RabbitMQ主要是为了实现系统之间的<code>双向解耦</code>而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p>\n<p><code>AMQP</code>是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是 <strong>面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全</strong>。</p>\n<h2 id=\"2-2-RabbitMQ安装\"><a href=\"#2-2-RabbitMQ安装\" class=\"headerlink\" title=\"2.2 RabbitMQ安装\"></a>2.2 RabbitMQ安装</h2><ul>\n<li>使用<code>docker</code>安装(3-management版本自带管理后台)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure></li>\n<li>启动RabbitMQ并且启动管理后台<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -d -p 15672:15672  -p  5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin --name rabbitmq --hostname=rabbitmqhostone  rabbitmq:3-management</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker start rabbitmq</span><br></pre></td></tr></table></figure></li>\n<li>查看管理后台<br>在浏览器打开 <a href=\"http://localhost:15672/\" target=\"_blank\" rel=\"noopener\">http://localhost:15672/</a> 输入用户名:admin 密码:admin 可进入管理后台</li>\n</ul>\n<h2 id=\"2-3-相关概念介绍\"><a href=\"#2-3-相关概念介绍\" class=\"headerlink\" title=\"2.3 相关概念介绍\"></a>2.3 相关概念介绍</h2><h3 id=\"2-3-1-生产者和消费者\"><a href=\"#2-3-1-生产者和消费者\" class=\"headerlink\" title=\"2.3.1 生产者和消费者\"></a>2.3.1 生产者和消费者</h3><ul>\n<li><p><code>Producer</code>:生产者，就是投递消息的一方。<br>生产者创建消息，然后发布到RabbitMQ中。消息一般可以包含2个部分:<code>消息体和标签(Label)</code>。消息体也可以称之为payload，在实际应用中，<strong>消息体一般是一个带有业务逻辑结构的数据</strong>，比如一个JSON字符串。当然可以进一步对这个消息体进行序列化操作。消息的标签用来表述这条消息，比如一个交换器的名称和一个路由键。生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签把消息发送给感兴趣的消费者(Consumer)。</p>\n</li>\n<li><p><code>Consumer</code>:消费者，就是接收消息的一方。<br>消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体(payload)在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体，也就不知道消息的生产者是谁，当然消费者也不需要知道。</p>\n</li>\n<li><p><code>Broker</code>:消息中间件的服务节点。<br>对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个<code>RabbitMQ服务节点</code>，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</p>\n</li>\n</ul>\n<p><strong>RabbitMQ运转流程</strong><br><img src=\"/image/rabbit/mq-yunzhuanliucheng.jpg\" alt=\"RabbitMQ运转流程\"></p>\n<h3 id=\"2-3-2-交换器Exchange，路由RoutingKey，绑定Binding\"><a href=\"#2-3-2-交换器Exchange，路由RoutingKey，绑定Binding\" class=\"headerlink\" title=\"2.3.2 交换器Exchange，路由RoutingKey，绑定Binding\"></a>2.3.2 交换器Exchange，路由RoutingKey，绑定Binding</h3><ul>\n<li><p><code>Exchange</code>:交换器<br><img src=\"/image/rabbit/mq-exchange.jpg\" alt=\"交换器\"><br>MQ中我们暂时可以理解成 <strong>生产者将消息投递到队列中</strong>，但是实际上这个在RabbitMQ中不会发生。真实情况是，<strong>生产者将消息发送到<code>Exchange(交换器)</code>，由交换器将消息路由到一个或者多个<code>队列</code>中。如果路由不到，或许会返回给生产者，或许直接丢弃</strong>。<br>RabbitMQ中的交换器有四种类型，下面将会一一介绍，并且会附上代码详细说明。</p>\n</li>\n<li><p><code>RoutingKey</code>:路由键<br>生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键(BindingKey)固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p>\n</li>\n<li><p><code>Binding</code>:绑定<br>RabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键(BindingKey)，这样RabbitMQ就知道如何正确地将消息路由到队列了，如下图所示:<br><img src=\"/image/rabbit/mq-banding.jpg\" alt=\"绑定\"></p>\n</li>\n</ul>\n<h3 id=\"2-3-3-交换器类型\"><a href=\"#2-3-3-交换器类型\" class=\"headerlink\" title=\"2.3.3 交换器类型\"></a>2.3.3 交换器类型</h3><p>RabbitMQ常用的交换器类型有<code>fanout</code>、<code>direct</code>、<code>topic</code>和<code>headers</code>这四种。AMQP协议里其实还提<br>到另外两种类型:<code>System</code>和<code>自定义</code>，在这里就不作详细介绍了。</p>\n<h4 id=\"2-3-3-1-fanout\"><a href=\"#2-3-3-1-fanout\" class=\"headerlink\" title=\"2.3.3.1 fanout\"></a>2.3.3.1 <code>fanout</code></h4><p>就是我们熟悉的广播模式或者订阅模式，它会把所有发送到该ExChange的消息全部路由到所有与该交换器绑定的队列中。如下图：<br><img src=\"/image/rabbit/mq-fanout.jpg\" alt=\"fanout\"></p>\n<h4 id=\"2-3-3-2-direct-RabbitMQ默认的交换器类型\"><a href=\"#2-3-3-2-direct-RabbitMQ默认的交换器类型\" class=\"headerlink\" title=\"2.3.3.2 direct(RabbitMQ默认的交换器类型)\"></a>2.3.3.2 <code>direct</code>(RabbitMQ默认的交换器类型)</h4><p>direct类型的交换器路由规则也很简单，它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。如下图：<br><img src=\"/image/rabbit/mq-direct.jpg\" alt=\"direct\"></p>\n<h4 id=\"2-3-3-3-topic\"><a href=\"#2-3-3-3-topic\" class=\"headerlink\" title=\"2.3.3.3 topic\"></a>2.3.3.3 topic</h4><p>上面讲到<code>direct类型</code>的交换器路由规则是完全匹配BindingKey和RoutingKey，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。<code>topic类型</code>的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定:</p>\n<ul>\n<li>RoutingKey为一个点号<code>.</code>分隔的字符串(被点号<code>.</code>分隔开的每一段独立的字符串称为一个单词)，如”com.rabbitmq.client”，”java.util.concurrent”,”com.hidden.client”等</li>\n<li>BindingKey也是点号<code>.</code>分隔</li>\n<li>BindingKey中可以存在两种特殊字符串<code>*</code>和<code>#</code>，用于做模糊匹配，其中<code>*</code>用于匹配一个单词，<code>#</code>用于匹配多规格单词(可以是零个)。<br>如下图：<br><img src=\"/image/rabbit/mq-topic.jpg\" alt=\"topic\"><br>思考: </li>\n</ul>\n<p>1.路由建 “com.rabbitmq.client”会路由到哪一个队列？<br>2.路由建 “com.hidden.client”会路由到哪一个队列？<br>3.路由建 “com.hidden.demo”会路由到哪一个队列？<br>4.路由建 “java.util.concurrent”会路由到哪一个队列？<br>5.路由建 “java.rabbitmq.demo”会路由到哪一个队列？</p>\n<h4 id=\"2-3-3-4-headers-不常用\"><a href=\"#2-3-3-4-headers-不常用\" class=\"headerlink\" title=\"2.3.3.4 headers(不常用)\"></a>2.3.3.4 headers(不常用)</h4><p><code>headers类型</code>的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers(也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。<strong>headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在</strong> 所以对于headers类型交换器我们只需要了解即可，知道有这么个类型存在。</p>\n<h2 id=\"2-4-交换器类型详解\"><a href=\"#2-4-交换器类型详解\" class=\"headerlink\" title=\"2.4 交换器类型详解\"></a>2.4 交换器类型详解</h2><h3 id=\"2-4-1-新建\"><a href=\"#2-4-1-新建\" class=\"headerlink\" title=\"2.4.1 新建\"></a>2.4.1 新建</h3><p>新建rabbit-demo工程，在其中新建两个mudle 一个为rabbit-consumer 另一个为rabbit-producer<br>pom.xml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>rabbit-producer/application.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=1180</span><br><span class=\"line\"># 端口 1181 消费者  1180 生产者</span><br><span class=\"line\"></span><br><span class=\"line\">spring.rabbitmq.host=127.0.0.1</span><br><span class=\"line\">spring.rabbitmq.username=admin</span><br><span class=\"line\">spring.rabbitmq.password=admin</span><br><span class=\"line\">spring.rabbitmq.port=5672</span><br></pre></td></tr></table></figure>\n<p>rabbit-producer/application.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=1181</span><br><span class=\"line\"># 端口 1181 消费者  1180 生产者</span><br><span class=\"line\"></span><br><span class=\"line\">spring.rabbitmq.host=127.0.0.1</span><br><span class=\"line\">spring.rabbitmq.username=admin</span><br><span class=\"line\">spring.rabbitmq.password=admin</span><br><span class=\"line\">spring.rabbitmq.port=5672</span><br></pre></td></tr></table></figure>\n<p>项目创建完成</p>\n<h3 id=\"2-4-2-声明一个队列各个参数的意义\"><a href=\"#2-4-2-声明一个队列各个参数的意义\" class=\"headerlink\" title=\"2.4.2 声明一个队列各个参数的意义\"></a>2.4.2 声明一个队列各个参数的意义</h3><ul>\n<li><code>name</code>: 队列的名称 字符串;</li>\n<li><code>durable</code>: 是否持久化, 队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库;</li>\n<li><code>exclusive</code>: 是否排外的，有两个作用，一：当连接关闭时connection.close()该队列是否会自动删除；二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常，一般等于true的话用于一个队列只能有一个消费者来消费的场景。</li>\n<li><code>autoDelete</code>: 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除</li>\n<li><code>arguments</code>: 队列中的消息什么时候会自动被删除？ 是一个Map&lt;String, Object&gt;，它有如下参数:<ul>\n<li>“x-message-ttl”: 1000  设置队列中的所有消息的生存周期</li>\n<li>“x-expires”: 1000  当队列在指定的时间没有被访问就会被删除</li>\n<li>“x-max-length”: 10  限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉</li>\n<li>“x-max-length-bytes”:  限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小</li>\n<li>“x-dead-letter-exchange”: “” 当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉</li>\n<li>“x-dead-letter-routing-key”: “”  将删除的消息推送到指定交换机的指定路由键的队列中去</li>\n<li>“x-max-priority”:  优先级队列，声明队列时先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费</li>\n<li>“x-queue-mode”: “lazy” 先将消息保存到磁盘上，不放在内存中，当消费者开始消费的时候才加载到内存中</li>\n<li>“x-queue-master-locator”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-4-3-fanout代码实现\"><a href=\"#2-4-3-fanout代码实现\" class=\"headerlink\" title=\"2.4.3 fanout代码实现\"></a>2.4.3 fanout代码实现</h3><h4 id=\"2-4-3-1-在消费者项目中添加一个配置类\"><a href=\"#2-4-3-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.4.3.1 在消费者项目中添加一个配置类\"></a>2.4.3.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.fanout;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/1 4:35 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明一个队列，后面有很多属性</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueue1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"fanout.queue1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueue2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"fanout.queue2\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">\"fanout_exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBinding1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBinding2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-3-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-4-3-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.4.3.2 在消费者项目中添加一个消息监听类\"></a>2.4.3.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.fanout;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/1 4:40 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"fanout.queue1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer1</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"1fanoutConsumer 接收消息msg: &#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"fanout.queue2\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer2</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"2fanoutConsumer 接收消息msg: &#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-3-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-4-3-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.4.3.3 在生产者项目中添加一个消息发送controller\"></a>2.4.3.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/28 11:50 AM</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * fanout类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * 虽然fanout类型下不需要routingKey 但是在调用convertAndSend方法时还是需要配置routingKey</span></span><br><span class=\"line\"><span class=\"comment\">     * 只是routingKey可以任意指定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/fanout/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">fanoutProducer</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg)</span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"fanout生产消息 msg:&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数是交换器名称 第二个参数是routingKey名称，fanout模式写任何key都会被无视 第三个是要发送的消息</span></span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"fanout_exchange\"</span>,<span class=\"string\">\"\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-3-4-测试\"><a href=\"#2-4-3-4-测试\" class=\"headerlink\" title=\"2.4.3.4 测试\"></a>2.4.3.4 测试</h4><p>分别启动这两个项目，在浏览器的路径上输入<a href=\"http://localhost:1180/fanout/测试消息\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/fanout/测试消息</a>，就可在消费者项目控制台中看到绑定这个fanout模式交换器的队列接收到的消息在控制台打印出来了。</p>\n<h3 id=\"2-4-4-direct代码实现\"><a href=\"#2-4-4-direct代码实现\" class=\"headerlink\" title=\"2.4.4 direct代码实现\"></a>2.4.4 direct代码实现</h3><h4 id=\"2-4-4-1-在消费者项目中添加一个配置类\"><a href=\"#2-4-4-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.4.4.1 在消费者项目中添加一个配置类\"></a>2.4.4.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.direct;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/29 1:40 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DirectConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义两个队列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"direct.queue1\"</span>,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"direct.queue2\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"direct.queue3\"</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>, map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义 exchange</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"direct_exchange\"</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列1 绑定 exchange 并且设置routingKey为direct.1</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue1()).to(directExchange()).with(<span class=\"string\">\"direct.routing.key1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列2 绑定 exchange 并且设置routingKey为direct.2</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue2()).to(directExchange()).with(<span class=\"string\">\"direct.routing.key2\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue3()).to(directExchange()).with(<span class=\"string\">\"direct.routing.key1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-4-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-4-4-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.4.4.2 在消费者项目中添加一个消息监听类\"></a>2.4.4.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">和fanout相同，只是监听的队列不同而已</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-4-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-4-4-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.4.4.3 在生产者项目中添加一个消息发送controller\"></a>2.4.4.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/28 11:50 AM</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DirectProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * direct类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/direct/queue1/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">directProducerOne</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"生产者生产消息:\"</span> + msg);</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息</span></span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"direct_exchange\"</span>, <span class=\"string\">\"direct.routing.key1\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/direct/queue2/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">directProducerTwo</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"生产者生产消息:\"</span> + msg);</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息</span></span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"mq-direct_exchange\"</span>, <span class=\"string\">\"direct.routing.key2\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-4-4-测试\"><a href=\"#2-4-4-4-测试\" class=\"headerlink\" title=\"2.4.4.4 测试\"></a>2.4.4.4 测试</h4><p>分别启动两个项目，在浏览器的路径上输入 <a href=\"http://localhost:1180/direct/queue1/测试消息1\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/direct/queue1/测试消息1</a> ，就可在消费者项目中看到打印的信息。<br>如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey设置为一样即可</p>\n<h3 id=\"2-4-5-topic代码实现\"><a href=\"#2-4-5-topic代码实现\" class=\"headerlink\" title=\"2.4.5 topic代码实现\"></a>2.4.5 topic代码实现</h3><h4 id=\"2-4-5-1-在消费者项目中添加一个配置类\"><a href=\"#2-4-5-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.4.5.1 在消费者项目中添加一个配置类\"></a>2.4.5.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.topic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/29 8:42 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建队列</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueue1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"topic.queue1\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueue2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"topic.queue2\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建交换器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"topic_exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 绑定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBinding1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(<span class=\"string\">\"*.jiafly.*\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBinding2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(<span class=\"string\">\"com.jiafly.*\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-5-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-4-5-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.4.5.2 在消费者项目中添加一个消息监听类\"></a>2.4.5.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 和fanout类型相同，只是监听的队列不同而已</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-5-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-4-5-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.4.5.3 在生产者项目中添加一个消息发送controller\"></a>2.4.5.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/28 11:50 AM</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * topic类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/topic/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">topicProducerOne</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"topic:生产消息:\"</span> + msg);</span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"topic_exchange\"</span>, <span class=\"string\">\"com.jiafly.test\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-5-4-测试\"><a href=\"#2-4-5-4-测试\" class=\"headerlink\" title=\"2.4.5.4 测试\"></a>2.4.5.4 测试</h4><p>分别启动两个项目，在浏览器的路径上输入<a href=\"http://localhost:1180/topic/测试消息\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/topic/测试消息</a> ，就可在消费者项目中看到打印的信息。<br>如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey使用<code>*</code>或者<code>#</code>表示</p>\n<h2 id=\"2-5-延时队列\"><a href=\"#2-5-延时队列\" class=\"headerlink\" title=\"2.5 延时队列\"></a>2.5 延时队列</h2><h3 id=\"2-5-1-延时队列能做什么\"><a href=\"#2-5-1-延时队列能做什么\" class=\"headerlink\" title=\"2.5.1 延时队列能做什么\"></a>2.5.1 延时队列能做什么</h3><ul>\n<li>订单业务：在电商/点餐中，都有下单后 30 分钟内没有付款，就自动取消订单。</li>\n<li>短信通知：下单成功后 60s 之后给用户发送短信通知。</li>\n<li>失败重试：业务操作失败后，间隔一定的时间进行失败重试</li>\n</ul>\n<p>这类业务的特点就是：非实时的，需要延迟处理，需要进行失败重试。一种比较笨的方式是采用定时任务，轮训数据库，方法简单好用，但性能底下，在高并发情况下容易弄死数据库，间隔时间不好设置，时间过大，影响精度，过小影响性能，而且做不到按超时的时间顺序处理。另一种就是用Java中的DelayQueue 位于java.util.concurrent包下，本质是由PriorityQueue和BlockingQueue实现的阻塞优先级队列。，这玩意最大的问题就是不支持分布式与持久化。</p>\n<p>在 AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面 所介绍的 DLX 和 TTL 模拟出延迟队列的功能。所以在介绍延时队列之前，首先介绍下DLX(Dead-Letter-Exchange)和TTL(Time to Live)。<br><img src=\"/image/rabbit/delay-mq.jpg\" alt=\"延时队列\"></p>\n<h3 id=\"2-5-2-死信交换器DLX-Dead-Letter-Exchange\"><a href=\"#2-5-2-死信交换器DLX-Dead-Letter-Exchange\" class=\"headerlink\" title=\"2.5.2 死信交换器DLX(Dead-Letter-Exchange)\"></a>2.5.2 死信交换器DLX(Dead-Letter-Exchange)</h3><p>DLX：死信队列，用来存储有超时时间信息的消息， 并且可以设置当消息超时时，转发到另一个指定队列(此处设置转发到router), 无消费者，当接收到客户端消息之后，等待消息超时，将消息转发到指定的Router队列。</p>\n<p>Router: 转发队列，用来接收死信队列超时消息， 如上示例消息，在接收到之后，消费者将消息解析，获取queueName，body,再向所获取的queueName队列发送一条消息，内容为body.</p>\n<p>具体代码实现:</p>\n<h4 id=\"2-5-2-1-在消费者项目中添加一个配置类\"><a href=\"#2-5-2-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.5.2.1 在消费者项目中添加一个配置类\"></a>2.5.2.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.delay;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/2 12:44 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个交换机</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">delayExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"delay_exchange\"</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 转发队列</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">routerQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"router.queue\"</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 转发队列绑定交换机</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">routerBinding</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(routerQueue()).to(delayExchange()).with(<span class=\"string\">\"router.routing.key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 死信队列</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">deadLetterQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap(<span class=\"number\">16</span>);</span><br><span class=\"line\">        arguments.put(<span class=\"string\">\"x-dead-letter-exchange\"</span>, <span class=\"string\">\"delay_exchange\"</span>);</span><br><span class=\"line\">        arguments.put(<span class=\"string\">\"x-dead-letter-routing-key\"</span>, <span class=\"string\">\"router.routing.key\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"dead.letter.queue\"</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 死信队列绑定交换机</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">deadLetterBinding</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(deadLetterQueue()).to(delayExchange()).with(<span class=\"string\">\"dead.letter.routing.key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-2-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-5-2-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.5.2.2 在消费者项目中添加一个消息监听类\"></a>2.5.2.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.delay;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/3 6:13 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"router.queue\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delayConsumer</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delay.queue1接收消息:&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-2-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-5-2-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.5.2.3 在生产者项目中添加一个消息发送controller\"></a>2.5.2.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.support.converter.AbstractJavaTypeMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/3 7:17 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 延迟队列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/delay/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">delayProducerOne</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delay:生产消息:\"</span> + msg);</span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"delay_exchange\"</span>, <span class=\"string\">\"dead.letter.routing.key\"</span>, msg, message -&gt; &#123;</span><br><span class=\"line\">            message.getMessageProperties().setExpiration(<span class=\"number\">30</span> * <span class=\"number\">1000</span> + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-2-4-测试\"><a href=\"#2-5-2-4-测试\" class=\"headerlink\" title=\"2.5.2.4 测试\"></a>2.5.2.4 测试</h4><p>分别启动两个项目，在浏览器的路径上输入<a href=\"http://localhost:1180/delay/测试消息\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/delay/测试消息</a>，就可在消费者项目中看到打印的信息。30秒后可以看到消费者管理后台有刚刚发送的消息被打印出来了。</p>\n<h2 id=\"2-6-消息的持久化\"><a href=\"#2-6-消息的持久化\" class=\"headerlink\" title=\"2.6 消息的持久化\"></a>2.6 消息的持久化</h2><p>为了保证RabbitMQ在重启、奔溃等异常情况下数据没有丢失，除了对消息本身持久化为，还需要将消息传输经过的队列(queue)，交互机进行持久化(exchange)，持久化以上元素后，消息才算真正RabbitMQ重启不会丢失。<br>创建时候的参数:</p>\n<ul>\n<li><code>durable</code><br>是否持久化，如果true，则此种队列叫持久化队列（Durable queues）。此队列会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。 </li>\n<li><code>execulusive</code><br>表示此对应只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable </li>\n<li><code>autoDelete</code><br>当没有生成者/消费者使用此队列时，此队列会被自动删除。<br>(即当最后一个消费者退订后即被删除)</li>\n</ul>\n<p><strong>设置消息持久化必须先设置队列持久化</strong>，要不然队列不持久化，消息持久化，队列都不存在了，消息存在还有什么意义。<code>消息持久化需要将交换机持久化、队列持久化、消息持久化，才能最终达到持久化的目的</code>。其实在前面就已经使用持久化了。我们在管理后台去看一下。</p>\n<h2 id=\"2-7-消息的确认与拒绝\"><a href=\"#2-7-消息的确认与拒绝\" class=\"headerlink\" title=\"2.7 消息的确认与拒绝\"></a>2.7 消息的确认与拒绝</h2><p>消费者在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题，对于此AMQP有两种处理方式：</p>\n<ul>\n<li><p><code>自动确认模式</code>:<br>当RabbbitMQ将消息发送给应用后，消费者端自动回送一个确认消息，此时RabbitMQ删除此消息。</p>\n</li>\n<li><p><code>显式确认模式</code>:<br>消费者收到消息后，可以在执行一些逻辑后，消费者自己决定什么时候发送确认回执（acknowledgement），RabbitMQ收到回执后才删除消息，这样就保证消费端不会丢失消息</p>\n</li>\n</ul>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那么消息会被重新放入队列，并且在还有其他消费者存在于此队列的前提下，立即投递给另外一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。RabbitMQ里的消息是不会过期。当消费者挂掉后，RabbitMQ会不断尝试重推。所有单个消息的推送可能花费很长的时间。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/image/rabbit/mq-login.jpg\" alt=\"RabbitMQ\"></p>\n<h1 id=\"1-消息中间件\"><a href=\"#1-消息中间件\" class=\"headerlink\" title=\"1.消息中间件\"></a>1.消息中间件</h1><h2 id=\"1-1-什么是消息中间\"><a href=\"#1-1-什么是消息中间\" class=\"headerlink\" title=\"1.1 什么是消息中间\"></a>1.1 什么是消息中间</h2><p><code>消息</code> (Message) 是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串、<br>JSON 等，也可以很复杂，比如内嵌对象。</p>\n<p><code>消息队列中间件</code> (Message Queue Middleware，简称为 MQ) 是指利用高效可靠的消息传递 机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传 递和消息排队模型，它可以在分布式环境下扩展进程间的通信。</p>\n<p>消息队列中间件，也可以称为消息队列或者消息中间件。它一般有两种传递模式:</p>\n<ul>\n<li><code>点对点</code> (P2P, Point-to-Point) 模式</li>\n<li><code>发布/订阅</code> (Pub/Sub) 模式。","more":"<code>点对点</code>是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的步传输成为可能。<code>发布订阅</code>定义了如何向一个内容节点发布和订阅消息，这个内容节点称为<code>主题</code>(topic)，<code>主题</code>可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而<code>消息订阅者</code>则从主题中订阅消息。<code>主题</code>使得消息的订阅者与消息的发布者互相保持独立，不需要进行接触即可保证消 息的传递，发布/订阅模式在消息的一对多广播时采用 。</li>\n</ul>\n<p>目前开源的消息中间件有很多，比较主流的有 <code>RabbitMQ</code>、 <code>Kafka</code>、 <code>ActiveMQ</code>、 <code>RocketMQ</code>等。</p>\n<h2 id=\"1-2-消息中间件的作用\"><a href=\"#1-2-消息中间件的作用\" class=\"headerlink\" title=\"1.2 消息中间件的作用\"></a>1.2 消息中间件的作用</h2><p>消息中间件凭借其独到的特性，在不同的应用场景下可以展现不同的作用。总的来说，消息中间件的作用可以概括如下:</p>\n<h3 id=\"1-2-1-解耦\"><a href=\"#1-2-1-解耦\" class=\"headerlink\" title=\"1.2.1 解耦\"></a>1.2.1 <code>解耦</code></h3><p>在项目启动之初来预测将来会碰到什么需求是极其困难的。消息中间件在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，这允许你独立地扩展或修改两边的处理过程，只要确保它 们遵守同样的接口约束即可。</p>\n<h3 id=\"1-2-2-冗余〈存储\"><a href=\"#1-2-2-冗余〈存储\" class=\"headerlink\" title=\"1.2.2 冗余〈存储)\"></a>1.2.2 <code>冗余〈存储)</code></h3><p>有些情况下，处理数据的过程会失败。消息中间件可以把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。在把一个消息从消息中间件中删除之前，需要你的处理系统明确地指出该消息己经被处理完成，从而确保你的数据被安全地保 存直到你使用完毕。</p>\n<h3 id=\"1-2-3-扩展性\"><a href=\"#1-2-3-扩展性\" class=\"headerlink\" title=\"1.2.3 扩展性\"></a>1.2.3 <code>扩展性</code></h3><p>因为消息中间件解捐了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要另外增加处理过程即可，不需要改变代码，也不需要调节参数。</p>\n<h3 id=\"1-2-4-削峰\"><a href=\"#1-2-4-削峰\" class=\"headerlink\" title=\"1.2.4 削峰\"></a>1.2.4 <code>削峰</code></h3><p>在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，不会因为突发的超负荷请求而完全崩惯。</p>\n<h3 id=\"1-2-5-可恢复性\"><a href=\"#1-2-5-可恢复性\" class=\"headerlink\" title=\"1.2.5 可恢复性\"></a>1.2.5 <code>可恢复性</code></h3><p>当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的稿合度，所以即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。</p>\n<h3 id=\"1-2-6-顺序保证\"><a href=\"#1-2-6-顺序保证\" class=\"headerlink\" title=\"1.2.6 顺序保证\"></a>1.2.6 <code>顺序保证</code></h3><p>在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定程度上的顺序性。</p>\n<h3 id=\"1-2-7-缓冲\"><a href=\"#1-2-7-缓冲\" class=\"headerlink\" title=\"1.2.7 缓冲\"></a>1.2.7 <code>缓冲</code></h3><p>在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务最高效率地执行，写入消息中间件的处理会尽可能快速。该缓冲层有助于控制 和优化数据流经过系统的速度。</p>\n<h3 id=\"1-2-8-异步通信\"><a href=\"#1-2-8-异步通信\" class=\"headerlink\" title=\"1.2.8 异步通信\"></a>1.2.8 <code>异步通信</code></h3><p>在很多时候应用不想也不需要立即处理消息 。消息中间件提供了异步处理机制，允许应用把一些消息放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。</p>\n<h1 id=\"2-RabbitMQ入门\"><a href=\"#2-RabbitMQ入门\" class=\"headerlink\" title=\"2.RabbitMQ入门\"></a>2.RabbitMQ入门</h1><h2 id=\"2-1-RabbitMQ介绍\"><a href=\"#2-1-RabbitMQ介绍\" class=\"headerlink\" title=\"2.1 RabbitMQ介绍\"></a>2.1 RabbitMQ介绍</h2><p><code>RabbitMQ</code>是采用<code>Erlang</code>语言实现<code>AMQP</code>(Advanced Message Queuing Protocol，高级消息<br>队列协议)的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。并且支持多种客户端 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。在易用性、扩展性、高可用性等方面表现不俗。</p>\n<p>RabbitMQ主要是为了实现系统之间的<code>双向解耦</code>而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p>\n<p><code>AMQP</code>是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是 <strong>面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全</strong>。</p>\n<h2 id=\"2-2-RabbitMQ安装\"><a href=\"#2-2-RabbitMQ安装\" class=\"headerlink\" title=\"2.2 RabbitMQ安装\"></a>2.2 RabbitMQ安装</h2><ul>\n<li>使用<code>docker</code>安装(3-management版本自带管理后台)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure></li>\n<li>启动RabbitMQ并且启动管理后台<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run -d -p 15672:15672  -p  5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin --name rabbitmq --hostname=rabbitmqhostone  rabbitmq:3-management</span><br><span class=\"line\"></span><br><span class=\"line\">$ docker start rabbitmq</span><br></pre></td></tr></table></figure></li>\n<li>查看管理后台<br>在浏览器打开 <a href=\"http://localhost:15672/\" target=\"_blank\" rel=\"noopener\">http://localhost:15672/</a> 输入用户名:admin 密码:admin 可进入管理后台</li>\n</ul>\n<h2 id=\"2-3-相关概念介绍\"><a href=\"#2-3-相关概念介绍\" class=\"headerlink\" title=\"2.3 相关概念介绍\"></a>2.3 相关概念介绍</h2><h3 id=\"2-3-1-生产者和消费者\"><a href=\"#2-3-1-生产者和消费者\" class=\"headerlink\" title=\"2.3.1 生产者和消费者\"></a>2.3.1 生产者和消费者</h3><ul>\n<li><p><code>Producer</code>:生产者，就是投递消息的一方。<br>生产者创建消息，然后发布到RabbitMQ中。消息一般可以包含2个部分:<code>消息体和标签(Label)</code>。消息体也可以称之为payload，在实际应用中，<strong>消息体一般是一个带有业务逻辑结构的数据</strong>，比如一个JSON字符串。当然可以进一步对这个消息体进行序列化操作。消息的标签用来表述这条消息，比如一个交换器的名称和一个路由键。生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签把消息发送给感兴趣的消费者(Consumer)。</p>\n</li>\n<li><p><code>Consumer</code>:消费者，就是接收消息的一方。<br>消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体(payload)在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体，也就不知道消息的生产者是谁，当然消费者也不需要知道。</p>\n</li>\n<li><p><code>Broker</code>:消息中间件的服务节点。<br>对于RabbitMQ来说，一个RabbitMQ Broker可以简单地看作一个<code>RabbitMQ服务节点</code>，或者RabbitMQ服务实例。大多数情况下也可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</p>\n</li>\n</ul>\n<p><strong>RabbitMQ运转流程</strong><br><img src=\"/image/rabbit/mq-yunzhuanliucheng.jpg\" alt=\"RabbitMQ运转流程\"></p>\n<h3 id=\"2-3-2-交换器Exchange，路由RoutingKey，绑定Binding\"><a href=\"#2-3-2-交换器Exchange，路由RoutingKey，绑定Binding\" class=\"headerlink\" title=\"2.3.2 交换器Exchange，路由RoutingKey，绑定Binding\"></a>2.3.2 交换器Exchange，路由RoutingKey，绑定Binding</h3><ul>\n<li><p><code>Exchange</code>:交换器<br><img src=\"/image/rabbit/mq-exchange.jpg\" alt=\"交换器\"><br>MQ中我们暂时可以理解成 <strong>生产者将消息投递到队列中</strong>，但是实际上这个在RabbitMQ中不会发生。真实情况是，<strong>生产者将消息发送到<code>Exchange(交换器)</code>，由交换器将消息路由到一个或者多个<code>队列</code>中。如果路由不到，或许会返回给生产者，或许直接丢弃</strong>。<br>RabbitMQ中的交换器有四种类型，下面将会一一介绍，并且会附上代码详细说明。</p>\n</li>\n<li><p><code>RoutingKey</code>:路由键<br>生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键(BindingKey)固定的情况下，生产者可以在发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p>\n</li>\n<li><p><code>Binding</code>:绑定<br>RabbitMQ中通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键(BindingKey)，这样RabbitMQ就知道如何正确地将消息路由到队列了，如下图所示:<br><img src=\"/image/rabbit/mq-banding.jpg\" alt=\"绑定\"></p>\n</li>\n</ul>\n<h3 id=\"2-3-3-交换器类型\"><a href=\"#2-3-3-交换器类型\" class=\"headerlink\" title=\"2.3.3 交换器类型\"></a>2.3.3 交换器类型</h3><p>RabbitMQ常用的交换器类型有<code>fanout</code>、<code>direct</code>、<code>topic</code>和<code>headers</code>这四种。AMQP协议里其实还提<br>到另外两种类型:<code>System</code>和<code>自定义</code>，在这里就不作详细介绍了。</p>\n<h4 id=\"2-3-3-1-fanout\"><a href=\"#2-3-3-1-fanout\" class=\"headerlink\" title=\"2.3.3.1 fanout\"></a>2.3.3.1 <code>fanout</code></h4><p>就是我们熟悉的广播模式或者订阅模式，它会把所有发送到该ExChange的消息全部路由到所有与该交换器绑定的队列中。如下图：<br><img src=\"/image/rabbit/mq-fanout.jpg\" alt=\"fanout\"></p>\n<h4 id=\"2-3-3-2-direct-RabbitMQ默认的交换器类型\"><a href=\"#2-3-3-2-direct-RabbitMQ默认的交换器类型\" class=\"headerlink\" title=\"2.3.3.2 direct(RabbitMQ默认的交换器类型)\"></a>2.3.3.2 <code>direct</code>(RabbitMQ默认的交换器类型)</h4><p>direct类型的交换器路由规则也很简单，它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。如下图：<br><img src=\"/image/rabbit/mq-direct.jpg\" alt=\"direct\"></p>\n<h4 id=\"2-3-3-3-topic\"><a href=\"#2-3-3-3-topic\" class=\"headerlink\" title=\"2.3.3.3 topic\"></a>2.3.3.3 topic</h4><p>上面讲到<code>direct类型</code>的交换器路由规则是完全匹配BindingKey和RoutingKey，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。<code>topic类型</code>的交换器在匹配规则上进行了扩展，它与direct类型的交换器相似，也是将消息路由到BindingKey和RoutingKey相匹配的队列中，但这里的匹配规则有些不同，它约定:</p>\n<ul>\n<li>RoutingKey为一个点号<code>.</code>分隔的字符串(被点号<code>.</code>分隔开的每一段独立的字符串称为一个单词)，如”com.rabbitmq.client”，”java.util.concurrent”,”com.hidden.client”等</li>\n<li>BindingKey也是点号<code>.</code>分隔</li>\n<li>BindingKey中可以存在两种特殊字符串<code>*</code>和<code>#</code>，用于做模糊匹配，其中<code>*</code>用于匹配一个单词，<code>#</code>用于匹配多规格单词(可以是零个)。<br>如下图：<br><img src=\"/image/rabbit/mq-topic.jpg\" alt=\"topic\"><br>思考: </li>\n</ul>\n<p>1.路由建 “com.rabbitmq.client”会路由到哪一个队列？<br>2.路由建 “com.hidden.client”会路由到哪一个队列？<br>3.路由建 “com.hidden.demo”会路由到哪一个队列？<br>4.路由建 “java.util.concurrent”会路由到哪一个队列？<br>5.路由建 “java.rabbitmq.demo”会路由到哪一个队列？</p>\n<h4 id=\"2-3-3-4-headers-不常用\"><a href=\"#2-3-3-4-headers-不常用\" class=\"headerlink\" title=\"2.3.3.4 headers(不常用)\"></a>2.3.3.4 headers(不常用)</h4><p><code>headers类型</code>的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers(也是一个键值对的形式)，对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。<strong>headers类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在</strong> 所以对于headers类型交换器我们只需要了解即可，知道有这么个类型存在。</p>\n<h2 id=\"2-4-交换器类型详解\"><a href=\"#2-4-交换器类型详解\" class=\"headerlink\" title=\"2.4 交换器类型详解\"></a>2.4 交换器类型详解</h2><h3 id=\"2-4-1-新建\"><a href=\"#2-4-1-新建\" class=\"headerlink\" title=\"2.4.1 新建\"></a>2.4.1 新建</h3><p>新建rabbit-demo工程，在其中新建两个mudle 一个为rabbit-consumer 另一个为rabbit-producer<br>pom.xml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class=\"line\">  &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class=\"line\">  &lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>rabbit-producer/application.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=1180</span><br><span class=\"line\"># 端口 1181 消费者  1180 生产者</span><br><span class=\"line\"></span><br><span class=\"line\">spring.rabbitmq.host=127.0.0.1</span><br><span class=\"line\">spring.rabbitmq.username=admin</span><br><span class=\"line\">spring.rabbitmq.password=admin</span><br><span class=\"line\">spring.rabbitmq.port=5672</span><br></pre></td></tr></table></figure>\n<p>rabbit-producer/application.properties</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server.port=1181</span><br><span class=\"line\"># 端口 1181 消费者  1180 生产者</span><br><span class=\"line\"></span><br><span class=\"line\">spring.rabbitmq.host=127.0.0.1</span><br><span class=\"line\">spring.rabbitmq.username=admin</span><br><span class=\"line\">spring.rabbitmq.password=admin</span><br><span class=\"line\">spring.rabbitmq.port=5672</span><br></pre></td></tr></table></figure>\n<p>项目创建完成</p>\n<h3 id=\"2-4-2-声明一个队列各个参数的意义\"><a href=\"#2-4-2-声明一个队列各个参数的意义\" class=\"headerlink\" title=\"2.4.2 声明一个队列各个参数的意义\"></a>2.4.2 声明一个队列各个参数的意义</h3><ul>\n<li><code>name</code>: 队列的名称 字符串;</li>\n<li><code>durable</code>: 是否持久化, 队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库;</li>\n<li><code>exclusive</code>: 是否排外的，有两个作用，一：当连接关闭时connection.close()该队列是否会自动删除；二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常，一般等于true的话用于一个队列只能有一个消费者来消费的场景。</li>\n<li><code>autoDelete</code>: 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，查看某个队列的消费者数量，当consumers = 0时队列就会自动删除</li>\n<li><code>arguments</code>: 队列中的消息什么时候会自动被删除？ 是一个Map&lt;String, Object&gt;，它有如下参数:<ul>\n<li>“x-message-ttl”: 1000  设置队列中的所有消息的生存周期</li>\n<li>“x-expires”: 1000  当队列在指定的时间没有被访问就会被删除</li>\n<li>“x-max-length”: 10  限定队列的消息的最大值长度，超过指定长度将会把最早的几条删除掉</li>\n<li>“x-max-length-bytes”:  限定队列最大占用的空间大小， 一般受限于内存、磁盘的大小</li>\n<li>“x-dead-letter-exchange”: “” 当队列消息长度大于最大长度、或者过期的等，将从队列中删除的消息推送到指定的交换机中去而不是丢弃掉</li>\n<li>“x-dead-letter-routing-key”: “”  将删除的消息推送到指定交换机的指定路由键的队列中去</li>\n<li>“x-max-priority”:  优先级队列，声明队列时先定义最大优先级值(定义最大值一般不要太大)，在发布消息的时候指定该消息的优先级， 优先级更高（数值更大的）的消息先被消费</li>\n<li>“x-queue-mode”: “lazy” 先将消息保存到磁盘上，不放在内存中，当消费者开始消费的时候才加载到内存中</li>\n<li>“x-queue-master-locator”</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-4-3-fanout代码实现\"><a href=\"#2-4-3-fanout代码实现\" class=\"headerlink\" title=\"2.4.3 fanout代码实现\"></a>2.4.3 fanout代码实现</h3><h4 id=\"2-4-3-1-在消费者项目中添加一个配置类\"><a href=\"#2-4-3-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.4.3.1 在消费者项目中添加一个配置类\"></a>2.4.3.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.fanout;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/1 4:35 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明一个队列，后面有很多属性</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueue1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"fanout.queue1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">fanoutQueue2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"fanout.queue2\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FanoutExchange <span class=\"title\">fanoutExchange</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FanoutExchange(<span class=\"string\">\"fanout_exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBinding1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">fanoutBinding2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(fanoutQueue2()).to(fanoutExchange());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-3-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-4-3-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.4.3.2 在消费者项目中添加一个消息监听类\"></a>2.4.3.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.fanout;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/1 4:40 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"fanout.queue1\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer1</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"1fanoutConsumer 接收消息msg: &#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"fanout.queue2\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fanoutConsumer2</span><span class=\"params\">(String msg)</span></span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"2fanoutConsumer 接收消息msg: &#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-3-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-4-3-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.4.3.3 在生产者项目中添加一个消息发送controller\"></a>2.4.3.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/28 11:50 AM</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FanoutProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * fanout类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * 虽然fanout类型下不需要routingKey 但是在调用convertAndSend方法时还是需要配置routingKey</span></span><br><span class=\"line\"><span class=\"comment\">     * 只是routingKey可以任意指定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/fanout/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">fanoutProducer</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg)</span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"fanout生产消息 msg:&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数是交换器名称 第二个参数是routingKey名称，fanout模式写任何key都会被无视 第三个是要发送的消息</span></span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"fanout_exchange\"</span>,<span class=\"string\">\"\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-3-4-测试\"><a href=\"#2-4-3-4-测试\" class=\"headerlink\" title=\"2.4.3.4 测试\"></a>2.4.3.4 测试</h4><p>分别启动这两个项目，在浏览器的路径上输入<a href=\"http://localhost:1180/fanout/测试消息\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/fanout/测试消息</a>，就可在消费者项目控制台中看到绑定这个fanout模式交换器的队列接收到的消息在控制台打印出来了。</p>\n<h3 id=\"2-4-4-direct代码实现\"><a href=\"#2-4-4-direct代码实现\" class=\"headerlink\" title=\"2.4.4 direct代码实现\"></a>2.4.4 direct代码实现</h3><h4 id=\"2-4-4-1-在消费者项目中添加一个配置类\"><a href=\"#2-4-4-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.4.4.1 在消费者项目中添加一个配置类\"></a>2.4.4.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.direct;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/29 1:40 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DirectConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义两个队列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"direct.queue1\"</span>,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"direct.queue2\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">directQueue3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"direct.queue3\"</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">true</span>, <span class=\"keyword\">true</span>, map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义 exchange</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">directExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"direct_exchange\"</span>,<span class=\"keyword\">true</span>,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列1 绑定 exchange 并且设置routingKey为direct.1</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue1()).to(directExchange()).with(<span class=\"string\">\"direct.routing.key1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 队列2 绑定 exchange 并且设置routingKey为direct.2</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue2()).to(directExchange()).with(<span class=\"string\">\"direct.routing.key2\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">directBinding3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(directQueue3()).to(directExchange()).with(<span class=\"string\">\"direct.routing.key1\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-4-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-4-4-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.4.4.2 在消费者项目中添加一个消息监听类\"></a>2.4.4.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">和fanout相同，只是监听的队列不同而已</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-4-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-4-4-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.4.4.3 在生产者项目中添加一个消息发送controller\"></a>2.4.4.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/28 11:50 AM</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DirectProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * direct类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/direct/queue1/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">directProducerOne</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"生产者生产消息:\"</span> + msg);</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息</span></span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"direct_exchange\"</span>, <span class=\"string\">\"direct.routing.key1\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/direct/queue2/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">directProducerTwo</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"生产者生产消息:\"</span> + msg);</span><br><span class=\"line\">        <span class=\"comment\">// 第一个参数是交换器名称 第二个参数是routingKey名称 第三个是要发送的消息</span></span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"mq-direct_exchange\"</span>, <span class=\"string\">\"direct.routing.key2\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-4-4-测试\"><a href=\"#2-4-4-4-测试\" class=\"headerlink\" title=\"2.4.4.4 测试\"></a>2.4.4.4 测试</h4><p>分别启动两个项目，在浏览器的路径上输入 <a href=\"http://localhost:1180/direct/queue1/测试消息1\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/direct/queue1/测试消息1</a> ，就可在消费者项目中看到打印的信息。<br>如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey设置为一样即可</p>\n<h3 id=\"2-4-5-topic代码实现\"><a href=\"#2-4-5-topic代码实现\" class=\"headerlink\" title=\"2.4.5 topic代码实现\"></a>2.4.5 topic代码实现</h3><h4 id=\"2-4-5-1-在消费者项目中添加一个配置类\"><a href=\"#2-4-5-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.4.5.1 在消费者项目中添加一个配置类\"></a>2.4.5.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.topic;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/29 8:42 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建队列</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueue1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"topic.queue1\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">topicQueue2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"topic.queue2\"</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建交换器</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TopicExchange <span class=\"title\">topicExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TopicExchange(<span class=\"string\">\"topic_exchange\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 绑定</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBinding1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(<span class=\"string\">\"*.jiafly.*\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">topicBinding2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(<span class=\"string\">\"com.jiafly.*\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-5-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-4-5-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.4.5.2 在消费者项目中添加一个消息监听类\"></a>2.4.5.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 和fanout类型相同，只是监听的队列不同而已</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-5-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-4-5-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.4.5.3 在生产者项目中添加一个消息发送controller\"></a>2.4.5.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/11/28 11:50 AM</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产者</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * topic类型</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/topic/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">topicProducerOne</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"topic:生产消息:\"</span> + msg);</span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"topic_exchange\"</span>, <span class=\"string\">\"com.jiafly.test\"</span>, msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-4-5-4-测试\"><a href=\"#2-4-5-4-测试\" class=\"headerlink\" title=\"2.4.5.4 测试\"></a>2.4.5.4 测试</h4><p>分别启动两个项目，在浏览器的路径上输入<a href=\"http://localhost:1180/topic/测试消息\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/topic/测试消息</a> ，就可在消费者项目中看到打印的信息。<br>如果需要两个队列接受相同的信息，只需要将两个队列绑定的routingKey使用<code>*</code>或者<code>#</code>表示</p>\n<h2 id=\"2-5-延时队列\"><a href=\"#2-5-延时队列\" class=\"headerlink\" title=\"2.5 延时队列\"></a>2.5 延时队列</h2><h3 id=\"2-5-1-延时队列能做什么\"><a href=\"#2-5-1-延时队列能做什么\" class=\"headerlink\" title=\"2.5.1 延时队列能做什么\"></a>2.5.1 延时队列能做什么</h3><ul>\n<li>订单业务：在电商/点餐中，都有下单后 30 分钟内没有付款，就自动取消订单。</li>\n<li>短信通知：下单成功后 60s 之后给用户发送短信通知。</li>\n<li>失败重试：业务操作失败后，间隔一定的时间进行失败重试</li>\n</ul>\n<p>这类业务的特点就是：非实时的，需要延迟处理，需要进行失败重试。一种比较笨的方式是采用定时任务，轮训数据库，方法简单好用，但性能底下，在高并发情况下容易弄死数据库，间隔时间不好设置，时间过大，影响精度，过小影响性能，而且做不到按超时的时间顺序处理。另一种就是用Java中的DelayQueue 位于java.util.concurrent包下，本质是由PriorityQueue和BlockingQueue实现的阻塞优先级队列。，这玩意最大的问题就是不支持分布式与持久化。</p>\n<p>在 AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面 所介绍的 DLX 和 TTL 模拟出延迟队列的功能。所以在介绍延时队列之前，首先介绍下DLX(Dead-Letter-Exchange)和TTL(Time to Live)。<br><img src=\"/image/rabbit/delay-mq.jpg\" alt=\"延时队列\"></p>\n<h3 id=\"2-5-2-死信交换器DLX-Dead-Letter-Exchange\"><a href=\"#2-5-2-死信交换器DLX-Dead-Letter-Exchange\" class=\"headerlink\" title=\"2.5.2 死信交换器DLX(Dead-Letter-Exchange)\"></a>2.5.2 死信交换器DLX(Dead-Letter-Exchange)</h3><p>DLX：死信队列，用来存储有超时时间信息的消息， 并且可以设置当消息超时时，转发到另一个指定队列(此处设置转发到router), 无消费者，当接收到客户端消息之后，等待消息超时，将消息转发到指定的Router队列。</p>\n<p>Router: 转发队列，用来接收死信队列超时消息， 如上示例消息，在接收到之后，消费者将消息解析，获取queueName，body,再向所获取的queueName队列发送一条消息，内容为body.</p>\n<p>具体代码实现:</p>\n<h4 id=\"2-5-2-1-在消费者项目中添加一个配置类\"><a href=\"#2-5-2-1-在消费者项目中添加一个配置类\" class=\"headerlink\" title=\"2.5.2.1 在消费者项目中添加一个配置类\"></a>2.5.2.1 在消费者项目中添加一个配置类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.delay;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Binding;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.Queue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/2 12:44 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个交换机</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DirectExchange <span class=\"title\">delayExchange</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DirectExchange(<span class=\"string\">\"delay_exchange\"</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 转发队列</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">routerQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"router.queue\"</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 转发队列绑定交换机</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">routerBinding</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(routerQueue()).to(delayExchange()).with(<span class=\"string\">\"router.routing.key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 死信队列</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Queue <span class=\"title\">deadLetterQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap(<span class=\"number\">16</span>);</span><br><span class=\"line\">        arguments.put(<span class=\"string\">\"x-dead-letter-exchange\"</span>, <span class=\"string\">\"delay_exchange\"</span>);</span><br><span class=\"line\">        arguments.put(<span class=\"string\">\"x-dead-letter-routing-key\"</span>, <span class=\"string\">\"router.routing.key\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Queue(<span class=\"string\">\"dead.letter.queue\"</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 死信队列绑定交换机</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Binding <span class=\"title\">deadLetterBinding</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(deadLetterQueue()).to(delayExchange()).with(<span class=\"string\">\"dead.letter.routing.key\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-2-2-在消费者项目中添加一个消息监听类\"><a href=\"#2-5-2-2-在消费者项目中添加一个消息监听类\" class=\"headerlink\" title=\"2.5.2.2 在消费者项目中添加一个消息监听类\"></a>2.5.2.2 在消费者项目中添加一个消息监听类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.consumer.delay;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/3 6:13 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener</span>(queues = <span class=\"string\">\"router.queue\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delayConsumer</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delay.queue1接收消息:&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-2-3-在生产者项目中添加一个消息发送controller\"><a href=\"#2-5-2-3-在生产者项目中添加一个消息发送controller\" class=\"headerlink\" title=\"2.5.2.3 在生产者项目中添加一个消息发送controller\"></a>2.5.2.3 在生产者项目中添加一个消息发送controller</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.rabbit.producer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.amqp.support.converter.AbstractJavaTypeMapper;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> liuyi</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/12/3 7:17 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>()</span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AmqpTemplate template;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 延迟队列</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> msg 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 消息内容</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/delay/&#123;msg&#125;\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">delayProducerOne</span><span class=\"params\">(@PathVariable(<span class=\"string\">\"msg\"</span>)</span> String msg) </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"delay:生产消息:\"</span> + msg);</span><br><span class=\"line\">        template.convertAndSend(<span class=\"string\">\"delay_exchange\"</span>, <span class=\"string\">\"dead.letter.routing.key\"</span>, msg, message -&gt; &#123;</span><br><span class=\"line\">            message.getMessageProperties().setExpiration(<span class=\"number\">30</span> * <span class=\"number\">1000</span> + <span class=\"string\">\"\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-5-2-4-测试\"><a href=\"#2-5-2-4-测试\" class=\"headerlink\" title=\"2.5.2.4 测试\"></a>2.5.2.4 测试</h4><p>分别启动两个项目，在浏览器的路径上输入<a href=\"http://localhost:1180/delay/测试消息\" target=\"_blank\" rel=\"noopener\">http://localhost:1180/delay/测试消息</a>，就可在消费者项目中看到打印的信息。30秒后可以看到消费者管理后台有刚刚发送的消息被打印出来了。</p>\n<h2 id=\"2-6-消息的持久化\"><a href=\"#2-6-消息的持久化\" class=\"headerlink\" title=\"2.6 消息的持久化\"></a>2.6 消息的持久化</h2><p>为了保证RabbitMQ在重启、奔溃等异常情况下数据没有丢失，除了对消息本身持久化为，还需要将消息传输经过的队列(queue)，交互机进行持久化(exchange)，持久化以上元素后，消息才算真正RabbitMQ重启不会丢失。<br>创建时候的参数:</p>\n<ul>\n<li><code>durable</code><br>是否持久化，如果true，则此种队列叫持久化队列（Durable queues）。此队列会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。 </li>\n<li><code>execulusive</code><br>表示此对应只能被当前创建的连接使用，而且当连接关闭后队列即被删除。此参考优先级高于durable </li>\n<li><code>autoDelete</code><br>当没有生成者/消费者使用此队列时，此队列会被自动删除。<br>(即当最后一个消费者退订后即被删除)</li>\n</ul>\n<p><strong>设置消息持久化必须先设置队列持久化</strong>，要不然队列不持久化，消息持久化，队列都不存在了，消息存在还有什么意义。<code>消息持久化需要将交换机持久化、队列持久化、消息持久化，才能最终达到持久化的目的</code>。其实在前面就已经使用持久化了。我们在管理后台去看一下。</p>\n<h2 id=\"2-7-消息的确认与拒绝\"><a href=\"#2-7-消息的确认与拒绝\" class=\"headerlink\" title=\"2.7 消息的确认与拒绝\"></a>2.7 消息的确认与拒绝</h2><p>消费者在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题，对于此AMQP有两种处理方式：</p>\n<ul>\n<li><p><code>自动确认模式</code>:<br>当RabbbitMQ将消息发送给应用后，消费者端自动回送一个确认消息，此时RabbitMQ删除此消息。</p>\n</li>\n<li><p><code>显式确认模式</code>:<br>消费者收到消息后，可以在执行一些逻辑后，消费者自己决定什么时候发送确认回执（acknowledgement），RabbitMQ收到回执后才删除消息，这样就保证消费端不会丢失消息</p>\n</li>\n</ul>\n<p>如果一个消费者在尚未发送确认回执的情况下挂掉了，那么消息会被重新放入队列，并且在还有其他消费者存在于此队列的前提下，立即投递给另外一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。RabbitMQ里的消息是不会过期。当消费者挂掉后，RabbitMQ会不断尝试重推。所有单个消息的推送可能花费很长的时间。</p>"},{"title":"Docker-安装常用镜像","date":"2019-05-15T12:31:00.000Z","top":8,"_content":"# 1.前言\n我们在平时的开发中可能会用到mysql，redis 还有mongodb等用于存储数据，但是有时候我们使用测试环境可能不太方便(例如:在家不能连接公司数据库)，这时候我们可以在本地或者自己的云服务器上就有了发挥的作用了，但是如果我们在本地安装这些的话就很占我们电脑的内存了，这时候docker就登场了。\n<!-- more -->\n# 2.安装docker\n## 2.1 在linux上安装docker\n在linux上安装docker其实是比较简单的，只需要在命令行中敲入即可，这里我以为Ubuntu系统为例:\n```bash\n$ sudo apt-get -y install docker.io\n```\n就这样docker就安装完了，我们可以输入docker，查看docker可以使用的命令。显示如下图，说明已经安装成功。\n```bash\n$ docker\n```\n![docker](/image/docker/docker-util.jpg)\n\n## 2.2 在macOS上安装docker\n### 2.2.1 macOS 我们可以使用 Homebrew 来安装 Docker\n```bash\n$ brew cask install docker\n\n==> Creating Caskroom at /usr/local/Caskroom\n==> We'll set permissions properly so we won't need sudo in the future\nPassword:          # 输入 macOS 密码\n==> Satisfying dependencies\n==> Downloading https://download.docker.com/mac/stable/21090/Docker.dmg\n######################################################################## 100.0%\n==> Verifying checksum for Cask docker\n==> Installing Cask docker\n==> Moving App 'Docker.app' to '/Applications/Docker.app'.\n&#x1f37a;  docker was successfully installed!\n```\n### 2.2.2 手动下载安装\n点击以下链接下载[dmg下载链接](https://download.docker.com/mac/stable/Docker.dmg) 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到Application 文件夹即可。\n\n## 2.3 在Windows上安装docker\n[windows下载链接](https://www.docker.com/get-docker) 和windows其他程序安装方式相同。\n\n# 3.基于docker安装常用镜像\n## 3.1 安装mysql\n**/data/docker/mysql** 是宿主机目录用来映射mysql的数据\n### 3.1.1 安装\n```bash\n$ docker pull mysql:8.0.16\n```\n等待下载完成后即安装完成，接下来就是启动镜像了。\n### 3.1.2 启动镜像\n- **普通启动**\n```bash\n$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16\n\n```\n启动镜像名称为mysql，前面一个端口是映射端口，`root`是数据库密码，**/data/docker/mysql** 是宿主机目录用来保存mysql的数据。\n- **设置时区和宿主机相同启动**\n```bash\n$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16\n\n```\n启动镜像名称为mysql，前面一个端口是映射端口，`root`是数据库密码， **-v /etc/localtime:/etc/localtime**是设置时区与宿主机一致，**/data/docker/mysql** 是宿主机目录用来保存mysql的数据。\n\n### 3.1.3 启动mysql\n```bash\n$ docker start mysql\n```\n\n## 3.2 安装redis\n### 3.2.1 安装redis\n```bash\n$ docker pull reids:5.0.4\n```\n\n### 3.2.2 启动镜像\n```bash\n$ docker run --name redis -p 6379:6379 -v /data/docker/redis:/data -d redis:5.0.4 redis-server --appendonly yes --requirepass \"root\"\n\n```\n启动镜像名称为redis，前面一个端口是映射端口，**/data/docker/redis**是宿主机数据保存地址 **，appendonly yes**是后台启动，**requirepass \"root\"**是设置密码为`root`\n\n### 3.2.3 启动ridis\n```bash\n$ docker start redis\n```\n\n\n## 3.3 安装MongoDB\n### 3.3.1 安装MongoDB\n```bash\n$ docker pull mongo\n```\n\n### 3.3.2 启动镜像\n- 启动\n```bash\n$ docker run --name mongo -p 27017:27017 -v /data/docker/mongo:/data/db -d mongo:latest --auth\n\n```\n- 新建管理员\n```bash\n$ docker exec -it mongo mongo admin\n>>  db.createUser({ user: 'admin', pwd: 'admin', roles: [ { role: 'userAdminAnyDatabase', db: 'admin' } ]});\n```\n执行之后看到如下信息则创建成功。\n```bash\nSuccessfully added user: {\n    \"user\" : \"admin\",\n    \"roles\" : [\n        {\n            \"role\" : \"userAdminAnyDatabase\",\n            \"db\" : \"admin\"\n        }\n    ]\n}\n```\n\n### 3.3.3 启动MongoDB\n```bash\n$ docker start mongo\n```\n\n# 3. 结语\n我们在使用docker的时候有时候想进入容器可以使用如下命令进入，最后的mysql可以使用容器的名称或者容器的id。\n```bash\n$ docker exec -it mysql /bin/bash\n```\n\n\n","source":"_posts/docker/Docker-安装常用镜像.md","raw":"---\ntitle: Docker-安装常用镜像\ndate: 2019-05-15 20:31:00\ntags:\n    - docker\ncategories: \n    - docker\ntop: 8\n---\n# 1.前言\n我们在平时的开发中可能会用到mysql，redis 还有mongodb等用于存储数据，但是有时候我们使用测试环境可能不太方便(例如:在家不能连接公司数据库)，这时候我们可以在本地或者自己的云服务器上就有了发挥的作用了，但是如果我们在本地安装这些的话就很占我们电脑的内存了，这时候docker就登场了。\n<!-- more -->\n# 2.安装docker\n## 2.1 在linux上安装docker\n在linux上安装docker其实是比较简单的，只需要在命令行中敲入即可，这里我以为Ubuntu系统为例:\n```bash\n$ sudo apt-get -y install docker.io\n```\n就这样docker就安装完了，我们可以输入docker，查看docker可以使用的命令。显示如下图，说明已经安装成功。\n```bash\n$ docker\n```\n![docker](/image/docker/docker-util.jpg)\n\n## 2.2 在macOS上安装docker\n### 2.2.1 macOS 我们可以使用 Homebrew 来安装 Docker\n```bash\n$ brew cask install docker\n\n==> Creating Caskroom at /usr/local/Caskroom\n==> We'll set permissions properly so we won't need sudo in the future\nPassword:          # 输入 macOS 密码\n==> Satisfying dependencies\n==> Downloading https://download.docker.com/mac/stable/21090/Docker.dmg\n######################################################################## 100.0%\n==> Verifying checksum for Cask docker\n==> Installing Cask docker\n==> Moving App 'Docker.app' to '/Applications/Docker.app'.\n&#x1f37a;  docker was successfully installed!\n```\n### 2.2.2 手动下载安装\n点击以下链接下载[dmg下载链接](https://download.docker.com/mac/stable/Docker.dmg) 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到Application 文件夹即可。\n\n## 2.3 在Windows上安装docker\n[windows下载链接](https://www.docker.com/get-docker) 和windows其他程序安装方式相同。\n\n# 3.基于docker安装常用镜像\n## 3.1 安装mysql\n**/data/docker/mysql** 是宿主机目录用来映射mysql的数据\n### 3.1.1 安装\n```bash\n$ docker pull mysql:8.0.16\n```\n等待下载完成后即安装完成，接下来就是启动镜像了。\n### 3.1.2 启动镜像\n- **普通启动**\n```bash\n$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16\n\n```\n启动镜像名称为mysql，前面一个端口是映射端口，`root`是数据库密码，**/data/docker/mysql** 是宿主机目录用来保存mysql的数据。\n- **设置时区和宿主机相同启动**\n```bash\n$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16\n\n```\n启动镜像名称为mysql，前面一个端口是映射端口，`root`是数据库密码， **-v /etc/localtime:/etc/localtime**是设置时区与宿主机一致，**/data/docker/mysql** 是宿主机目录用来保存mysql的数据。\n\n### 3.1.3 启动mysql\n```bash\n$ docker start mysql\n```\n\n## 3.2 安装redis\n### 3.2.1 安装redis\n```bash\n$ docker pull reids:5.0.4\n```\n\n### 3.2.2 启动镜像\n```bash\n$ docker run --name redis -p 6379:6379 -v /data/docker/redis:/data -d redis:5.0.4 redis-server --appendonly yes --requirepass \"root\"\n\n```\n启动镜像名称为redis，前面一个端口是映射端口，**/data/docker/redis**是宿主机数据保存地址 **，appendonly yes**是后台启动，**requirepass \"root\"**是设置密码为`root`\n\n### 3.2.3 启动ridis\n```bash\n$ docker start redis\n```\n\n\n## 3.3 安装MongoDB\n### 3.3.1 安装MongoDB\n```bash\n$ docker pull mongo\n```\n\n### 3.3.2 启动镜像\n- 启动\n```bash\n$ docker run --name mongo -p 27017:27017 -v /data/docker/mongo:/data/db -d mongo:latest --auth\n\n```\n- 新建管理员\n```bash\n$ docker exec -it mongo mongo admin\n>>  db.createUser({ user: 'admin', pwd: 'admin', roles: [ { role: 'userAdminAnyDatabase', db: 'admin' } ]});\n```\n执行之后看到如下信息则创建成功。\n```bash\nSuccessfully added user: {\n    \"user\" : \"admin\",\n    \"roles\" : [\n        {\n            \"role\" : \"userAdminAnyDatabase\",\n            \"db\" : \"admin\"\n        }\n    ]\n}\n```\n\n### 3.3.3 启动MongoDB\n```bash\n$ docker start mongo\n```\n\n# 3. 结语\n我们在使用docker的时候有时候想进入容器可以使用如下命令进入，最后的mysql可以使用容器的名称或者容器的id。\n```bash\n$ docker exec -it mysql /bin/bash\n```\n\n\n","slug":"docker/Docker-安装常用镜像","published":1,"updated":"2019-11-26T05:53:54.378Z","_id":"ck38agcoi000ajfus0yojhg74","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>我们在平时的开发中可能会用到mysql，redis 还有mongodb等用于存储数据，但是有时候我们使用测试环境可能不太方便(例如:在家不能连接公司数据库)，这时候我们可以在本地或者自己的云服务器上就有了发挥的作用了，但是如果我们在本地安装这些的话就很占我们电脑的内存了，这时候docker就登场了。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-安装docker\"><a href=\"#2-安装docker\" class=\"headerlink\" title=\"2.安装docker\"></a>2.安装docker</h1><h2 id=\"2-1-在linux上安装docker\"><a href=\"#2-1-在linux上安装docker\" class=\"headerlink\" title=\"2.1 在linux上安装docker\"></a>2.1 在linux上安装docker</h2><p>在linux上安装docker其实是比较简单的，只需要在命令行中敲入即可，这里我以为Ubuntu系统为例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get -y install docker.io</span><br></pre></td></tr></table></figure>\n<p>就这样docker就安装完了，我们可以输入docker，查看docker可以使用的命令。显示如下图，说明已经安装成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker</span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/docker/docker-util.jpg\" alt=\"docker\"></p>\n<h2 id=\"2-2-在macOS上安装docker\"><a href=\"#2-2-在macOS上安装docker\" class=\"headerlink\" title=\"2.2 在macOS上安装docker\"></a>2.2 在macOS上安装docker</h2><h3 id=\"2-2-1-macOS-我们可以使用-Homebrew-来安装-Docker\"><a href=\"#2-2-1-macOS-我们可以使用-Homebrew-来安装-Docker\" class=\"headerlink\" title=\"2.2.1 macOS 我们可以使用 Homebrew 来安装 Docker\"></a>2.2.1 macOS 我们可以使用 Homebrew 来安装 Docker</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew cask install docker</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; Creating Caskroom at /usr/<span class=\"built_in\">local</span>/Caskroom</span><br><span class=\"line\">==&gt; We<span class=\"string\">'ll set permissions properly so we won'</span>t need sudo <span class=\"keyword\">in</span> the future</span><br><span class=\"line\">Password:          <span class=\"comment\"># 输入 macOS 密码</span></span><br><span class=\"line\">==&gt; Satisfying dependencies</span><br><span class=\"line\">==&gt; Downloading https://download.docker.com/mac/stable/21090/Docker.dmg</span><br><span class=\"line\"><span class=\"comment\">######################################################################## 100.0%</span></span><br><span class=\"line\">==&gt; Verifying checksum <span class=\"keyword\">for</span> Cask docker</span><br><span class=\"line\">==&gt; Installing Cask docker</span><br><span class=\"line\">==&gt; Moving App <span class=\"string\">'Docker.app'</span> to <span class=\"string\">'/Applications/Docker.app'</span>.</span><br><span class=\"line\">&amp;<span class=\"comment\">#x1f37a;  docker was successfully installed!</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-2-手动下载安装\"><a href=\"#2-2-2-手动下载安装\" class=\"headerlink\" title=\"2.2.2 手动下载安装\"></a>2.2.2 手动下载安装</h3><p>点击以下链接下载<a href=\"https://download.docker.com/mac/stable/Docker.dmg\" target=\"_blank\" rel=\"noopener\">dmg下载链接</a> 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到Application 文件夹即可。</p>\n<h2 id=\"2-3-在Windows上安装docker\"><a href=\"#2-3-在Windows上安装docker\" class=\"headerlink\" title=\"2.3 在Windows上安装docker\"></a>2.3 在Windows上安装docker</h2><p><a href=\"https://www.docker.com/get-docker\" target=\"_blank\" rel=\"noopener\">windows下载链接</a> 和windows其他程序安装方式相同。</p>\n<h1 id=\"3-基于docker安装常用镜像\"><a href=\"#3-基于docker安装常用镜像\" class=\"headerlink\" title=\"3.基于docker安装常用镜像\"></a>3.基于docker安装常用镜像</h1><h2 id=\"3-1-安装mysql\"><a href=\"#3-1-安装mysql\" class=\"headerlink\" title=\"3.1 安装mysql\"></a>3.1 安装mysql</h2><p><strong>/data/docker/mysql</strong> 是宿主机目录用来映射mysql的数据</p>\n<h3 id=\"3-1-1-安装\"><a href=\"#3-1-1-安装\" class=\"headerlink\" title=\"3.1.1 安装\"></a>3.1.1 安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull mysql:8.0.16</span><br></pre></td></tr></table></figure>\n<p>等待下载完成后即安装完成，接下来就是启动镜像了。</p>\n<h3 id=\"3-1-2-启动镜像\"><a href=\"#3-1-2-启动镜像\" class=\"headerlink\" title=\"3.1.2 启动镜像\"></a>3.1.2 启动镜像</h3><ul>\n<li><strong>普通启动</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16</span><br></pre></td></tr></table></figure>\n启动镜像名称为mysql，前面一个端口是映射端口，<code>root</code>是数据库密码，<strong>/data/docker/mysql</strong> 是宿主机目录用来保存mysql的数据。</li>\n<li><strong>设置时区和宿主机相同启动</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16</span><br></pre></td></tr></table></figure>\n启动镜像名称为mysql，前面一个端口是映射端口，<code>root</code>是数据库密码， <strong>-v /etc/localtime:/etc/localtime</strong>是设置时区与宿主机一致，<strong>/data/docker/mysql</strong> 是宿主机目录用来保存mysql的数据。</li>\n</ul>\n<h3 id=\"3-1-3-启动mysql\"><a href=\"#3-1-3-启动mysql\" class=\"headerlink\" title=\"3.1.3 启动mysql\"></a>3.1.3 启动mysql</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start mysql</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-安装redis\"><a href=\"#3-2-安装redis\" class=\"headerlink\" title=\"3.2 安装redis\"></a>3.2 安装redis</h2><h3 id=\"3-2-1-安装redis\"><a href=\"#3-2-1-安装redis\" class=\"headerlink\" title=\"3.2.1 安装redis\"></a>3.2.1 安装redis</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull reids:5.0.4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-启动镜像\"><a href=\"#3-2-2-启动镜像\" class=\"headerlink\" title=\"3.2.2 启动镜像\"></a>3.2.2 启动镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name redis -p 6379:6379 -v /data/docker/redis:/data -d redis:5.0.4 redis-server --appendonly yes --requirepass <span class=\"string\">\"root\"</span></span><br></pre></td></tr></table></figure>\n<p>启动镜像名称为redis，前面一个端口是映射端口，<strong>/data/docker/redis</strong>是宿主机数据保存地址 <strong>，appendonly yes</strong>是后台启动，<strong>requirepass “root”</strong>是设置密码为<code>root</code></p>\n<h3 id=\"3-2-3-启动ridis\"><a href=\"#3-2-3-启动ridis\" class=\"headerlink\" title=\"3.2.3 启动ridis\"></a>3.2.3 启动ridis</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start redis</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-3-安装MongoDB\"><a href=\"#3-3-安装MongoDB\" class=\"headerlink\" title=\"3.3 安装MongoDB\"></a>3.3 安装MongoDB</h2><h3 id=\"3-3-1-安装MongoDB\"><a href=\"#3-3-1-安装MongoDB\" class=\"headerlink\" title=\"3.3.1 安装MongoDB\"></a>3.3.1 安装MongoDB</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull mongo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-2-启动镜像\"><a href=\"#3-3-2-启动镜像\" class=\"headerlink\" title=\"3.3.2 启动镜像\"></a>3.3.2 启动镜像</h3><ul>\n<li>启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mongo -p 27017:27017 -v /data/docker/mongo:/data/db -d mongo:latest --auth</span><br></pre></td></tr></table></figure></li>\n<li>新建管理员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it mongo mongo admin</span><br><span class=\"line\">&gt;&gt;  db.createUser(&#123; user: <span class=\"string\">'admin'</span>, <span class=\"built_in\">pwd</span>: <span class=\"string\">'admin'</span>, roles: [ &#123; role: <span class=\"string\">'userAdminAnyDatabase'</span>, db: <span class=\"string\">'admin'</span> &#125; ]&#125;);</span><br></pre></td></tr></table></figure>\n执行之后看到如下信息则创建成功。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Successfully added user: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span> : <span class=\"string\">\"admin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"roles\"</span> : [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"role\"</span> : <span class=\"string\">\"userAdminAnyDatabase\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"db\"</span> : <span class=\"string\">\"admin\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-3-3-启动MongoDB\"><a href=\"#3-3-3-启动MongoDB\" class=\"headerlink\" title=\"3.3.3 启动MongoDB\"></a>3.3.3 启动MongoDB</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start mongo</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-结语\"><a href=\"#3-结语\" class=\"headerlink\" title=\"3. 结语\"></a>3. 结语</h1><p>我们在使用docker的时候有时候想进入容器可以使用如下命令进入，最后的mysql可以使用容器的名称或者容器的id。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it mysql /bin/bash</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>我们在平时的开发中可能会用到mysql，redis 还有mongodb等用于存储数据，但是有时候我们使用测试环境可能不太方便(例如:在家不能连接公司数据库)，这时候我们可以在本地或者自己的云服务器上就有了发挥的作用了，但是如果我们在本地安装这些的话就很占我们电脑的内存了，这时候docker就登场了。</p>","more":"<h1 id=\"2-安装docker\"><a href=\"#2-安装docker\" class=\"headerlink\" title=\"2.安装docker\"></a>2.安装docker</h1><h2 id=\"2-1-在linux上安装docker\"><a href=\"#2-1-在linux上安装docker\" class=\"headerlink\" title=\"2.1 在linux上安装docker\"></a>2.1 在linux上安装docker</h2><p>在linux上安装docker其实是比较简单的，只需要在命令行中敲入即可，这里我以为Ubuntu系统为例:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get -y install docker.io</span><br></pre></td></tr></table></figure>\n<p>就这样docker就安装完了，我们可以输入docker，查看docker可以使用的命令。显示如下图，说明已经安装成功。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker</span><br></pre></td></tr></table></figure>\n<p><img src=\"/image/docker/docker-util.jpg\" alt=\"docker\"></p>\n<h2 id=\"2-2-在macOS上安装docker\"><a href=\"#2-2-在macOS上安装docker\" class=\"headerlink\" title=\"2.2 在macOS上安装docker\"></a>2.2 在macOS上安装docker</h2><h3 id=\"2-2-1-macOS-我们可以使用-Homebrew-来安装-Docker\"><a href=\"#2-2-1-macOS-我们可以使用-Homebrew-来安装-Docker\" class=\"headerlink\" title=\"2.2.1 macOS 我们可以使用 Homebrew 来安装 Docker\"></a>2.2.1 macOS 我们可以使用 Homebrew 来安装 Docker</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ brew cask install docker</span><br><span class=\"line\"></span><br><span class=\"line\">==&gt; Creating Caskroom at /usr/<span class=\"built_in\">local</span>/Caskroom</span><br><span class=\"line\">==&gt; We<span class=\"string\">'ll set permissions properly so we won'</span>t need sudo <span class=\"keyword\">in</span> the future</span><br><span class=\"line\">Password:          <span class=\"comment\"># 输入 macOS 密码</span></span><br><span class=\"line\">==&gt; Satisfying dependencies</span><br><span class=\"line\">==&gt; Downloading https://download.docker.com/mac/stable/21090/Docker.dmg</span><br><span class=\"line\"><span class=\"comment\">######################################################################## 100.0%</span></span><br><span class=\"line\">==&gt; Verifying checksum <span class=\"keyword\">for</span> Cask docker</span><br><span class=\"line\">==&gt; Installing Cask docker</span><br><span class=\"line\">==&gt; Moving App <span class=\"string\">'Docker.app'</span> to <span class=\"string\">'/Applications/Docker.app'</span>.</span><br><span class=\"line\">&amp;<span class=\"comment\">#x1f37a;  docker was successfully installed!</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-2-手动下载安装\"><a href=\"#2-2-2-手动下载安装\" class=\"headerlink\" title=\"2.2.2 手动下载安装\"></a>2.2.2 手动下载安装</h3><p>点击以下链接下载<a href=\"https://download.docker.com/mac/stable/Docker.dmg\" target=\"_blank\" rel=\"noopener\">dmg下载链接</a> 如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将鲸鱼图标拖拽到Application 文件夹即可。</p>\n<h2 id=\"2-3-在Windows上安装docker\"><a href=\"#2-3-在Windows上安装docker\" class=\"headerlink\" title=\"2.3 在Windows上安装docker\"></a>2.3 在Windows上安装docker</h2><p><a href=\"https://www.docker.com/get-docker\" target=\"_blank\" rel=\"noopener\">windows下载链接</a> 和windows其他程序安装方式相同。</p>\n<h1 id=\"3-基于docker安装常用镜像\"><a href=\"#3-基于docker安装常用镜像\" class=\"headerlink\" title=\"3.基于docker安装常用镜像\"></a>3.基于docker安装常用镜像</h1><h2 id=\"3-1-安装mysql\"><a href=\"#3-1-安装mysql\" class=\"headerlink\" title=\"3.1 安装mysql\"></a>3.1 安装mysql</h2><p><strong>/data/docker/mysql</strong> 是宿主机目录用来映射mysql的数据</p>\n<h3 id=\"3-1-1-安装\"><a href=\"#3-1-1-安装\" class=\"headerlink\" title=\"3.1.1 安装\"></a>3.1.1 安装</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull mysql:8.0.16</span><br></pre></td></tr></table></figure>\n<p>等待下载完成后即安装完成，接下来就是启动镜像了。</p>\n<h3 id=\"3-1-2-启动镜像\"><a href=\"#3-1-2-启动镜像\" class=\"headerlink\" title=\"3.1.2 启动镜像\"></a>3.1.2 启动镜像</h3><ul>\n<li><strong>普通启动</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16</span><br></pre></td></tr></table></figure>\n启动镜像名称为mysql，前面一个端口是映射端口，<code>root</code>是数据库密码，<strong>/data/docker/mysql</strong> 是宿主机目录用来保存mysql的数据。</li>\n<li><strong>设置时区和宿主机相同启动</strong><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mysql -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql:/var/lib/mysql -d mysql:8.0.16</span><br></pre></td></tr></table></figure>\n启动镜像名称为mysql，前面一个端口是映射端口，<code>root</code>是数据库密码， <strong>-v /etc/localtime:/etc/localtime</strong>是设置时区与宿主机一致，<strong>/data/docker/mysql</strong> 是宿主机目录用来保存mysql的数据。</li>\n</ul>\n<h3 id=\"3-1-3-启动mysql\"><a href=\"#3-1-3-启动mysql\" class=\"headerlink\" title=\"3.1.3 启动mysql\"></a>3.1.3 启动mysql</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start mysql</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-安装redis\"><a href=\"#3-2-安装redis\" class=\"headerlink\" title=\"3.2 安装redis\"></a>3.2 安装redis</h2><h3 id=\"3-2-1-安装redis\"><a href=\"#3-2-1-安装redis\" class=\"headerlink\" title=\"3.2.1 安装redis\"></a>3.2.1 安装redis</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull reids:5.0.4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-启动镜像\"><a href=\"#3-2-2-启动镜像\" class=\"headerlink\" title=\"3.2.2 启动镜像\"></a>3.2.2 启动镜像</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name redis -p 6379:6379 -v /data/docker/redis:/data -d redis:5.0.4 redis-server --appendonly yes --requirepass <span class=\"string\">\"root\"</span></span><br></pre></td></tr></table></figure>\n<p>启动镜像名称为redis，前面一个端口是映射端口，<strong>/data/docker/redis</strong>是宿主机数据保存地址 <strong>，appendonly yes</strong>是后台启动，<strong>requirepass “root”</strong>是设置密码为<code>root</code></p>\n<h3 id=\"3-2-3-启动ridis\"><a href=\"#3-2-3-启动ridis\" class=\"headerlink\" title=\"3.2.3 启动ridis\"></a>3.2.3 启动ridis</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start redis</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-3-安装MongoDB\"><a href=\"#3-3-安装MongoDB\" class=\"headerlink\" title=\"3.3 安装MongoDB\"></a>3.3 安装MongoDB</h2><h3 id=\"3-3-1-安装MongoDB\"><a href=\"#3-3-1-安装MongoDB\" class=\"headerlink\" title=\"3.3.1 安装MongoDB\"></a>3.3.1 安装MongoDB</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull mongo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-2-启动镜像\"><a href=\"#3-3-2-启动镜像\" class=\"headerlink\" title=\"3.3.2 启动镜像\"></a>3.3.2 启动镜像</h3><ul>\n<li>启动<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mongo -p 27017:27017 -v /data/docker/mongo:/data/db -d mongo:latest --auth</span><br></pre></td></tr></table></figure></li>\n<li>新建管理员<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it mongo mongo admin</span><br><span class=\"line\">&gt;&gt;  db.createUser(&#123; user: <span class=\"string\">'admin'</span>, <span class=\"built_in\">pwd</span>: <span class=\"string\">'admin'</span>, roles: [ &#123; role: <span class=\"string\">'userAdminAnyDatabase'</span>, db: <span class=\"string\">'admin'</span> &#125; ]&#125;);</span><br></pre></td></tr></table></figure>\n执行之后看到如下信息则创建成功。<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Successfully added user: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span> : <span class=\"string\">\"admin\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"roles\"</span> : [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"role\"</span> : <span class=\"string\">\"userAdminAnyDatabase\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"db\"</span> : <span class=\"string\">\"admin\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"3-3-3-启动MongoDB\"><a href=\"#3-3-3-启动MongoDB\" class=\"headerlink\" title=\"3.3.3 启动MongoDB\"></a>3.3.3 启动MongoDB</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start mongo</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-结语\"><a href=\"#3-结语\" class=\"headerlink\" title=\"3. 结语\"></a>3. 结语</h1><p>我们在使用docker的时候有时候想进入容器可以使用如下命令进入，最后的mysql可以使用容器的名称或者容器的id。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it mysql /bin/bash</span><br></pre></td></tr></table></figure>"},{"title":"Docker-介绍","date":"2018-09-19T12:13:14.000Z","top":10,"_content":"# 1.前言\n## 1.1 什么是Docker？\n\nDocker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及 AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为**容器**。\n<!-- more -->\nDocker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker技术比虚拟机技术更为轻便、快捷。\n传统虚拟机技术是虚拟 出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程;而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n\n## 1.2 为什么要使用docker？\n作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。\n\n- **更高效的利用系统资源**\n\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n\n- **更快速的启动时间**\n\n传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。\n\n\n- **一致的运行环境**\n\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。\n\n\n- **持续交付和部署**\n\n使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成(Continuous Integration)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment)系统进行自动部署。\n\n\n- **更轻松的迁移**\n\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n\n- **更轻松的维护和扩展**\n\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n\n- **对比传统虚拟机总结**\n\n| 特性 | 容器 | 虚拟机 |\n| ----- | :-----: | :-----: |\n| **启动** | 秒级 | 分钟级 |\n| **硬盘使用** | 一般为MB | 一般为GB |\n| **性能** | 接近原生 | 弱于|\n| **系统支持量** | 单机支持上千个容器 | 一般几十个 |\n\n\n# 2. Docker的几个基本概念\n\n## 2.1 Docker镜像(image)\n\n我们都知道，**操作系统分为内核和用户空间**。对于Linux而言，内核启动后，会挂载文件系统为其提供用户空间支持。而Docker镜像(Image)，就相当于是一个文件系统。比如官方镜像ubuntu:14.04就包含了完整的一套Ubuntu14.04最小系统的root文件系统。\n\n\n因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时，就充分利用UnionFS的技术，将其设计为**分层存储的架构**。所以严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说是由多层文件系统联合组成。\n\n\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n\n\n**分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。**\n\n\n## 2.2 Docker容器(container)\n\n镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n**容器的实质是进程，但是与直接在宿主机上执行的进程不同，容器进程运行于属于自己的独立的*命名空间***。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。\n\n每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(Volume)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。\n\n## 2.3 Docker仓库(registry)\n镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。\n\n下面以Ubuntu镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如:14.04,16.04。 我们可以通过ubuntu:14.04或者ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，那将视为ubuntu:latest。\n### 2.3.1 公有仓库\n最常使用的公有仓库是DockerHub，这也是默认的仓库，拥有大量的官方镜像。还有还有CoreOS的Quay.io，Google的Google Container Registry，Kubernetes 的镜像使用的就是Google的服务。\n\n由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对Docker Hub的镜像服务(Registry Mirror)，这些镜像服务被称为加速器。常见的有:阿里云加速器、DaoCloud加速器、灵雀云加速器等。\n\n### 2.3.2 私有仓库\n用户还可以在本地搭建私有Docker Registry。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。","source":"_posts/docker/Docker-介绍.md","raw":"---\ntitle: Docker-介绍\ndate: 2018-09-19 20:13:14\ntags: \n    - docker\ncategories: \n    - docker\ntop: 10\n---\n# 1.前言\n## 1.1 什么是Docker？\n\nDocker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及 AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为**容器**。\n<!-- more -->\nDocker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker技术比虚拟机技术更为轻便、快捷。\n传统虚拟机技术是虚拟 出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程;而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n\n## 1.2 为什么要使用docker？\n作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。\n\n- **更高效的利用系统资源**\n\n由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n\n\n- **更快速的启动时间**\n\n传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。\n\n\n- **一致的运行环境**\n\n开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。\n\n\n- **持续交付和部署**\n\n使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成(Continuous Integration)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment)系统进行自动部署。\n\n\n- **更轻松的迁移**\n\n由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n\n\n- **更轻松的维护和扩展**\n\nDocker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n\n\n- **对比传统虚拟机总结**\n\n| 特性 | 容器 | 虚拟机 |\n| ----- | :-----: | :-----: |\n| **启动** | 秒级 | 分钟级 |\n| **硬盘使用** | 一般为MB | 一般为GB |\n| **性能** | 接近原生 | 弱于|\n| **系统支持量** | 单机支持上千个容器 | 一般几十个 |\n\n\n# 2. Docker的几个基本概念\n\n## 2.1 Docker镜像(image)\n\n我们都知道，**操作系统分为内核和用户空间**。对于Linux而言，内核启动后，会挂载文件系统为其提供用户空间支持。而Docker镜像(Image)，就相当于是一个文件系统。比如官方镜像ubuntu:14.04就包含了完整的一套Ubuntu14.04最小系统的root文件系统。\n\n\n因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时，就充分利用UnionFS的技术，将其设计为**分层存储的架构**。所以严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说是由多层文件系统联合组成。\n\n\n镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。\n\n\n**分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。**\n\n\n## 2.2 Docker容器(container)\n\n镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n\n**容器的实质是进程，但是与直接在宿主机上执行的进程不同，容器进程运行于属于自己的独立的*命名空间***。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。\n\n每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。\n\n容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(Volume)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。\n\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。\n\n## 2.3 Docker仓库(registry)\n镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。\n\n下面以Ubuntu镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如:14.04,16.04。 我们可以通过ubuntu:14.04或者ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，那将视为ubuntu:latest。\n### 2.3.1 公有仓库\n最常使用的公有仓库是DockerHub，这也是默认的仓库，拥有大量的官方镜像。还有还有CoreOS的Quay.io，Google的Google Container Registry，Kubernetes 的镜像使用的就是Google的服务。\n\n由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对Docker Hub的镜像服务(Registry Mirror)，这些镜像服务被称为加速器。常见的有:阿里云加速器、DaoCloud加速器、灵雀云加速器等。\n\n### 2.3.2 私有仓库\n用户还可以在本地搭建私有Docker Registry。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。","slug":"docker/Docker-介绍","published":1,"updated":"2019-11-26T05:53:54.372Z","_id":"ck38agcoj000bjfus6bufbp4z","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><h2 id=\"1-1-什么是Docker？\"><a href=\"#1-1-什么是Docker？\" class=\"headerlink\" title=\"1.1 什么是Docker？\"></a>1.1 什么是Docker？</h2><p>Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及 AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为<strong>容器</strong>。</p>\n<a id=\"more\"></a>\n<p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker技术比虚拟机技术更为轻便、快捷。<br>传统虚拟机技术是虚拟 出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程;而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>\n<h2 id=\"1-2-为什么要使用docker？\"><a href=\"#1-2-为什么要使用docker？\" class=\"headerlink\" title=\"1.2 为什么要使用docker？\"></a>1.2 为什么要使用docker？</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>\n<ul>\n<li><strong>更高效的利用系统资源</strong></li>\n</ul>\n<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<ul>\n<li><strong>更快速的启动时间</strong></li>\n</ul>\n<p>传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。</p>\n<ul>\n<li><strong>一致的运行环境</strong></li>\n</ul>\n<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。</p>\n<ul>\n<li><strong>持续交付和部署</strong></li>\n</ul>\n<p>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成(Continuous Integration)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment)系统进行自动部署。</p>\n<ul>\n<li><strong>更轻松的迁移</strong></li>\n</ul>\n<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<ul>\n<li><strong>更轻松的维护和扩展</strong></li>\n</ul>\n<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<ul>\n<li><strong>对比传统虚拟机总结</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th align=\"center\">容器</th>\n<th align=\"center\">虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>启动</strong></td>\n<td align=\"center\">秒级</td>\n<td align=\"center\">分钟级</td>\n</tr>\n<tr>\n<td><strong>硬盘使用</strong></td>\n<td align=\"center\">一般为MB</td>\n<td align=\"center\">一般为GB</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td align=\"center\">接近原生</td>\n<td align=\"center\">弱于</td>\n</tr>\n<tr>\n<td><strong>系统支持量</strong></td>\n<td align=\"center\">单机支持上千个容器</td>\n<td align=\"center\">一般几十个</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-Docker的几个基本概念\"><a href=\"#2-Docker的几个基本概念\" class=\"headerlink\" title=\"2. Docker的几个基本概念\"></a>2. Docker的几个基本概念</h1><h2 id=\"2-1-Docker镜像-image\"><a href=\"#2-1-Docker镜像-image\" class=\"headerlink\" title=\"2.1 Docker镜像(image)\"></a>2.1 Docker镜像(image)</h2><p>我们都知道，<strong>操作系统分为内核和用户空间</strong>。对于Linux而言，内核启动后，会挂载文件系统为其提供用户空间支持。而Docker镜像(Image)，就相当于是一个文件系统。比如官方镜像ubuntu:14.04就包含了完整的一套Ubuntu14.04最小系统的root文件系统。</p>\n<p>因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时，就充分利用UnionFS的技术，将其设计为<strong>分层存储的架构</strong>。所以严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说是由多层文件系统联合组成。</p>\n<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>\n<p><strong>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</strong></p>\n<h2 id=\"2-2-Docker容器-container\"><a href=\"#2-2-Docker容器-container\" class=\"headerlink\" title=\"2.2 Docker容器(container)\"></a>2.2 Docker容器(container)</h2><p>镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p><strong>容器的实质是进程，但是与直接在宿主机上执行的进程不同，容器进程运行于属于自己的独立的<em>命名空间</em></strong>。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p>\n<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>\n<p>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(Volume)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>\n<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p>\n<h2 id=\"2-3-Docker仓库-registry\"><a href=\"#2-3-Docker仓库-registry\" class=\"headerlink\" title=\"2.3 Docker仓库(registry)\"></a>2.3 Docker仓库(registry)</h2><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p>\n<p>下面以Ubuntu镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如:14.04,16.04。 我们可以通过ubuntu:14.04或者ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，那将视为ubuntu:latest。</p>\n<h3 id=\"2-3-1-公有仓库\"><a href=\"#2-3-1-公有仓库\" class=\"headerlink\" title=\"2.3.1 公有仓库\"></a>2.3.1 公有仓库</h3><p>最常使用的公有仓库是DockerHub，这也是默认的仓库，拥有大量的官方镜像。还有还有CoreOS的Quay.io，Google的Google Container Registry，Kubernetes 的镜像使用的就是Google的服务。</p>\n<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对Docker Hub的镜像服务(Registry Mirror)，这些镜像服务被称为加速器。常见的有:阿里云加速器、DaoCloud加速器、灵雀云加速器等。</p>\n<h3 id=\"2-3-2-私有仓库\"><a href=\"#2-3-2-私有仓库\" class=\"headerlink\" title=\"2.3.2 私有仓库\"></a>2.3.2 私有仓库</h3><p>用户还可以在本地搭建私有Docker Registry。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><h2 id=\"1-1-什么是Docker？\"><a href=\"#1-1-什么是Docker？\" class=\"headerlink\" title=\"1.1 什么是Docker？\"></a>1.1 什么是Docker？</h2><p>Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及 AUFS类的UnionFS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为<strong>容器</strong>。</p>","more":"<p>Docker在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker技术比虚拟机技术更为轻便、快捷。<br>传统虚拟机技术是虚拟 出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程;而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>\n<h2 id=\"1-2-为什么要使用docker？\"><a href=\"#1-2-为什么要使用docker？\" class=\"headerlink\" title=\"1.2 为什么要使用docker？\"></a>1.2 为什么要使用docker？</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>\n<ul>\n<li><strong>更高效的利用系统资源</strong></li>\n</ul>\n<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>\n<ul>\n<li><strong>更快速的启动时间</strong></li>\n</ul>\n<p>传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。</p>\n<ul>\n<li><strong>一致的运行环境</strong></li>\n</ul>\n<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。</p>\n<ul>\n<li><strong>持续交付和部署</strong></li>\n</ul>\n<p>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合持续集成(Continuous Integration)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment)系统进行自动部署。</p>\n<ul>\n<li><strong>更轻松的迁移</strong></li>\n</ul>\n<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>\n<ul>\n<li><strong>更轻松的维护和扩展</strong></li>\n</ul>\n<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>\n<ul>\n<li><strong>对比传统虚拟机总结</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th align=\"center\">容器</th>\n<th align=\"center\">虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>启动</strong></td>\n<td align=\"center\">秒级</td>\n<td align=\"center\">分钟级</td>\n</tr>\n<tr>\n<td><strong>硬盘使用</strong></td>\n<td align=\"center\">一般为MB</td>\n<td align=\"center\">一般为GB</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td align=\"center\">接近原生</td>\n<td align=\"center\">弱于</td>\n</tr>\n<tr>\n<td><strong>系统支持量</strong></td>\n<td align=\"center\">单机支持上千个容器</td>\n<td align=\"center\">一般几十个</td>\n</tr>\n</tbody></table>\n<h1 id=\"2-Docker的几个基本概念\"><a href=\"#2-Docker的几个基本概念\" class=\"headerlink\" title=\"2. Docker的几个基本概念\"></a>2. Docker的几个基本概念</h1><h2 id=\"2-1-Docker镜像-image\"><a href=\"#2-1-Docker镜像-image\" class=\"headerlink\" title=\"2.1 Docker镜像(image)\"></a>2.1 Docker镜像(image)</h2><p>我们都知道，<strong>操作系统分为内核和用户空间</strong>。对于Linux而言，内核启动后，会挂载文件系统为其提供用户空间支持。而Docker镜像(Image)，就相当于是一个文件系统。比如官方镜像ubuntu:14.04就包含了完整的一套Ubuntu14.04最小系统的root文件系统。</p>\n<p>因为镜像包含操作系统完整的root文件系统，其体积往往是庞大的，因此在Docker设计时，就充分利用UnionFS的技术，将其设计为<strong>分层存储的架构</strong>。所以严格来说，镜像并非是像一个ISO那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说是由多层文件系统联合组成。</p>\n<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>\n<p><strong>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</strong></p>\n<h2 id=\"2-2-Docker容器-container\"><a href=\"#2-2-Docker容器-container\" class=\"headerlink\" title=\"2.2 Docker容器(container)\"></a>2.2 Docker容器(container)</h2><p>镜像(image)和容器(container)的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>\n<p><strong>容器的实质是进程，但是与直接在宿主机上执行的进程不同，容器进程运行于属于自己的独立的<em>命名空间</em></strong>。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，甚至自己的用户ID空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p>\n<p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>\n<p>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷(Volume)、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。</p>\n<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p>\n<h2 id=\"2-3-Docker仓库-registry\"><a href=\"#2-3-Docker仓库-registry\" class=\"headerlink\" title=\"2.3 Docker仓库(registry)\"></a>2.3 Docker仓库(registry)</h2><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p>\n<p>下面以Ubuntu镜像为例，ubuntu是仓库的名字，其内包含有不同的版本标签，如:14.04,16.04。 我们可以通过ubuntu:14.04或者ubuntu:16.04来具体指定所需哪个版本的镜像。如果忽略了标签，那将视为ubuntu:latest。</p>\n<h3 id=\"2-3-1-公有仓库\"><a href=\"#2-3-1-公有仓库\" class=\"headerlink\" title=\"2.3.1 公有仓库\"></a>2.3.1 公有仓库</h3><p>最常使用的公有仓库是DockerHub，这也是默认的仓库，拥有大量的官方镜像。还有还有CoreOS的Quay.io，Google的Google Container Registry，Kubernetes 的镜像使用的就是Google的服务。</p>\n<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对Docker Hub的镜像服务(Registry Mirror)，这些镜像服务被称为加速器。常见的有:阿里云加速器、DaoCloud加速器、灵雀云加速器等。</p>\n<h3 id=\"2-3-2-私有仓库\"><a href=\"#2-3-2-私有仓库\" class=\"headerlink\" title=\"2.3.2 私有仓库\"></a>2.3.2 私有仓库</h3><p>用户还可以在本地搭建私有Docker Registry。Docker官方提供了Docker Registry镜像，可以直接使用做为私有Registry服务。</p>"},{"title":"Docker搭建ES和kibana环境","date":"2019-07-05T02:46:00.000Z","top":7,"_content":"# 1.前言\n现在elasticsearch是比较火的，很多公司都在用，所以如果说还不知道es可能就会被人鄙视了。所以这里我就下决心来学习es，我比较钟爱于docker所有也就使用了docker来安装es，这里会详细介绍下安装的细节以及需要注意的地方。这里我使用的电脑是MacBook Pro 如果是linux的话其实基本相同，如果是Windows的话，可能就不太一样了，这里我也没有实际操作过，感兴趣的也可以自己去尝试一下。\n<!-- more -->\n# 2.es安装\n## 2.1 docker安装es\n要使用es肯定是需要安装的，由于用惯了docker，所以也想在docker上尝试一下，主要是因为我的好多软件都以及选择了docker。docker安装其实是很简单的，至于要一行命令即可。这里我选择的是es的7.2.0版本镜像镜像安装，具体安装命令如下:\n```bash\n$ docker pull elasticsearch:7.2.0\n```\n敲完命令以后回车，只需要等带镜像下载完成就可以了。\n\n## 2.2 启动es\n安装完成以后当然需要去启动我们的es了，这里启动也是很方便的只需要一行命令即可。如下:\n```bash\n$ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -d elasticsearch:7.2.0\n```\n这样es就启动好了。我们可以去检查es是否安装完成，可以输入命令：\n```bash\n$ curl http://localhost:9200\n```\n或者在浏览器中打开[http://localhost:9200](http://localhost:9200)这个网址，如果能看到以下信息则说明我们的es是已经安装好了的。\n```bash\n{\n  \"name\" : \"530dd7820315\",\n  \"cluster_name\" : \"docker-cluster\",\n  \"cluster_uuid\" : \"7O0fjpBJTkmn_axwmZX0RQ\",\n  \"version\" : {\n    \"number\" : \"7.2.0\",\n    \"build_flavor\" : \"default\",\n    \"build_type\" : \"docker\",\n    \"build_hash\" : \"508c38a\",\n    \"build_date\" : \"2019-06-20T15:54:18.811730Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"8.0.0\",\n    \"minimum_wire_compatibility_version\" : \"6.8.0\",\n    \"minimum_index_compatibility_version\" : \"6.0.0-beta1\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n如果你是在服务器上安装，想要对外访问还必须打开你服务器的9200端口，然后将localhost换成你服务器的ip地址即可。\n\n## 2.3 修改配置，解决跨域访问问题\n首先进入到容器中，然后进入到指定目录修改`elasticsearch.yml`文件。\n```bash\n$ docker exec -it elasticsearch /bin/bash\n$ cd /usr/share/elasticsearch/config/\n$ vi elasticsearch.yml\n```\n\n在elasticsearch.yml的文件末尾加上:\n```bash\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n```\n\n修改配置后重启容器即可。\n```bash\n$ docker restart elasticsearch\n```\n\n## 2.4 安装ik分词器\nes自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入到plugins目录中下载分词器，下载完成后然后解压，再重启es即可。具体步骤如下:\n**注意：**elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启的时候会失败。可以在这查看所有版本，选择合适自己版本的右键复制链接地址即可。[点击这里](https://github.com/medcl/elasticsearch-analysis-ik/releases)\n```bash\n$ cd /usr/share/elasticsearch/plugins/\n$ elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zip\n$ exit\n$ docker restart elasticsearch \n```\n然后可以在kibana界面的`dev tools`中验证是否安装成功；\n```bash\nPOST test/_analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"你好我是东邪Jiafly\"\n}\n```\n不添加`\"analyzer\": \"ik_max_word\",`则是每个字分词，可以在下面kibana安装完成以后尝试一下。\n\n# 3.kibana安装\n## 3.1 docker安装kibana\n同样适用docker安装kibana命令如下:\n```bash\n$ docker pull kibana:7.2.0\n```\n等待所有镜像下载完成即可。\n\n## 3.2 启动kibana\n安装完成以后需要启动kibana容器，使用`--link`连接到elasticsearch容器，命令如下:\n```bash\n$ docker run --name kibana --link=elasticsearch:test  -p 5601:5601 -d kibana:7.2.0\n$ docker start kibana\n```\n启动以后可以打开浏览器输入[http://localhost:5601](http://localhost:5601)就可以打开kibana的界面了。\n\n# 4.结语\n经过以上步骤就安装好了es和kibana，是不是很简单？这就是docker的好用处之一，也是我比较钟爱docker的原因之一。当然docker远不止这些功能，更多的我们以后慢慢写到，总之肯定是都能用上的。哈哈\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。\n\n\n\n\n","source":"_posts/docker/Docker-搭建es和kibana环境.md","raw":"---\ntitle: Docker搭建ES和kibana环境\ndate: 2019-07-05 10:46:00\ntags:\n    - es\n    - docker\ncategories:\n    - docker\ntop: 7\n---\n# 1.前言\n现在elasticsearch是比较火的，很多公司都在用，所以如果说还不知道es可能就会被人鄙视了。所以这里我就下决心来学习es，我比较钟爱于docker所有也就使用了docker来安装es，这里会详细介绍下安装的细节以及需要注意的地方。这里我使用的电脑是MacBook Pro 如果是linux的话其实基本相同，如果是Windows的话，可能就不太一样了，这里我也没有实际操作过，感兴趣的也可以自己去尝试一下。\n<!-- more -->\n# 2.es安装\n## 2.1 docker安装es\n要使用es肯定是需要安装的，由于用惯了docker，所以也想在docker上尝试一下，主要是因为我的好多软件都以及选择了docker。docker安装其实是很简单的，至于要一行命令即可。这里我选择的是es的7.2.0版本镜像镜像安装，具体安装命令如下:\n```bash\n$ docker pull elasticsearch:7.2.0\n```\n敲完命令以后回车，只需要等带镜像下载完成就可以了。\n\n## 2.2 启动es\n安装完成以后当然需要去启动我们的es了，这里启动也是很方便的只需要一行命令即可。如下:\n```bash\n$ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -d elasticsearch:7.2.0\n```\n这样es就启动好了。我们可以去检查es是否安装完成，可以输入命令：\n```bash\n$ curl http://localhost:9200\n```\n或者在浏览器中打开[http://localhost:9200](http://localhost:9200)这个网址，如果能看到以下信息则说明我们的es是已经安装好了的。\n```bash\n{\n  \"name\" : \"530dd7820315\",\n  \"cluster_name\" : \"docker-cluster\",\n  \"cluster_uuid\" : \"7O0fjpBJTkmn_axwmZX0RQ\",\n  \"version\" : {\n    \"number\" : \"7.2.0\",\n    \"build_flavor\" : \"default\",\n    \"build_type\" : \"docker\",\n    \"build_hash\" : \"508c38a\",\n    \"build_date\" : \"2019-06-20T15:54:18.811730Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"8.0.0\",\n    \"minimum_wire_compatibility_version\" : \"6.8.0\",\n    \"minimum_index_compatibility_version\" : \"6.0.0-beta1\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n```\n如果你是在服务器上安装，想要对外访问还必须打开你服务器的9200端口，然后将localhost换成你服务器的ip地址即可。\n\n## 2.3 修改配置，解决跨域访问问题\n首先进入到容器中，然后进入到指定目录修改`elasticsearch.yml`文件。\n```bash\n$ docker exec -it elasticsearch /bin/bash\n$ cd /usr/share/elasticsearch/config/\n$ vi elasticsearch.yml\n```\n\n在elasticsearch.yml的文件末尾加上:\n```bash\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n```\n\n修改配置后重启容器即可。\n```bash\n$ docker restart elasticsearch\n```\n\n## 2.4 安装ik分词器\nes自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入到plugins目录中下载分词器，下载完成后然后解压，再重启es即可。具体步骤如下:\n**注意：**elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启的时候会失败。可以在这查看所有版本，选择合适自己版本的右键复制链接地址即可。[点击这里](https://github.com/medcl/elasticsearch-analysis-ik/releases)\n```bash\n$ cd /usr/share/elasticsearch/plugins/\n$ elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zip\n$ exit\n$ docker restart elasticsearch \n```\n然后可以在kibana界面的`dev tools`中验证是否安装成功；\n```bash\nPOST test/_analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"你好我是东邪Jiafly\"\n}\n```\n不添加`\"analyzer\": \"ik_max_word\",`则是每个字分词，可以在下面kibana安装完成以后尝试一下。\n\n# 3.kibana安装\n## 3.1 docker安装kibana\n同样适用docker安装kibana命令如下:\n```bash\n$ docker pull kibana:7.2.0\n```\n等待所有镜像下载完成即可。\n\n## 3.2 启动kibana\n安装完成以后需要启动kibana容器，使用`--link`连接到elasticsearch容器，命令如下:\n```bash\n$ docker run --name kibana --link=elasticsearch:test  -p 5601:5601 -d kibana:7.2.0\n$ docker start kibana\n```\n启动以后可以打开浏览器输入[http://localhost:5601](http://localhost:5601)就可以打开kibana的界面了。\n\n# 4.结语\n经过以上步骤就安装好了es和kibana，是不是很简单？这就是docker的好用处之一，也是我比较钟爱docker的原因之一。当然docker远不止这些功能，更多的我们以后慢慢写到，总之肯定是都能用上的。哈哈\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。\n\n\n\n\n","slug":"docker/Docker-搭建es和kibana环境","published":1,"updated":"2019-11-26T05:53:54.376Z","_id":"ck38agcok000ejfus5amwcovt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>现在elasticsearch是比较火的，很多公司都在用，所以如果说还不知道es可能就会被人鄙视了。所以这里我就下决心来学习es，我比较钟爱于docker所有也就使用了docker来安装es，这里会详细介绍下安装的细节以及需要注意的地方。这里我使用的电脑是MacBook Pro 如果是linux的话其实基本相同，如果是Windows的话，可能就不太一样了，这里我也没有实际操作过，感兴趣的也可以自己去尝试一下。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-es安装\"><a href=\"#2-es安装\" class=\"headerlink\" title=\"2.es安装\"></a>2.es安装</h1><h2 id=\"2-1-docker安装es\"><a href=\"#2-1-docker安装es\" class=\"headerlink\" title=\"2.1 docker安装es\"></a>2.1 docker安装es</h2><p>要使用es肯定是需要安装的，由于用惯了docker，所以也想在docker上尝试一下，主要是因为我的好多软件都以及选择了docker。docker安装其实是很简单的，至于要一行命令即可。这里我选择的是es的7.2.0版本镜像镜像安装，具体安装命令如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull elasticsearch:7.2.0</span><br></pre></td></tr></table></figure>\n<p>敲完命令以后回车，只需要等带镜像下载完成就可以了。</p>\n<h2 id=\"2-2-启动es\"><a href=\"#2-2-启动es\" class=\"headerlink\" title=\"2.2 启动es\"></a>2.2 启动es</h2><p>安装完成以后当然需要去启动我们的es了，这里启动也是很方便的只需要一行命令即可。如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class=\"string\">\"discovery.type=single-node\"</span> -d elasticsearch:7.2.0</span><br></pre></td></tr></table></figure>\n<p>这样es就启动好了。我们可以去检查es是否安装完成，可以输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http://localhost:9200</span><br></pre></td></tr></table></figure>\n<p>或者在浏览器中打开<a href=\"http://localhost:9200\" target=\"_blank\" rel=\"noopener\">http://localhost:9200</a>这个网址，如果能看到以下信息则说明我们的es是已经安装好了的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span> : <span class=\"string\">\"530dd7820315\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_name\"</span> : <span class=\"string\">\"docker-cluster\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_uuid\"</span> : <span class=\"string\">\"7O0fjpBJTkmn_axwmZX0RQ\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"number\"</span> : <span class=\"string\">\"7.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_flavor\"</span> : <span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_type\"</span> : <span class=\"string\">\"docker\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_hash\"</span> : <span class=\"string\">\"508c38a\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_date\"</span> : <span class=\"string\">\"2019-06-20T15:54:18.811730Z\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_snapshot\"</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">\"lucene_version\"</span> : <span class=\"string\">\"8.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"minimum_wire_compatibility_version\"</span> : <span class=\"string\">\"6.8.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"minimum_index_compatibility_version\"</span> : <span class=\"string\">\"6.0.0-beta1\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"tagline\"</span> : <span class=\"string\">\"You Know, for Search\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你是在服务器上安装，想要对外访问还必须打开你服务器的9200端口，然后将localhost换成你服务器的ip地址即可。</p>\n<h2 id=\"2-3-修改配置，解决跨域访问问题\"><a href=\"#2-3-修改配置，解决跨域访问问题\" class=\"headerlink\" title=\"2.3 修改配置，解决跨域访问问题\"></a>2.3 修改配置，解决跨域访问问题</h2><p>首先进入到容器中，然后进入到指定目录修改<code>elasticsearch.yml</code>文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it elasticsearch /bin/bash</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/share/elasticsearch/config/</span><br><span class=\"line\">$ vi elasticsearch.yml</span><br></pre></td></tr></table></figure>\n\n<p>在elasticsearch.yml的文件末尾加上:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.cors.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">http.cors.allow-origin: <span class=\"string\">\"*\"</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置后重启容器即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker restart elasticsearch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-安装ik分词器\"><a href=\"#2-4-安装ik分词器\" class=\"headerlink\" title=\"2.4 安装ik分词器\"></a>2.4 安装ik分词器</h2><p>es自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入到plugins目录中下载分词器，下载完成后然后解压，再重启es即可。具体步骤如下:<br><strong>注意：</strong>elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启的时候会失败。可以在这查看所有版本，选择合适自己版本的右键复制链接地址即可。<a href=\"https://github.com/medcl/elasticsearch-analysis-ik/releases\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/share/elasticsearch/plugins/</span><br><span class=\"line\">$ elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zip</span><br><span class=\"line\">$ <span class=\"built_in\">exit</span></span><br><span class=\"line\">$ docker restart elasticsearch</span><br></pre></td></tr></table></figure>\n<p>然后可以在kibana界面的<code>dev tools</code>中验证是否安装成功；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST <span class=\"built_in\">test</span>/_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"ik_max_word\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"text\"</span>: <span class=\"string\">\"你好我是东邪Jiafly\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不添加<code>&quot;analyzer&quot;: &quot;ik_max_word&quot;,</code>则是每个字分词，可以在下面kibana安装完成以后尝试一下。</p>\n<h1 id=\"3-kibana安装\"><a href=\"#3-kibana安装\" class=\"headerlink\" title=\"3.kibana安装\"></a>3.kibana安装</h1><h2 id=\"3-1-docker安装kibana\"><a href=\"#3-1-docker安装kibana\" class=\"headerlink\" title=\"3.1 docker安装kibana\"></a>3.1 docker安装kibana</h2><p>同样适用docker安装kibana命令如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull kibana:7.2.0</span><br></pre></td></tr></table></figure>\n<p>等待所有镜像下载完成即可。</p>\n<h2 id=\"3-2-启动kibana\"><a href=\"#3-2-启动kibana\" class=\"headerlink\" title=\"3.2 启动kibana\"></a>3.2 启动kibana</h2><p>安装完成以后需要启动kibana容器，使用<code>--link</code>连接到elasticsearch容器，命令如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name kibana --link=elasticsearch:<span class=\"built_in\">test</span>  -p 5601:5601 -d kibana:7.2.0</span><br><span class=\"line\">$ docker start kibana</span><br></pre></td></tr></table></figure>\n<p>启动以后可以打开浏览器输入<a href=\"http://localhost:5601\" target=\"_blank\" rel=\"noopener\">http://localhost:5601</a>就可以打开kibana的界面了。</p>\n<h1 id=\"4-结语\"><a href=\"#4-结语\" class=\"headerlink\" title=\"4.结语\"></a>4.结语</h1><p>经过以上步骤就安装好了es和kibana，是不是很简单？这就是docker的好用处之一，也是我比较钟爱docker的原因之一。当然docker远不止这些功能，更多的我们以后慢慢写到，总之肯定是都能用上的。哈哈</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>现在elasticsearch是比较火的，很多公司都在用，所以如果说还不知道es可能就会被人鄙视了。所以这里我就下决心来学习es，我比较钟爱于docker所有也就使用了docker来安装es，这里会详细介绍下安装的细节以及需要注意的地方。这里我使用的电脑是MacBook Pro 如果是linux的话其实基本相同，如果是Windows的话，可能就不太一样了，这里我也没有实际操作过，感兴趣的也可以自己去尝试一下。</p>","more":"<h1 id=\"2-es安装\"><a href=\"#2-es安装\" class=\"headerlink\" title=\"2.es安装\"></a>2.es安装</h1><h2 id=\"2-1-docker安装es\"><a href=\"#2-1-docker安装es\" class=\"headerlink\" title=\"2.1 docker安装es\"></a>2.1 docker安装es</h2><p>要使用es肯定是需要安装的，由于用惯了docker，所以也想在docker上尝试一下，主要是因为我的好多软件都以及选择了docker。docker安装其实是很简单的，至于要一行命令即可。这里我选择的是es的7.2.0版本镜像镜像安装，具体安装命令如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull elasticsearch:7.2.0</span><br></pre></td></tr></table></figure>\n<p>敲完命令以后回车，只需要等带镜像下载完成就可以了。</p>\n<h2 id=\"2-2-启动es\"><a href=\"#2-2-启动es\" class=\"headerlink\" title=\"2.2 启动es\"></a>2.2 启动es</h2><p>安装完成以后当然需要去启动我们的es了，这里启动也是很方便的只需要一行命令即可。如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 -e <span class=\"string\">\"discovery.type=single-node\"</span> -d elasticsearch:7.2.0</span><br></pre></td></tr></table></figure>\n<p>这样es就启动好了。我们可以去检查es是否安装完成，可以输入命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http://localhost:9200</span><br></pre></td></tr></table></figure>\n<p>或者在浏览器中打开<a href=\"http://localhost:9200\" target=\"_blank\" rel=\"noopener\">http://localhost:9200</a>这个网址，如果能看到以下信息则说明我们的es是已经安装好了的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span> : <span class=\"string\">\"530dd7820315\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_name\"</span> : <span class=\"string\">\"docker-cluster\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"cluster_uuid\"</span> : <span class=\"string\">\"7O0fjpBJTkmn_axwmZX0RQ\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span> : &#123;</span><br><span class=\"line\">    <span class=\"string\">\"number\"</span> : <span class=\"string\">\"7.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_flavor\"</span> : <span class=\"string\">\"default\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_type\"</span> : <span class=\"string\">\"docker\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_hash\"</span> : <span class=\"string\">\"508c38a\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_date\"</span> : <span class=\"string\">\"2019-06-20T15:54:18.811730Z\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"build_snapshot\"</span> : <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"string\">\"lucene_version\"</span> : <span class=\"string\">\"8.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"minimum_wire_compatibility_version\"</span> : <span class=\"string\">\"6.8.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"minimum_index_compatibility_version\"</span> : <span class=\"string\">\"6.0.0-beta1\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"tagline\"</span> : <span class=\"string\">\"You Know, for Search\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你是在服务器上安装，想要对外访问还必须打开你服务器的9200端口，然后将localhost换成你服务器的ip地址即可。</p>\n<h2 id=\"2-3-修改配置，解决跨域访问问题\"><a href=\"#2-3-修改配置，解决跨域访问问题\" class=\"headerlink\" title=\"2.3 修改配置，解决跨域访问问题\"></a>2.3 修改配置，解决跨域访问问题</h2><p>首先进入到容器中，然后进入到指定目录修改<code>elasticsearch.yml</code>文件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker <span class=\"built_in\">exec</span> -it elasticsearch /bin/bash</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/share/elasticsearch/config/</span><br><span class=\"line\">$ vi elasticsearch.yml</span><br></pre></td></tr></table></figure>\n\n<p>在elasticsearch.yml的文件末尾加上:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.cors.enabled: <span class=\"literal\">true</span></span><br><span class=\"line\">http.cors.allow-origin: <span class=\"string\">\"*\"</span></span><br></pre></td></tr></table></figure>\n\n<p>修改配置后重启容器即可。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker restart elasticsearch</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-安装ik分词器\"><a href=\"#2-4-安装ik分词器\" class=\"headerlink\" title=\"2.4 安装ik分词器\"></a>2.4 安装ik分词器</h2><p>es自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入到plugins目录中下载分词器，下载完成后然后解压，再重启es即可。具体步骤如下:<br><strong>注意：</strong>elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启的时候会失败。可以在这查看所有版本，选择合适自己版本的右键复制链接地址即可。<a href=\"https://github.com/medcl/elasticsearch-analysis-ik/releases\" target=\"_blank\" rel=\"noopener\">点击这里</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/share/elasticsearch/plugins/</span><br><span class=\"line\">$ elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zip</span><br><span class=\"line\">$ <span class=\"built_in\">exit</span></span><br><span class=\"line\">$ docker restart elasticsearch</span><br></pre></td></tr></table></figure>\n<p>然后可以在kibana界面的<code>dev tools</code>中验证是否安装成功；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST <span class=\"built_in\">test</span>/_analyze</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"analyzer\"</span>: <span class=\"string\">\"ik_max_word\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"text\"</span>: <span class=\"string\">\"你好我是东邪Jiafly\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不添加<code>&quot;analyzer&quot;: &quot;ik_max_word&quot;,</code>则是每个字分词，可以在下面kibana安装完成以后尝试一下。</p>\n<h1 id=\"3-kibana安装\"><a href=\"#3-kibana安装\" class=\"headerlink\" title=\"3.kibana安装\"></a>3.kibana安装</h1><h2 id=\"3-1-docker安装kibana\"><a href=\"#3-1-docker安装kibana\" class=\"headerlink\" title=\"3.1 docker安装kibana\"></a>3.1 docker安装kibana</h2><p>同样适用docker安装kibana命令如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull kibana:7.2.0</span><br></pre></td></tr></table></figure>\n<p>等待所有镜像下载完成即可。</p>\n<h2 id=\"3-2-启动kibana\"><a href=\"#3-2-启动kibana\" class=\"headerlink\" title=\"3.2 启动kibana\"></a>3.2 启动kibana</h2><p>安装完成以后需要启动kibana容器，使用<code>--link</code>连接到elasticsearch容器，命令如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name kibana --link=elasticsearch:<span class=\"built_in\">test</span>  -p 5601:5601 -d kibana:7.2.0</span><br><span class=\"line\">$ docker start kibana</span><br></pre></td></tr></table></figure>\n<p>启动以后可以打开浏览器输入<a href=\"http://localhost:5601\" target=\"_blank\" rel=\"noopener\">http://localhost:5601</a>就可以打开kibana的界面了。</p>\n<h1 id=\"4-结语\"><a href=\"#4-结语\" class=\"headerlink\" title=\"4.结语\"></a>4.结语</h1><p>经过以上步骤就安装好了es和kibana，是不是很简单？这就是docker的好用处之一，也是我比较钟爱docker的原因之一。当然docker远不止这些功能，更多的我们以后慢慢写到，总之肯定是都能用上的。哈哈</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>"},{"title":"使用Orika实现Java Bean映射","date":"2019-05-29T04:00:00.000Z","notshow":true,"_content":"\nOrika是Java Bean映射框架，可以实现从一个对象递归拷贝数据至另一个对象。这样我们可以将数据在实体，DTO，VO之间切换。关于Bean映射，其实BeanUtil中的copyProperties()方法也可以实现，但是如果名字相同类型不同的的是不能直接复制的，而orika却可以解决这个问题。\n<!-- more -->\n# 1.引入orika的jar包\n现在用的大部分都是使用的maven文件，可以在pom.xml文件中引入下列配置即可。\n```xml\n<dependency>\n    <groupId>ma.glasnost.orika</groupId>\n    <artifactId>orika-core</artifactId>\n    <version>1.5.4</version>\n</dependency>\n```\n\n# 2.创建映射工具类\n之前创建没有使用单例，造成了内存溢出的情况，后来采用单例的模式，解决了这个问题。\n\n```java\npackage com.jiafly.libra.common.utils;\n\nimport ma.glasnost.orika.MapperFacade;\nimport ma.glasnost.orika.MapperFactory;\nimport ma.glasnost.orika.impl.DefaultMapperFactory;\nimport ma.glasnost.orika.metadata.ClassMapBuilder;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 映射工具类\n *\n * @author 东邪Jiafly\n */\npublic enum MapperUtils {\n\n    /**\n     * 实例\n     */\n    INSTANCE;\n\n    /**\n     * 默认字段工厂\n     */\n    private static final MapperFactory MAPPER_FACTORY = new DefaultMapperFactory.Builder().build();\n\n    /**\n     * 默认字段实例\n     */\n    private static final MapperFacade MAPPER_FACADE = MAPPER_FACTORY.getMapperFacade();\n\n    /**\n     * 默认字段实例集合\n     */\n    private static Map<String, MapperFacade> CACHE_MAPPER_FACADE_MAP = new ConcurrentHashMap<>();\n\n    /**\n     * 映射实体（默认字段）\n     *\n     * @param toClass 映射类对象\n     * @param data    数据（对象）\n     * @return 映射类对象\n     */\n    public <E, T> E map(Class<E> toClass, T data) {\n        return MAPPER_FACADE.map(data, toClass);\n    }\n\n    /**\n     * 映射实体（自定义配置）\n     *\n     * @param toClass   映射类对象\n     * @param data      数据（对象）\n     * @param configMap 自定义配置\n     * @return 映射类对象\n     */\n    public <E, T> E map(Class<E> toClass, T data, Map<String, String> configMap) {\n        MapperFacade mapperFacade = this.getMapperFacade(toClass, data.getClass(), configMap);\n        return mapperFacade.map(data, toClass);\n    }\n\n    /**\n     * 映射集合（默认字段）\n     *\n     * @param toClass 映射类对象\n     * @param data    数据（集合）\n     * @return 映射类对象\n     */\n    public <E, T> List<E> mapAsList(Class<E> toClass, Collection<T> data) {\n        return MAPPER_FACADE.mapAsList(data, toClass);\n    }\n\n\n    /**\n     * 映射集合（自定义配置）\n     *\n     * @param toClass   映射类\n     * @param data      数据（集合）\n     * @param configMap 自定义配置\n     * @return 映射类对象\n     */\n    public <E, T> List<E> mapAsList(Class<E> toClass, Collection<T> data, Map<String, String> configMap) {\n        T t = data.stream().findFirst().orElseThrow(() -> new ResourceNotExistException(\"映射集合，数据集合为空\"));\n        MapperFacade mapperFacade = this.getMapperFacade(toClass, t.getClass(), configMap);\n        return mapperFacade.mapAsList(data, toClass);\n    }\n\n    /**\n     * 获取自定义映射\n     *\n     * @param toClass   映射类\n     * @param dataClass 数据映射类\n     * @param configMap 自定义配置\n     * @return 映射类对象\n     */\n    private <E, T> MapperFacade getMapperFacade(Class<E> toClass, Class<T> dataClass, Map<String, String> configMap) {\n        String mapKey = dataClass.getCanonicalName() + \"_\" + toClass.getCanonicalName();\n        MapperFacade mapperFacade = CACHE_MAPPER_FACADE_MAP.get(mapKey);\n        if (Objects.isNull(mapperFacade)) {\n            MapperFactory factory = new DefaultMapperFactory.Builder().build();\n            ClassMapBuilder classMapBuilder = factory.classMap(dataClass, toClass);\n            configMap.forEach(classMapBuilder::field);\n            classMapBuilder.byDefault().register();\n            mapperFacade = factory.getMapperFacade();\n            CACHE_MAPPER_FACADE_MAP.put(mapKey, mapperFacade);\n        }\n        return mapperFacade;\n    }\n}\n```\n\n# 3.使用映射工具类\n这个工具列中主要有四个方法来根据不同需求去映射对象。\n- **map(Class<E> toClass, T data)**\n这个是普通的映射实体，主要映射命名相同的默认字段。\n\n- **map(Class<E> toClass, T data, Map<String, String> configMap)**\n这是个自定义配置的映射集合，当name\n- **mapAsList(Class<E> toClass, Collection<T> data)**\n这个是针对集合的映射\n- **mapAsList(Class<E> toClass, Collection<T> data, Map<String, String> configMap)**\n这是针对集合配置并且自定义配置\n\n# 4.结语\n这篇主要是针对使用Orika的使用写了一个工具类，以方便我们在需要的时候直接使用，当然如果想对Orika有一些更高级的使用，可以继续阅读Orika的源码，分析它具体的实现原理。\n\n\n","source":"_posts/java/使用Orika实现Java Bean映射.md","raw":"---\ntitle: 使用Orika实现Java Bean映射\ndate: 2019-05-29 12:00:00\ntags: \n    - Bean映射\n    - Orika\n    - Java\ncategories: \n    - java\nnotshow: true\n---\n\nOrika是Java Bean映射框架，可以实现从一个对象递归拷贝数据至另一个对象。这样我们可以将数据在实体，DTO，VO之间切换。关于Bean映射，其实BeanUtil中的copyProperties()方法也可以实现，但是如果名字相同类型不同的的是不能直接复制的，而orika却可以解决这个问题。\n<!-- more -->\n# 1.引入orika的jar包\n现在用的大部分都是使用的maven文件，可以在pom.xml文件中引入下列配置即可。\n```xml\n<dependency>\n    <groupId>ma.glasnost.orika</groupId>\n    <artifactId>orika-core</artifactId>\n    <version>1.5.4</version>\n</dependency>\n```\n\n# 2.创建映射工具类\n之前创建没有使用单例，造成了内存溢出的情况，后来采用单例的模式，解决了这个问题。\n\n```java\npackage com.jiafly.libra.common.utils;\n\nimport ma.glasnost.orika.MapperFacade;\nimport ma.glasnost.orika.MapperFactory;\nimport ma.glasnost.orika.impl.DefaultMapperFactory;\nimport ma.glasnost.orika.metadata.ClassMapBuilder;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * 映射工具类\n *\n * @author 东邪Jiafly\n */\npublic enum MapperUtils {\n\n    /**\n     * 实例\n     */\n    INSTANCE;\n\n    /**\n     * 默认字段工厂\n     */\n    private static final MapperFactory MAPPER_FACTORY = new DefaultMapperFactory.Builder().build();\n\n    /**\n     * 默认字段实例\n     */\n    private static final MapperFacade MAPPER_FACADE = MAPPER_FACTORY.getMapperFacade();\n\n    /**\n     * 默认字段实例集合\n     */\n    private static Map<String, MapperFacade> CACHE_MAPPER_FACADE_MAP = new ConcurrentHashMap<>();\n\n    /**\n     * 映射实体（默认字段）\n     *\n     * @param toClass 映射类对象\n     * @param data    数据（对象）\n     * @return 映射类对象\n     */\n    public <E, T> E map(Class<E> toClass, T data) {\n        return MAPPER_FACADE.map(data, toClass);\n    }\n\n    /**\n     * 映射实体（自定义配置）\n     *\n     * @param toClass   映射类对象\n     * @param data      数据（对象）\n     * @param configMap 自定义配置\n     * @return 映射类对象\n     */\n    public <E, T> E map(Class<E> toClass, T data, Map<String, String> configMap) {\n        MapperFacade mapperFacade = this.getMapperFacade(toClass, data.getClass(), configMap);\n        return mapperFacade.map(data, toClass);\n    }\n\n    /**\n     * 映射集合（默认字段）\n     *\n     * @param toClass 映射类对象\n     * @param data    数据（集合）\n     * @return 映射类对象\n     */\n    public <E, T> List<E> mapAsList(Class<E> toClass, Collection<T> data) {\n        return MAPPER_FACADE.mapAsList(data, toClass);\n    }\n\n\n    /**\n     * 映射集合（自定义配置）\n     *\n     * @param toClass   映射类\n     * @param data      数据（集合）\n     * @param configMap 自定义配置\n     * @return 映射类对象\n     */\n    public <E, T> List<E> mapAsList(Class<E> toClass, Collection<T> data, Map<String, String> configMap) {\n        T t = data.stream().findFirst().orElseThrow(() -> new ResourceNotExistException(\"映射集合，数据集合为空\"));\n        MapperFacade mapperFacade = this.getMapperFacade(toClass, t.getClass(), configMap);\n        return mapperFacade.mapAsList(data, toClass);\n    }\n\n    /**\n     * 获取自定义映射\n     *\n     * @param toClass   映射类\n     * @param dataClass 数据映射类\n     * @param configMap 自定义配置\n     * @return 映射类对象\n     */\n    private <E, T> MapperFacade getMapperFacade(Class<E> toClass, Class<T> dataClass, Map<String, String> configMap) {\n        String mapKey = dataClass.getCanonicalName() + \"_\" + toClass.getCanonicalName();\n        MapperFacade mapperFacade = CACHE_MAPPER_FACADE_MAP.get(mapKey);\n        if (Objects.isNull(mapperFacade)) {\n            MapperFactory factory = new DefaultMapperFactory.Builder().build();\n            ClassMapBuilder classMapBuilder = factory.classMap(dataClass, toClass);\n            configMap.forEach(classMapBuilder::field);\n            classMapBuilder.byDefault().register();\n            mapperFacade = factory.getMapperFacade();\n            CACHE_MAPPER_FACADE_MAP.put(mapKey, mapperFacade);\n        }\n        return mapperFacade;\n    }\n}\n```\n\n# 3.使用映射工具类\n这个工具列中主要有四个方法来根据不同需求去映射对象。\n- **map(Class<E> toClass, T data)**\n这个是普通的映射实体，主要映射命名相同的默认字段。\n\n- **map(Class<E> toClass, T data, Map<String, String> configMap)**\n这是个自定义配置的映射集合，当name\n- **mapAsList(Class<E> toClass, Collection<T> data)**\n这个是针对集合的映射\n- **mapAsList(Class<E> toClass, Collection<T> data, Map<String, String> configMap)**\n这是针对集合配置并且自定义配置\n\n# 4.结语\n这篇主要是针对使用Orika的使用写了一个工具类，以方便我们在需要的时候直接使用，当然如果想对Orika有一些更高级的使用，可以继续阅读Orika的源码，分析它具体的实现原理。\n\n\n","slug":"java/使用Orika实现Java Bean映射","published":1,"updated":"2019-09-05T03:26:24.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcol000fjfusdt246ukq","content":"<p>Orika是Java Bean映射框架，可以实现从一个对象递归拷贝数据至另一个对象。这样我们可以将数据在实体，DTO，VO之间切换。关于Bean映射，其实BeanUtil中的copyProperties()方法也可以实现，但是如果名字相同类型不同的的是不能直接复制的，而orika却可以解决这个问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"1-引入orika的jar包\"><a href=\"#1-引入orika的jar包\" class=\"headerlink\" title=\"1.引入orika的jar包\"></a>1.引入orika的jar包</h1><p>现在用的大部分都是使用的maven文件，可以在pom.xml文件中引入下列配置即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ma.glasnost.orika<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>orika-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-创建映射工具类\"><a href=\"#2-创建映射工具类\" class=\"headerlink\" title=\"2.创建映射工具类\"></a>2.创建映射工具类</h1><p>之前创建没有使用单例，造成了内存溢出的情况，后来采用单例的模式，解决了这个问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.libra.common.utils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.MapperFacade;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.MapperFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.impl.DefaultMapperFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.metadata.ClassMapBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 映射工具类</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> 东邪Jiafly</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> MapperUtils &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实例</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认字段工厂</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapperFactory MAPPER_FACTORY = <span class=\"keyword\">new</span> DefaultMapperFactory.Builder().build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认字段实例</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapperFacade MAPPER_FACADE = MAPPER_FACTORY.getMapperFacade();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认字段实例集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, MapperFacade&gt; CACHE_MAPPER_FACADE_MAP = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射实体（默认字段）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data    数据（对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">E <span class=\"title\">map</span><span class=\"params\">(Class&lt;E&gt; toClass, T data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MAPPER_FACADE.map(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射实体（自定义配置）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass   映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data      数据（对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configMap 自定义配置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">E <span class=\"title\">map</span><span class=\"params\">(Class&lt;E&gt; toClass, T data, Map&lt;String, String&gt; configMap)</span> </span>&#123;</span><br><span class=\"line\">        MapperFacade mapperFacade = <span class=\"keyword\">this</span>.getMapperFacade(toClass, data.getClass(), configMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperFacade.map(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射集合（默认字段）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data    数据（集合）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">mapAsList</span><span class=\"params\">(Class&lt;E&gt; toClass, Collection&lt;T&gt; data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MAPPER_FACADE.mapAsList(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射集合（自定义配置）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass   映射类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data      数据（集合）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configMap 自定义配置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">mapAsList</span><span class=\"params\">(Class&lt;E&gt; toClass, Collection&lt;T&gt; data, Map&lt;String, String&gt; configMap)</span> </span>&#123;</span><br><span class=\"line\">        T t = data.stream().findFirst().orElseThrow(() -&gt; <span class=\"keyword\">new</span> ResourceNotExistException(<span class=\"string\">\"映射集合，数据集合为空\"</span>));</span><br><span class=\"line\">        MapperFacade mapperFacade = <span class=\"keyword\">this</span>.getMapperFacade(toClass, t.getClass(), configMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperFacade.mapAsList(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取自定义映射</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass   映射类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dataClass 数据映射类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configMap 自定义配置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> &lt;E, T&gt; <span class=\"function\">MapperFacade <span class=\"title\">getMapperFacade</span><span class=\"params\">(Class&lt;E&gt; toClass, Class&lt;T&gt; dataClass, Map&lt;String, String&gt; configMap)</span> </span>&#123;</span><br><span class=\"line\">        String mapKey = dataClass.getCanonicalName() + <span class=\"string\">\"_\"</span> + toClass.getCanonicalName();</span><br><span class=\"line\">        MapperFacade mapperFacade = CACHE_MAPPER_FACADE_MAP.get(mapKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Objects.isNull(mapperFacade)) &#123;</span><br><span class=\"line\">            MapperFactory factory = <span class=\"keyword\">new</span> DefaultMapperFactory.Builder().build();</span><br><span class=\"line\">            ClassMapBuilder classMapBuilder = factory.classMap(dataClass, toClass);</span><br><span class=\"line\">            configMap.forEach(classMapBuilder::field);</span><br><span class=\"line\">            classMapBuilder.byDefault().register();</span><br><span class=\"line\">            mapperFacade = factory.getMapperFacade();</span><br><span class=\"line\">            CACHE_MAPPER_FACADE_MAP.put(mapKey, mapperFacade);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperFacade;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-使用映射工具类\"><a href=\"#3-使用映射工具类\" class=\"headerlink\" title=\"3.使用映射工具类\"></a>3.使用映射工具类</h1><p>这个工具列中主要有四个方法来根据不同需求去映射对象。</p>\n<ul>\n<li><p><strong>map(Class<E> toClass, T data)</strong><br>这个是普通的映射实体，主要映射命名相同的默认字段。</p>\n</li>\n<li><p><strong>map(Class<E> toClass, T data, Map&lt;String, String&gt; configMap)</strong><br>这是个自定义配置的映射集合，当name</p>\n</li>\n<li><p><strong>mapAsList(Class<E> toClass, Collection<T> data)</strong><br>这个是针对集合的映射</p>\n</li>\n<li><p><strong>mapAsList(Class<E> toClass, Collection<T> data, Map&lt;String, String&gt; configMap)</strong><br>这是针对集合配置并且自定义配置</p>\n</li>\n</ul>\n<h1 id=\"4-结语\"><a href=\"#4-结语\" class=\"headerlink\" title=\"4.结语\"></a>4.结语</h1><p>这篇主要是针对使用Orika的使用写了一个工具类，以方便我们在需要的时候直接使用，当然如果想对Orika有一些更高级的使用，可以继续阅读Orika的源码，分析它具体的实现原理。</p>\n","site":{"data":{}},"excerpt":"<p>Orika是Java Bean映射框架，可以实现从一个对象递归拷贝数据至另一个对象。这样我们可以将数据在实体，DTO，VO之间切换。关于Bean映射，其实BeanUtil中的copyProperties()方法也可以实现，但是如果名字相同类型不同的的是不能直接复制的，而orika却可以解决这个问题。</p>","more":"<h1 id=\"1-引入orika的jar包\"><a href=\"#1-引入orika的jar包\" class=\"headerlink\" title=\"1.引入orika的jar包\"></a>1.引入orika的jar包</h1><p>现在用的大部分都是使用的maven文件，可以在pom.xml文件中引入下列配置即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ma.glasnost.orika<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>orika-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-创建映射工具类\"><a href=\"#2-创建映射工具类\" class=\"headerlink\" title=\"2.创建映射工具类\"></a>2.创建映射工具类</h1><p>之前创建没有使用单例，造成了内存溢出的情况，后来采用单例的模式，解决了这个问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jiafly.libra.common.utils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.MapperFacade;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.MapperFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.impl.DefaultMapperFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ma.glasnost.orika.metadata.ClassMapBuilder;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 映射工具类</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> 东邪Jiafly</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> MapperUtils &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 实例</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认字段工厂</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapperFactory MAPPER_FACTORY = <span class=\"keyword\">new</span> DefaultMapperFactory.Builder().build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认字段实例</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> MapperFacade MAPPER_FACADE = MAPPER_FACTORY.getMapperFacade();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 默认字段实例集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Map&lt;String, MapperFacade&gt; CACHE_MAPPER_FACADE_MAP = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射实体（默认字段）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data    数据（对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">E <span class=\"title\">map</span><span class=\"params\">(Class&lt;E&gt; toClass, T data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MAPPER_FACADE.map(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射实体（自定义配置）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass   映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data      数据（对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configMap 自定义配置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">E <span class=\"title\">map</span><span class=\"params\">(Class&lt;E&gt; toClass, T data, Map&lt;String, String&gt; configMap)</span> </span>&#123;</span><br><span class=\"line\">        MapperFacade mapperFacade = <span class=\"keyword\">this</span>.getMapperFacade(toClass, data.getClass(), configMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperFacade.map(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射集合（默认字段）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data    数据（集合）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">mapAsList</span><span class=\"params\">(Class&lt;E&gt; toClass, Collection&lt;T&gt; data)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MAPPER_FACADE.mapAsList(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 映射集合（自定义配置）</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass   映射类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> data      数据（集合）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configMap 自定义配置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;E, T&gt; <span class=\"function\">List&lt;E&gt; <span class=\"title\">mapAsList</span><span class=\"params\">(Class&lt;E&gt; toClass, Collection&lt;T&gt; data, Map&lt;String, String&gt; configMap)</span> </span>&#123;</span><br><span class=\"line\">        T t = data.stream().findFirst().orElseThrow(() -&gt; <span class=\"keyword\">new</span> ResourceNotExistException(<span class=\"string\">\"映射集合，数据集合为空\"</span>));</span><br><span class=\"line\">        MapperFacade mapperFacade = <span class=\"keyword\">this</span>.getMapperFacade(toClass, t.getClass(), configMap);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperFacade.mapAsList(data, toClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取自定义映射</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> toClass   映射类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dataClass 数据映射类</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> configMap 自定义配置</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 映射类对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> &lt;E, T&gt; <span class=\"function\">MapperFacade <span class=\"title\">getMapperFacade</span><span class=\"params\">(Class&lt;E&gt; toClass, Class&lt;T&gt; dataClass, Map&lt;String, String&gt; configMap)</span> </span>&#123;</span><br><span class=\"line\">        String mapKey = dataClass.getCanonicalName() + <span class=\"string\">\"_\"</span> + toClass.getCanonicalName();</span><br><span class=\"line\">        MapperFacade mapperFacade = CACHE_MAPPER_FACADE_MAP.get(mapKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Objects.isNull(mapperFacade)) &#123;</span><br><span class=\"line\">            MapperFactory factory = <span class=\"keyword\">new</span> DefaultMapperFactory.Builder().build();</span><br><span class=\"line\">            ClassMapBuilder classMapBuilder = factory.classMap(dataClass, toClass);</span><br><span class=\"line\">            configMap.forEach(classMapBuilder::field);</span><br><span class=\"line\">            classMapBuilder.byDefault().register();</span><br><span class=\"line\">            mapperFacade = factory.getMapperFacade();</span><br><span class=\"line\">            CACHE_MAPPER_FACADE_MAP.put(mapKey, mapperFacade);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mapperFacade;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-使用映射工具类\"><a href=\"#3-使用映射工具类\" class=\"headerlink\" title=\"3.使用映射工具类\"></a>3.使用映射工具类</h1><p>这个工具列中主要有四个方法来根据不同需求去映射对象。</p>\n<ul>\n<li><p><strong>map(Class<E> toClass, T data)</strong><br>这个是普通的映射实体，主要映射命名相同的默认字段。</p>\n</li>\n<li><p><strong>map(Class<E> toClass, T data, Map&lt;String, String&gt; configMap)</strong><br>这是个自定义配置的映射集合，当name</p>\n</li>\n<li><p><strong>mapAsList(Class<E> toClass, Collection<T> data)</strong><br>这个是针对集合的映射</p>\n</li>\n<li><p><strong>mapAsList(Class<E> toClass, Collection<T> data, Map&lt;String, String&gt; configMap)</strong><br>这是针对集合配置并且自定义配置</p>\n</li>\n</ul>\n<h1 id=\"4-结语\"><a href=\"#4-结语\" class=\"headerlink\" title=\"4.结语\"></a>4.结语</h1><p>这篇主要是针对使用Orika的使用写了一个工具类，以方便我们在需要的时候直接使用，当然如果想对Orika有一些更高级的使用，可以继续阅读Orika的源码，分析它具体的实现原理。</p>"},{"title":"Git回滚到分支指定版本","date":"2019-07-08T06:36:00.000Z","notshow":true,"_content":"# 1.前言\n在合并代码的时候，我们会尽量保证不会出现错误，但是这种情况是不能避免的，这一次我就遇到了一个问题，在合并代码的是后将其他的将其他人的代码合并没有了，想回到合并前的某一个commit,我是借助sourcetree操作的，但是发现操作的过程其实是相当麻烦，也许是我永不习惯吧，还是用回我擅长的命令行操作。\n<!-- more -->\n# 2.操作步骤\n操作步骤其实很简单，首先获取到commit ID 然后回滚到这个版本，最后提交到远程分支，仅此三步，用命令还是很简单的。\n- 获取commit ID\n```bash\n$ git log\n```\n通过上面的命令可以获取到commit ID，通过`空格键`翻页，如果想退出直接按键盘`q`键即可。\n\n\n- 回滚到知道的版本\n```bash\n$ git reset --hard <commit ID号>\n```\n尖括号中的就是上面查询到的ID，例如: `git reset --hard af3b5661f84da994dc29790ce838ebec5e6c5f0e`\n\n- 提交到远程分支\n```bash\n$ git push -f origin <branch name>\n```\n尖括号中填写要推倒的远程分支名即可，例如：`git push -f origin develop`\n\n# 3.结语\n会滚到指定的分支这个操作其实在很多情况下还是需要的，所以知道如何操作还会大量节省我们再去查阅相关资料的时间。\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。","source":"_posts/git/Git回滚到分支指定版本.md","raw":"---\ntitle: Git回滚到分支指定版本\ndate: 2019-07-08 14:36:00\ntags:\n    - Git\ncategories:\n    - Git\nnotshow: true\n---\n# 1.前言\n在合并代码的时候，我们会尽量保证不会出现错误，但是这种情况是不能避免的，这一次我就遇到了一个问题，在合并代码的是后将其他的将其他人的代码合并没有了，想回到合并前的某一个commit,我是借助sourcetree操作的，但是发现操作的过程其实是相当麻烦，也许是我永不习惯吧，还是用回我擅长的命令行操作。\n<!-- more -->\n# 2.操作步骤\n操作步骤其实很简单，首先获取到commit ID 然后回滚到这个版本，最后提交到远程分支，仅此三步，用命令还是很简单的。\n- 获取commit ID\n```bash\n$ git log\n```\n通过上面的命令可以获取到commit ID，通过`空格键`翻页，如果想退出直接按键盘`q`键即可。\n\n\n- 回滚到知道的版本\n```bash\n$ git reset --hard <commit ID号>\n```\n尖括号中的就是上面查询到的ID，例如: `git reset --hard af3b5661f84da994dc29790ce838ebec5e6c5f0e`\n\n- 提交到远程分支\n```bash\n$ git push -f origin <branch name>\n```\n尖括号中填写要推倒的远程分支名即可，例如：`git push -f origin develop`\n\n# 3.结语\n会滚到指定的分支这个操作其实在很多情况下还是需要的，所以知道如何操作还会大量节省我们再去查阅相关资料的时间。\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。","slug":"git/Git回滚到分支指定版本","published":1,"updated":"2019-09-05T03:26:23.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcom000gjfus7d836ndl","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>在合并代码的时候，我们会尽量保证不会出现错误，但是这种情况是不能避免的，这一次我就遇到了一个问题，在合并代码的是后将其他的将其他人的代码合并没有了，想回到合并前的某一个commit,我是借助sourcetree操作的，但是发现操作的过程其实是相当麻烦，也许是我永不习惯吧，还是用回我擅长的命令行操作。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-操作步骤\"><a href=\"#2-操作步骤\" class=\"headerlink\" title=\"2.操作步骤\"></a>2.操作步骤</h1><p>操作步骤其实很简单，首先获取到commit ID 然后回滚到这个版本，最后提交到远程分支，仅此三步，用命令还是很简单的。</p>\n<ul>\n<li>获取commit ID<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n通过上面的命令可以获取到commit ID，通过<code>空格键</code>翻页，如果想退出直接按键盘<code>q</code>键即可。</li>\n</ul>\n<ul>\n<li><p>回滚到知道的版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard &lt;commit ID号&gt;</span><br></pre></td></tr></table></figure>\n<p>尖括号中的就是上面查询到的ID，例如: <code>git reset --hard af3b5661f84da994dc29790ce838ebec5e6c5f0e</code></p>\n</li>\n<li><p>提交到远程分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -f origin &lt;branch name&gt;</span><br></pre></td></tr></table></figure>\n<p>尖括号中填写要推倒的远程分支名即可，例如：<code>git push -f origin develop</code></p>\n</li>\n</ul>\n<h1 id=\"3-结语\"><a href=\"#3-结语\" class=\"headerlink\" title=\"3.结语\"></a>3.结语</h1><p>会滚到指定的分支这个操作其实在很多情况下还是需要的，所以知道如何操作还会大量节省我们再去查阅相关资料的时间。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>在合并代码的时候，我们会尽量保证不会出现错误，但是这种情况是不能避免的，这一次我就遇到了一个问题，在合并代码的是后将其他的将其他人的代码合并没有了，想回到合并前的某一个commit,我是借助sourcetree操作的，但是发现操作的过程其实是相当麻烦，也许是我永不习惯吧，还是用回我擅长的命令行操作。</p>","more":"<h1 id=\"2-操作步骤\"><a href=\"#2-操作步骤\" class=\"headerlink\" title=\"2.操作步骤\"></a>2.操作步骤</h1><p>操作步骤其实很简单，首先获取到commit ID 然后回滚到这个版本，最后提交到远程分支，仅此三步，用命令还是很简单的。</p>\n<ul>\n<li>获取commit ID<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">log</span></span><br></pre></td></tr></table></figure>\n通过上面的命令可以获取到commit ID，通过<code>空格键</code>翻页，如果想退出直接按键盘<code>q</code>键即可。</li>\n</ul>\n<ul>\n<li><p>回滚到知道的版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard &lt;commit ID号&gt;</span><br></pre></td></tr></table></figure>\n<p>尖括号中的就是上面查询到的ID，例如: <code>git reset --hard af3b5661f84da994dc29790ce838ebec5e6c5f0e</code></p>\n</li>\n<li><p>提交到远程分支</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -f origin &lt;branch name&gt;</span><br></pre></td></tr></table></figure>\n<p>尖括号中填写要推倒的远程分支名即可，例如：<code>git push -f origin develop</code></p>\n</li>\n</ul>\n<h1 id=\"3-结语\"><a href=\"#3-结语\" class=\"headerlink\" title=\"3.结语\"></a>3.结语</h1><p>会滚到指定的分支这个操作其实在很多情况下还是需要的，所以知道如何操作还会大量节省我们再去查阅相关资料的时间。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>"},{"title":"Docker-创建mysql容器","date":"2019-03-10T09:45:22.000Z","top":9,"_content":"# 1. 前言\n我们在工作中会有需要在本机安装mysql，但是独立去安装mysql会耗费很大的内存以及磁盘空间，如果是在自己的电脑上时间久了可能会使电脑越来越卡。但是如果我们在电脑上安装了docker那就不一样了，或者我们购买了云主机，我们可以在主机上自己安装mysql，但是普通的按住步骤太繁琐，而且一般只能启用一个mysql，这时候Docker就站出来啦。\n个人比较推荐使用docker，因为真的是太好用了，好用到爱不释手。嘻嘻~。我们不仅可以使用docker还可以安装很多实用的工具，你可以到dockerHub上去查找你需要的镜像。\n<!-- more -->\n# 2. 准备工作\n## 2.1 安装Docker\n无论你是Windows还是Mac还是Linux，现在网上都有很多安装教程，你可以根据步骤进行安装，这里我们就当Docker已经安装完啦。\n## 2.2 拉取mysql的镜像(这里使用mysql5.7)\n```bash\n$ docker pull mysql:5.7\n```\n\n## 2.3 启动mysql\n当我们从镜像仓库拉完mysql以后，本地或者服务器上就已经有了mysql的镜像，我们可以通过命令去查看\n```bash\n$ docker images \n```\n这个命令就列出了当前主机上已经下载的所有镜像。\n## 2.4 在宿主机上创建数据存储文件夹\n个人比较推荐使用docker安装镜像之后对于数据要有规律的去保存，这样也方便以后删除镜像的时候能够轻易的找到数据一起删除。所有在这里我所有使用docker安装的镜像都会在/data/docker目录下，docker目录中暗中镜像再进行分类。\n例如：这里我要使用docker启动一个mysql的容器 容器名称为mysql001，这样我就创建如下目录\n```bash\n$ mkdir /data/docker/mysql/mysql001\n```\n### 2.5 创建容器\n```bash\n$ docker run --name mysql001 -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql/mysql001:/var/lib/mysql -d mysql:5.7 \n```\n\n这里我们对上面的命令进行拆解，清楚的了解每一步都是在做什么操作。\n- docker run \n这是启动一个容器\n- --name mysql001 \n启动的容器名称为mysql001，这个名称在后面操作可直接使用名称\n- -p 3306:3306\n映射端口，前面一个端口是宿主机的端口，后面一个端口是mysql的端口，我们访问数据库是通过访问宿主机去访问，所以使用的是前面一个端口\n- -e MYSQL_ROOT_PASSWORD=root\n设置mysql的登录密码为root\n- -v /etc/localtime:/etc/localtime\n这个是这是启动容器的时区和宿主机一致，这个设置比较有用，不然会出现数据库中的时间比当前时间晚8小时\n- -v /data/docker/mysql/mysql001:/var/lib/mysql\n这个就是用刚刚创建的目录去存储mysql的数据了，我们在mysql中的所有数据都会存储在宿主器前面的目录里\n- -d mysql:5.7\n-d是开启Daemon模式即保护进程的方式运行。最后的这个是知道启动容器的版本 如果没有的话默认就是latest 和前面pull镜像时一样\n\n### 启动容器\n执行完上面的命令后容器并没有启动，我们可以通过执行以下命令去启动容器\n```bash\n$ docker start mysql001\n```\n或者将name修改为image_id，image_id可以通过 docker images命令去查看。\n\n## 访问mysql数据库\n- 方式一\n```bash\n$ mysql-cli -h 127.0.0.1 -u root -p root\n```\n- 方式二\n使用mysql客户端如：mysqlworkbatch，navicat等客户端软件。\n\n### 删除容器\n删除容器必须要保证容器是stop的可以通过下面的命令查看\n- 查看正在运行的容器\n```bash\n$ docker ps \n```\n- 查看所有运行过的容器包括正在运行的容器\n```bash\n$ docker ps -a\n```\n根据上面的命令可以查找到容器id，执行命令删除容器\n```bash\n$ docker rm 容器id\n```\n\n\n","source":"_posts/docker/Docker-创建mysql容器.md","raw":"---\ntitle: Docker-创建mysql容器\ndate: 2019-03-10 17:45:22\ntags: \n    - docker\n    - mysql\ncategories: \n    - docker\ntop: 9\n---\n# 1. 前言\n我们在工作中会有需要在本机安装mysql，但是独立去安装mysql会耗费很大的内存以及磁盘空间，如果是在自己的电脑上时间久了可能会使电脑越来越卡。但是如果我们在电脑上安装了docker那就不一样了，或者我们购买了云主机，我们可以在主机上自己安装mysql，但是普通的按住步骤太繁琐，而且一般只能启用一个mysql，这时候Docker就站出来啦。\n个人比较推荐使用docker，因为真的是太好用了，好用到爱不释手。嘻嘻~。我们不仅可以使用docker还可以安装很多实用的工具，你可以到dockerHub上去查找你需要的镜像。\n<!-- more -->\n# 2. 准备工作\n## 2.1 安装Docker\n无论你是Windows还是Mac还是Linux，现在网上都有很多安装教程，你可以根据步骤进行安装，这里我们就当Docker已经安装完啦。\n## 2.2 拉取mysql的镜像(这里使用mysql5.7)\n```bash\n$ docker pull mysql:5.7\n```\n\n## 2.3 启动mysql\n当我们从镜像仓库拉完mysql以后，本地或者服务器上就已经有了mysql的镜像，我们可以通过命令去查看\n```bash\n$ docker images \n```\n这个命令就列出了当前主机上已经下载的所有镜像。\n## 2.4 在宿主机上创建数据存储文件夹\n个人比较推荐使用docker安装镜像之后对于数据要有规律的去保存，这样也方便以后删除镜像的时候能够轻易的找到数据一起删除。所有在这里我所有使用docker安装的镜像都会在/data/docker目录下，docker目录中暗中镜像再进行分类。\n例如：这里我要使用docker启动一个mysql的容器 容器名称为mysql001，这样我就创建如下目录\n```bash\n$ mkdir /data/docker/mysql/mysql001\n```\n### 2.5 创建容器\n```bash\n$ docker run --name mysql001 -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql/mysql001:/var/lib/mysql -d mysql:5.7 \n```\n\n这里我们对上面的命令进行拆解，清楚的了解每一步都是在做什么操作。\n- docker run \n这是启动一个容器\n- --name mysql001 \n启动的容器名称为mysql001，这个名称在后面操作可直接使用名称\n- -p 3306:3306\n映射端口，前面一个端口是宿主机的端口，后面一个端口是mysql的端口，我们访问数据库是通过访问宿主机去访问，所以使用的是前面一个端口\n- -e MYSQL_ROOT_PASSWORD=root\n设置mysql的登录密码为root\n- -v /etc/localtime:/etc/localtime\n这个是这是启动容器的时区和宿主机一致，这个设置比较有用，不然会出现数据库中的时间比当前时间晚8小时\n- -v /data/docker/mysql/mysql001:/var/lib/mysql\n这个就是用刚刚创建的目录去存储mysql的数据了，我们在mysql中的所有数据都会存储在宿主器前面的目录里\n- -d mysql:5.7\n-d是开启Daemon模式即保护进程的方式运行。最后的这个是知道启动容器的版本 如果没有的话默认就是latest 和前面pull镜像时一样\n\n### 启动容器\n执行完上面的命令后容器并没有启动，我们可以通过执行以下命令去启动容器\n```bash\n$ docker start mysql001\n```\n或者将name修改为image_id，image_id可以通过 docker images命令去查看。\n\n## 访问mysql数据库\n- 方式一\n```bash\n$ mysql-cli -h 127.0.0.1 -u root -p root\n```\n- 方式二\n使用mysql客户端如：mysqlworkbatch，navicat等客户端软件。\n\n### 删除容器\n删除容器必须要保证容器是stop的可以通过下面的命令查看\n- 查看正在运行的容器\n```bash\n$ docker ps \n```\n- 查看所有运行过的容器包括正在运行的容器\n```bash\n$ docker ps -a\n```\n根据上面的命令可以查找到容器id，执行命令删除容器\n```bash\n$ docker rm 容器id\n```\n\n\n","slug":"docker/Docker-创建mysql容器","published":1,"updated":"2019-11-26T05:53:54.342Z","_id":"ck38agcop000kjfus8zev1ek8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>我们在工作中会有需要在本机安装mysql，但是独立去安装mysql会耗费很大的内存以及磁盘空间，如果是在自己的电脑上时间久了可能会使电脑越来越卡。但是如果我们在电脑上安装了docker那就不一样了，或者我们购买了云主机，我们可以在主机上自己安装mysql，但是普通的按住步骤太繁琐，而且一般只能启用一个mysql，这时候Docker就站出来啦。<br>个人比较推荐使用docker，因为真的是太好用了，好用到爱不释手。嘻嘻~。我们不仅可以使用docker还可以安装很多实用的工具，你可以到dockerHub上去查找你需要的镜像。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-准备工作\"><a href=\"#2-准备工作\" class=\"headerlink\" title=\"2. 准备工作\"></a>2. 准备工作</h1><h2 id=\"2-1-安装Docker\"><a href=\"#2-1-安装Docker\" class=\"headerlink\" title=\"2.1 安装Docker\"></a>2.1 安装Docker</h2><p>无论你是Windows还是Mac还是Linux，现在网上都有很多安装教程，你可以根据步骤进行安装，这里我们就当Docker已经安装完啦。</p>\n<h2 id=\"2-2-拉取mysql的镜像-这里使用mysql5-7\"><a href=\"#2-2-拉取mysql的镜像-这里使用mysql5-7\" class=\"headerlink\" title=\"2.2 拉取mysql的镜像(这里使用mysql5.7)\"></a>2.2 拉取mysql的镜像(这里使用mysql5.7)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-启动mysql\"><a href=\"#2-3-启动mysql\" class=\"headerlink\" title=\"2.3 启动mysql\"></a>2.3 启动mysql</h2><p>当我们从镜像仓库拉完mysql以后，本地或者服务器上就已经有了mysql的镜像，我们可以通过命令去查看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker images</span><br></pre></td></tr></table></figure>\n<p>这个命令就列出了当前主机上已经下载的所有镜像。</p>\n<h2 id=\"2-4-在宿主机上创建数据存储文件夹\"><a href=\"#2-4-在宿主机上创建数据存储文件夹\" class=\"headerlink\" title=\"2.4 在宿主机上创建数据存储文件夹\"></a>2.4 在宿主机上创建数据存储文件夹</h2><p>个人比较推荐使用docker安装镜像之后对于数据要有规律的去保存，这样也方便以后删除镜像的时候能够轻易的找到数据一起删除。所有在这里我所有使用docker安装的镜像都会在/data/docker目录下，docker目录中暗中镜像再进行分类。<br>例如：这里我要使用docker启动一个mysql的容器 容器名称为mysql001，这样我就创建如下目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir /data/docker/mysql/mysql001</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-创建容器\"><a href=\"#2-5-创建容器\" class=\"headerlink\" title=\"2.5 创建容器\"></a>2.5 创建容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mysql001 -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql/mysql001:/var/lib/mysql -d mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<p>这里我们对上面的命令进行拆解，清楚的了解每一步都是在做什么操作。</p>\n<ul>\n<li>docker run<br>这是启动一个容器</li>\n<li>–name mysql001<br>启动的容器名称为mysql001，这个名称在后面操作可直接使用名称</li>\n<li>-p 3306:3306<br>映射端口，前面一个端口是宿主机的端口，后面一个端口是mysql的端口，我们访问数据库是通过访问宿主机去访问，所以使用的是前面一个端口</li>\n<li>-e MYSQL_ROOT_PASSWORD=root<br>设置mysql的登录密码为root</li>\n<li>-v /etc/localtime:/etc/localtime<br>这个是这是启动容器的时区和宿主机一致，这个设置比较有用，不然会出现数据库中的时间比当前时间晚8小时</li>\n<li>-v /data/docker/mysql/mysql001:/var/lib/mysql<br>这个就是用刚刚创建的目录去存储mysql的数据了，我们在mysql中的所有数据都会存储在宿主器前面的目录里</li>\n<li>-d mysql:5.7</li>\n<li>d是开启Daemon模式即保护进程的方式运行。最后的这个是知道启动容器的版本 如果没有的话默认就是latest 和前面pull镜像时一样</li>\n</ul>\n<h3 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h3><p>执行完上面的命令后容器并没有启动，我们可以通过执行以下命令去启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start mysql001</span><br></pre></td></tr></table></figure>\n<p>或者将name修改为image_id，image_id可以通过 docker images命令去查看。</p>\n<h2 id=\"访问mysql数据库\"><a href=\"#访问mysql数据库\" class=\"headerlink\" title=\"访问mysql数据库\"></a>访问mysql数据库</h2><ul>\n<li>方式一<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mysql-cli -h 127.0.0.1 -u root -p root</span><br></pre></td></tr></table></figure></li>\n<li>方式二<br>使用mysql客户端如：mysqlworkbatch，navicat等客户端软件。</li>\n</ul>\n<h3 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h3><p>删除容器必须要保证容器是stop的可以通过下面的命令查看</p>\n<ul>\n<li>查看正在运行的容器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker ps</span><br></pre></td></tr></table></figure></li>\n<li>查看所有运行过的容器包括正在运行的容器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker ps -a</span><br></pre></td></tr></table></figure>\n根据上面的命令可以查找到容器id，执行命令删除容器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker rm 容器id</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h1><p>我们在工作中会有需要在本机安装mysql，但是独立去安装mysql会耗费很大的内存以及磁盘空间，如果是在自己的电脑上时间久了可能会使电脑越来越卡。但是如果我们在电脑上安装了docker那就不一样了，或者我们购买了云主机，我们可以在主机上自己安装mysql，但是普通的按住步骤太繁琐，而且一般只能启用一个mysql，这时候Docker就站出来啦。<br>个人比较推荐使用docker，因为真的是太好用了，好用到爱不释手。嘻嘻~。我们不仅可以使用docker还可以安装很多实用的工具，你可以到dockerHub上去查找你需要的镜像。</p>","more":"<h1 id=\"2-准备工作\"><a href=\"#2-准备工作\" class=\"headerlink\" title=\"2. 准备工作\"></a>2. 准备工作</h1><h2 id=\"2-1-安装Docker\"><a href=\"#2-1-安装Docker\" class=\"headerlink\" title=\"2.1 安装Docker\"></a>2.1 安装Docker</h2><p>无论你是Windows还是Mac还是Linux，现在网上都有很多安装教程，你可以根据步骤进行安装，这里我们就当Docker已经安装完啦。</p>\n<h2 id=\"2-2-拉取mysql的镜像-这里使用mysql5-7\"><a href=\"#2-2-拉取mysql的镜像-这里使用mysql5-7\" class=\"headerlink\" title=\"2.2 拉取mysql的镜像(这里使用mysql5.7)\"></a>2.2 拉取mysql的镜像(这里使用mysql5.7)</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-启动mysql\"><a href=\"#2-3-启动mysql\" class=\"headerlink\" title=\"2.3 启动mysql\"></a>2.3 启动mysql</h2><p>当我们从镜像仓库拉完mysql以后，本地或者服务器上就已经有了mysql的镜像，我们可以通过命令去查看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker images</span><br></pre></td></tr></table></figure>\n<p>这个命令就列出了当前主机上已经下载的所有镜像。</p>\n<h2 id=\"2-4-在宿主机上创建数据存储文件夹\"><a href=\"#2-4-在宿主机上创建数据存储文件夹\" class=\"headerlink\" title=\"2.4 在宿主机上创建数据存储文件夹\"></a>2.4 在宿主机上创建数据存储文件夹</h2><p>个人比较推荐使用docker安装镜像之后对于数据要有规律的去保存，这样也方便以后删除镜像的时候能够轻易的找到数据一起删除。所有在这里我所有使用docker安装的镜像都会在/data/docker目录下，docker目录中暗中镜像再进行分类。<br>例如：这里我要使用docker启动一个mysql的容器 容器名称为mysql001，这样我就创建如下目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir /data/docker/mysql/mysql001</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-创建容器\"><a href=\"#2-5-创建容器\" class=\"headerlink\" title=\"2.5 创建容器\"></a>2.5 创建容器</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker run --name mysql001 -p 3306:3306  -e MYSQL_ROOT_PASSWORD=root -v /etc/localtime:/etc/localtime  -v /data/docker/mysql/mysql001:/var/lib/mysql -d mysql:5.7</span><br></pre></td></tr></table></figure>\n\n<p>这里我们对上面的命令进行拆解，清楚的了解每一步都是在做什么操作。</p>\n<ul>\n<li>docker run<br>这是启动一个容器</li>\n<li>–name mysql001<br>启动的容器名称为mysql001，这个名称在后面操作可直接使用名称</li>\n<li>-p 3306:3306<br>映射端口，前面一个端口是宿主机的端口，后面一个端口是mysql的端口，我们访问数据库是通过访问宿主机去访问，所以使用的是前面一个端口</li>\n<li>-e MYSQL_ROOT_PASSWORD=root<br>设置mysql的登录密码为root</li>\n<li>-v /etc/localtime:/etc/localtime<br>这个是这是启动容器的时区和宿主机一致，这个设置比较有用，不然会出现数据库中的时间比当前时间晚8小时</li>\n<li>-v /data/docker/mysql/mysql001:/var/lib/mysql<br>这个就是用刚刚创建的目录去存储mysql的数据了，我们在mysql中的所有数据都会存储在宿主器前面的目录里</li>\n<li>-d mysql:5.7</li>\n<li>d是开启Daemon模式即保护进程的方式运行。最后的这个是知道启动容器的版本 如果没有的话默认就是latest 和前面pull镜像时一样</li>\n</ul>\n<h3 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h3><p>执行完上面的命令后容器并没有启动，我们可以通过执行以下命令去启动容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker start mysql001</span><br></pre></td></tr></table></figure>\n<p>或者将name修改为image_id，image_id可以通过 docker images命令去查看。</p>\n<h2 id=\"访问mysql数据库\"><a href=\"#访问mysql数据库\" class=\"headerlink\" title=\"访问mysql数据库\"></a>访问mysql数据库</h2><ul>\n<li>方式一<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mysql-cli -h 127.0.0.1 -u root -p root</span><br></pre></td></tr></table></figure></li>\n<li>方式二<br>使用mysql客户端如：mysqlworkbatch，navicat等客户端软件。</li>\n</ul>\n<h3 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h3><p>删除容器必须要保证容器是stop的可以通过下面的命令查看</p>\n<ul>\n<li>查看正在运行的容器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker ps</span><br></pre></td></tr></table></figure></li>\n<li>查看所有运行过的容器包括正在运行的容器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker ps -a</span><br></pre></td></tr></table></figure>\n根据上面的命令可以查找到容器id，执行命令删除容器<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker rm 容器id</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>"},{"title":"Java8-Stream中的常用操作","date":"2019-05-16T14:23:11.000Z","notshow":true,"_content":"# 1.前言\nJava8提供了很多新特性，其中有一个就是基于流Stream的操作。Stream是一组用来处理数组，集合的API\n## 1.1 特性\n<!-- more -->\n- 不是数据结构，没有内部存储。\n- 不支持索引访问。\n- 延迟计算\n- 支持并行\n- 很容易生成数据或集合\n- 支持过滤，查找，转换，汇总，聚合等操作\n\n\n## 1.2 运行机制\nStream分为源source，中间操作，终止操作。\n- 流的源可以是一个数组，集合，生成器方法，I/O通道等等。\n- 一个流可以有零个或多个中间操作，每一个中间操作都会返回一个新的流，供下一个操作使用，一个流只会有一个终止操作。\n- Stream只有遇到终止操作，它的源才会开始执行遍历操作。\n\n## 1.3 Stream的创建\n`Stream`的创建其实有很多方式，但是我们在平时用到最多的可能就是基于数组的Stream.of()和集合的stream()方法其实它还有很多种的创建方式，下面将一一列出，并且列举相关实例。\n- 1.通过数组,Stream.of()\n- 2.通过集合\n- 3.通过Stream.generate方法来创建\n- 4.通过Stram.iterate方法\n- 5.其他API\n```java \npublic class CreateStream {\n    // 1.通过数组,Stream.of()\n    static void create1(){\n        String[] str = {\"a\",\"b\",\"c\"};\n        Stream<String> str1 = Stream.of(str);\n    }\n    // 2.通过集合\n    static void create2(){\n        List<String> strings = Arrays.asList(\"a\", \"b\", \"c\");\n        Stream<String> stream = strings.stream();\n    }\n    // 3.通过Stream.generate方法来创建\n    static void create3(){\n        //这是一个无限流，通过这种方法创建在操作的时候最好加上limit进行限制\n        Stream<Integer> generate = Stream.generate(() -> 1);\n        generate.limit(10).forEach(x -> System.out.println(x));\n    } \n    // 4.通过Stram.iterate方法\n    static void create4(){\n        Stream<Integer> iterate = Stream.iterate(1, x -> x +1);\n        iterate.forEach(x -> System.out.println(x));\n    }\n    // 5.其他API\n    static void create5(){\n        String str = \"abc\";\n        IntStream chars = str.chars();\n        chars.forEach(x -> System.out.println(x));\n    }\n}\n```\n\n# 2.Stream的常用操作(API)\n## 2.1 中间操作\n### 2.1.1 filter过滤\n接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。说白了就是给一个条件，filter会根据这个条件截取流中得数据。\n```java\npublic static void testFilter(){\n    List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    //截取所有能被2整除得数据\n    List<Integer> collect = integers.stream().filter(i -> i % 2 == 0).collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [2, 4, 6, 8, 10]\n```\n\n### 2.1.2 distinct去重\n返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。\n```java\npublic static void main(String[] args) {\n    List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);\n    List<Integer> collect = numbers.stream().distinct().collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [1, 2, 3, 4]\n```\n\n### 2.1.3 sorted排序\n对流中得数据进行排序，可以以自然序或着用Comparator接口定义的排序规则来排序一个流。Comparator能使用lambada表达式来初始化，还能够逆序一个已经排序的流。\n```java\npublic static void main(String[] args) {\n    List<Integer> integers = Arrays.asList(5, 8, 2, 6, 41, 11);\n    //排序默认为顺序  顺序 = [2, 5, 6, 8, 11, 41]\n    List<Integer> sorted = integers.stream().sorted().collect(Collectors.toList());\n    System.out.println(\"顺序 = \" + sorted);\n    //逆序    逆序 = [41, 11, 8, 6, 5, 2]\n    List<Integer> reverseOrder = integers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());\n    System.out.println(\"逆序 = \" + reverseOrder);\n    //也可以接收一个lambda\n    List<Integer> ages = integers.stream().sorted(Comparator.comparing(User::getAge)).collect(Collectors.toList());\n}\n```\n\n### 2.1.4 limit截取\n会返回一个不超过给定长度的流。\n```java\npublic static void testLimit(){\n    List<Integer> integers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);\n    List<Integer> collect = integers.stream().limit(3).collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [1, 2, 1]\n```\n\n### 2.1.5 skip舍弃\n会返回一个扔掉了前面n个元素的流。如果流中元素不足n个，则返回一个空流。\n```java\npublic static void testSkip(){\n    List<Integer> integers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);\n    //丢掉流中得前三个元素  \n    List<Integer> collect = integers.stream().skip(3).collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [3, 3, 2, 4]\n```\n\n### 2.1.6 map归纳\n接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素。就是根据指定函数获取流中得每个元素得数据并重新组合成一个新的元素。\n```java\npublic static void main(String[] args) {\n    //自己建好得一个获取对象list得方法\n    List<Dish> dishList = Dish.getDishList();\n    //获取每一道菜得名称  并放到一个list中\n    List<String> collect = dishList.stream().map(Dish::getName).collect(Collectors.toList());\n    //collect = [pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon]\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.1.7 flatMap扁平化\n该方法key可以让你把一个流中的每个值都换成另一个流，然后把所有的流都链接起来成为一个流。\n```java\npublic static void main(String[] args) {\n    String[] words = {\"Hello\", \"World\"};\n    List<String> collect = Stream.of(words).        //数组转换流\n            map(w -> w.split(\"\")).  //去掉“”并获取到两个String[]\n            flatMap(Arrays::stream).        //方法调用将两个String[]扁平化为一个stream\n            distinct().                     //去重    \n            collect(Collectors.toList());\n    //collect = [H, e, l, o, W, r, d]\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.1.8 peek\npeek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。\n```java\npublic static void main(String[] args) {\n    List<Integer> numbers = Arrays.asList(2, 3, 4, 5);\n    List<Integer> result =\n            numbers.stream()\n                    .peek(x -> System.out.println(\"from stream: \" + x))\n                    .map(x -> x + 17)\n                    .peek(x -> System.out.println(\"after map: \" + x))\n                    .filter(x -> x % 2 == 0)\n                    .peek(x -> System.out.println(\"after filter: \" + x))\n                    .limit(3)\n                    .peek(x -> System.out.println(\"after limit: \" + x))\n                    .collect(Collectors.toList());\n}\n// 结果：\n//     from stream: 2\n//     after map: 19\n//     from stream: 3\n//     after map: 20\n//     after filter: 20\n//     after limit: 20\n//     from stream: 4\n//     after map: 21\n//     from stream: 5\n//     after map: 22\n//     after filter: 22\n//     after limit: 22\n\n```\n\n### 2.1.9 collect收集\n从上面得代码已经可以看出来，collect是将最终stream中得数据收集起来，最终生成一个list，set，或者map。\n```java\npublic static void main(String[] args) {\n    List<Dish> dishList = Dish.getDishList();\n    // list\n    List<Dish> collect = dishList.stream().limit(2).collect(Collectors.toList());\n    // set\n    Set<Dish> collect1 = dishList.stream().limit(2).collect(Collectors.toSet());\n    // map\n    Map<String, Dish.Type> collect2 = dishList.stream().limit(2).collect(Collectors.toMap(Dish::getName, Dish::getType));\n}\n\n```\n\n## 2.2 终止操作\n- 循环 forEach\n- 计算 min、max、count、average\n- 匹配 anyMatch、allMatch、noneMatch、findFirst、findAny\n- 汇聚 reduce\n- 收集器 collect\n\n## 2.3 查找和匹配\n常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch，anyMatch，noneMatch，findFirst和findAny方法提供了这样的工具。\n查找和匹配都是终端操作。\n\n### 2.3.1 anyMatch\nanyMatch方法可以回答“流中是否有一个元素能匹配到给定的谓词”。会返回一个boolean值。\n```java\npublic class AnyMatch {\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        boolean b = dish.stream().anyMatch(Dish::isVegetarian);\n        System.out.println(b);\n    }\n}\n```\n\n### 2.3.2 allMatch\nallMatch方法和anyMatch类似，校验流中是否都能匹配到给定的谓词。\n```java\nclass AllMatch{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        //是否所有菜的热量都小于1000\n        boolean b = dish.stream().allMatch(d -> d.getCalories() < 1000);\n        System.out.println(b);\n    }\n}\n```\n\n### 2.3.3 noneMatch\nnoneMatch方法可以确保流中没有任何元素与给定的谓词匹配。\n```java\nclass NoneMatch{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        //没有任何菜的热量大于等于1000\n        boolean b = dish.stream().allMatch(d -> d.getCalories() >= 1000);\n        System.out.println(b);\n    }\n}\n```\n`anyMatch`，`noneMatch`，`allMatch`这三个操作都用到了所谓的短路。\n\n### 2.3.4 findAny\nfindAny方法将返回当前流中的符合过滤条件的任意元素。\n```java\nclass FindAny{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        Optional<Dish> any = dish.stream().filter(Dish::isVegetarian).findAny();\n        System.out.println(\"any = \" + any);\n    }\n}\n```\n\n### 2.3.5 findFirst\nfindFirst方法能找到你想要的第一个元素。\n```java\nclass FindFirst{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        Optional<Dish> any = dish.stream().filter(Dish::isVegetarian).findFirst();\n        System.out.println(\"any = \" + any);\n    }\n}\n```\n## 2.4 reduce 归约\n此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个 Integer 。这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操\n作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。\n### 2.4.1 元素求和\n```java\npublic static void main(String[] args) {\n    List<Integer> integers = Arrays.asList(1, 2, 3, 6, 8);\n    //求list中的和，以0为基数\n    Integer reduce = integers.stream().reduce(0, (a, b) -> a + b);\n    //Integer的静态方法\n    int sum = integers.stream().reduce(0, Integer::sum);\n    System.out.println(\"reduce = \" + reduce);\n}\n```\n\n### 2.4.2 最大值和最小值\n```java\npublic static void main(String[] args) {\n    List<Integer> integers = Arrays.asList(1, 2, 3, 6, 8);\n    Optional<Integer> min = integers.stream().reduce(Integer::min);\n    System.out.println(\"min = \" + min);\n    Optional<Integer> max = integers.stream().reduce(Integer::max);\n    System.out.println(\"max = \" + max);\n}\n```\n\n## 2.5 Collectors 收集器\n### 2.5.1 查找流中的最大值和最小值 minBy maxBy\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //创建一个Comparator来进行比较  比较菜的卡路里\n    Comparator<Dish> dishComparator = Comparator.comparingInt(Dish::getCalories);\n    //maxBy选出最大值\n    Optional<Dish> collect = dish.stream().collect(Collectors.maxBy(dishComparator));\n    System.out.println(\"collect = \" + collect);\n    //选出最小值\n    Optional<Dish> collect1 = dish.stream().collect(Collectors.minBy(dishComparator));\n    System.out.println(\"collect1 = \" + collect1);\n}\n```\n\n### 2.5.2 汇总 summingInt\n```java\n public static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //计算总和\n    int collect = dish.stream().collect(Collectors.summingInt(Dish::getCalories));\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.5.3 平均数 averagingInt\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //计算平均数\n    Double collect = dish.stream().collect(Collectors.averagingInt(Dish::getCalories));\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.5.4 连接字符串 joining\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    String collect = dish.stream().map(Dish::getName).collect(Collectors.joining());\n    System.out.println(\"collect = \" + collect);\n}\n```\njoining 工厂方法有一个重载版本可以接受元素之间的分界符，这样你就可以得到一个逗号分隔的菜肴名称列表。\n```java\nString collect = dish.stream().map(Dish::getName).collect(Collectors.joining(\", \"));\n```\n\n### 2.5.5 得到流中的总数 counting\n```java\nlong howManyDishes = dish.stream().collect(Collectors.counting());\n```\n\n## 2.6 分组\n### 2.6.1 分组 groupingBy\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //groupingBy接受一个function作为参数\n    Map<Dish.Type, List<Dish>> collect = dish.stream().collect(Collectors.groupingBy(Dish::getType));\n    System.out.println(\"collect = \" + collect);\n}\n```\n如果想用以分类的条件可能比简单的属性访问器要复杂。例如，你可能想把热量不到400卡路里的菜划分为“低热量”（diet），热量400到700卡路里的菜划为“普通”（normal），高于700卡路里的划为“高热量”（fat）。由于Dish类的作者没有把这个操作写成一个方法，你无法使用方法引用，但你可以把这个逻辑写成Lambda表达式。\n```java\npublic static void main(String[] args) {\n    List<Dish> dishList = Dish.getDish();\n    Map<String, List<Dish>> collect = dishList.stream().collect(Collectors.groupingBy(dish->{\n        if (dish.getCalories() <= 400) {\n            return \"DIET\";\n        } else if (dish.getCalories() <= 700) {\n            return \"NORMAL\";\n        } else {\n            return \"FAT\";\n        }\n    }));\n    System.out.println(\"collect = \" + collect);\n}\n```\n### 2.6.2 多级分组\n要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准。\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    Map<Dish.Type, Map<String, List<Dish>>> collect = dish.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.groupingBy(d -> {\n        if (d.getCalories() <= 400) {\n            return \"DIET\";\n        } else if (d.getCalories() <= 700) {\n            return \"NORMAL\";\n        } else {\n            return \"FAT\";\n        }\n    })));\n    System.out.println(\"collect = \" + collect);\n}\n```\n### 2.6.3 按子组收集数据\n在上一面，我们看到可以把第二个groupingBy收集器传递给外层收集器来实现多级分组。但进一步说，传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy。\n\n例如，要数一数菜单中每类菜有多少个，可以传递counting收集器作为groupingBy收集器的第二个参数。\n\n```java\nMap<Dish.Type, Long> typesCount = dish.stream().collect(groupingBy(Dish::getType, counting()));\n```\n普通的单参数groupingBy(f)（其中`f`是分类函数）实际上是 groupingBy(f,toList()) 的简便写法。\n\n# 3 并行流\n并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。\n\n## 3.1 将顺序流转为并行流\n可以把流转换成并行流，从而让前面的函数归约过程（也就是求和）并行运行——对顺序流调用 parallel 方法:\n```java\npublic static long parallelSum(long n) {\n    return Stream.iterate(1L, i -> i + 1)\n            .limit(n)\n            .parallel()\n            .reduce(0L, Long::sum);\n}\n```\nStream在内部分成了几块。因此可以对不同的块独立并行进行归纳操作，最后，同一个归纳操作会将各个子流的部分归纳结果合并起来，得到整个原始流的归纳结果。\n![Stream并行流](/image/java8Stream.jpg)\n类似地，你只需要对并行流调用 sequential 方法就可以把它变成顺序流。\n\n看看流的parallel方法，你可能会想，并行流用的线程是从哪儿来的？有多少个？怎么自定义这个过程呢？\n并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available-Processors()得到的。\n\n但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common.parallelism来改变线程池大小，如下所示：\n```java\nSystem.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\",\"12\");\n```\n这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议你不要修改它。\n\n## 3.2 分支/合并框架\n分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。\n### 3.2.1 使用RecursiveTask\n要把任务提交到这个池，必须创建RecursiveTask的一个子类，其中R是并行化任务（以\n及所有子任务）产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型（当\n然它可能会更新其他非局部机构）。\n要定义RecursiveTask，只需实现它唯一的抽象方法compute ：\n```java\nprotected abstract R compute();\n```\n这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。\n\n### 3.2.2 使用RecursiveTask求和\n```java\npublic class ForkJoinSumCalculator\n        extends java.util.concurrent.RecursiveTask<Long> {\n    private final long[] numbers;\n    private final int start;\n    private final int end;\n    public static final long THRESHOLD = 10_000;\n\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        //创建一个子任务来为数组得前一半求和\n        ForkJoinSumCalculator leftTask =\n                new ForkJoinSumCalculator(numbers, start, start + length / 2);\n        //利 用 另 一 个ForkJoinPool线程异步执行新创建的子任务\n        leftTask.fork();\n        //创建一个子任务来为数组得后一半求和\n        ForkJoinSumCalculator rightTask =\n                new ForkJoinSumCalculator(numbers, start + length / 2, end);\n        //同步执行第二个子任务，有可能进一步递归\n        Long rightResult = rightTask.compute();\n        //读取第一个任务得结构，未完成就等待\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    private long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n\n    public static long forkJoinSum(long n) {\n        long[] numbers = LongStream.rangeClosed(1, n).toArray();\n        ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n        return new ForkJoinPool().invoke(task);\n    }\n\n    public static void main(String[] args) {\n        long l = ForkJoinSumCalculator.forkJoinSum(5);\n        System.out.println(\"l = \" + l);\n    }\n}\n```\n","source":"_posts/java/Java8-Stream中常用操作.md","raw":"---\ntitle: Java8-Stream中的常用操作\ndate: 2019-05-16 22:23:11\ntags:\n    - Java8\n    - stream\ncategories: \n    - java\nnotshow: true\n---\n# 1.前言\nJava8提供了很多新特性，其中有一个就是基于流Stream的操作。Stream是一组用来处理数组，集合的API\n## 1.1 特性\n<!-- more -->\n- 不是数据结构，没有内部存储。\n- 不支持索引访问。\n- 延迟计算\n- 支持并行\n- 很容易生成数据或集合\n- 支持过滤，查找，转换，汇总，聚合等操作\n\n\n## 1.2 运行机制\nStream分为源source，中间操作，终止操作。\n- 流的源可以是一个数组，集合，生成器方法，I/O通道等等。\n- 一个流可以有零个或多个中间操作，每一个中间操作都会返回一个新的流，供下一个操作使用，一个流只会有一个终止操作。\n- Stream只有遇到终止操作，它的源才会开始执行遍历操作。\n\n## 1.3 Stream的创建\n`Stream`的创建其实有很多方式，但是我们在平时用到最多的可能就是基于数组的Stream.of()和集合的stream()方法其实它还有很多种的创建方式，下面将一一列出，并且列举相关实例。\n- 1.通过数组,Stream.of()\n- 2.通过集合\n- 3.通过Stream.generate方法来创建\n- 4.通过Stram.iterate方法\n- 5.其他API\n```java \npublic class CreateStream {\n    // 1.通过数组,Stream.of()\n    static void create1(){\n        String[] str = {\"a\",\"b\",\"c\"};\n        Stream<String> str1 = Stream.of(str);\n    }\n    // 2.通过集合\n    static void create2(){\n        List<String> strings = Arrays.asList(\"a\", \"b\", \"c\");\n        Stream<String> stream = strings.stream();\n    }\n    // 3.通过Stream.generate方法来创建\n    static void create3(){\n        //这是一个无限流，通过这种方法创建在操作的时候最好加上limit进行限制\n        Stream<Integer> generate = Stream.generate(() -> 1);\n        generate.limit(10).forEach(x -> System.out.println(x));\n    } \n    // 4.通过Stram.iterate方法\n    static void create4(){\n        Stream<Integer> iterate = Stream.iterate(1, x -> x +1);\n        iterate.forEach(x -> System.out.println(x));\n    }\n    // 5.其他API\n    static void create5(){\n        String str = \"abc\";\n        IntStream chars = str.chars();\n        chars.forEach(x -> System.out.println(x));\n    }\n}\n```\n\n# 2.Stream的常用操作(API)\n## 2.1 中间操作\n### 2.1.1 filter过滤\n接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。说白了就是给一个条件，filter会根据这个条件截取流中得数据。\n```java\npublic static void testFilter(){\n    List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n    //截取所有能被2整除得数据\n    List<Integer> collect = integers.stream().filter(i -> i % 2 == 0).collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [2, 4, 6, 8, 10]\n```\n\n### 2.1.2 distinct去重\n返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。\n```java\npublic static void main(String[] args) {\n    List<Integer> numbers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);\n    List<Integer> collect = numbers.stream().distinct().collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [1, 2, 3, 4]\n```\n\n### 2.1.3 sorted排序\n对流中得数据进行排序，可以以自然序或着用Comparator接口定义的排序规则来排序一个流。Comparator能使用lambada表达式来初始化，还能够逆序一个已经排序的流。\n```java\npublic static void main(String[] args) {\n    List<Integer> integers = Arrays.asList(5, 8, 2, 6, 41, 11);\n    //排序默认为顺序  顺序 = [2, 5, 6, 8, 11, 41]\n    List<Integer> sorted = integers.stream().sorted().collect(Collectors.toList());\n    System.out.println(\"顺序 = \" + sorted);\n    //逆序    逆序 = [41, 11, 8, 6, 5, 2]\n    List<Integer> reverseOrder = integers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());\n    System.out.println(\"逆序 = \" + reverseOrder);\n    //也可以接收一个lambda\n    List<Integer> ages = integers.stream().sorted(Comparator.comparing(User::getAge)).collect(Collectors.toList());\n}\n```\n\n### 2.1.4 limit截取\n会返回一个不超过给定长度的流。\n```java\npublic static void testLimit(){\n    List<Integer> integers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);\n    List<Integer> collect = integers.stream().limit(3).collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [1, 2, 1]\n```\n\n### 2.1.5 skip舍弃\n会返回一个扔掉了前面n个元素的流。如果流中元素不足n个，则返回一个空流。\n```java\npublic static void testSkip(){\n    List<Integer> integers = Arrays.asList(1, 2, 1, 3, 3, 2, 4);\n    //丢掉流中得前三个元素  \n    List<Integer> collect = integers.stream().skip(3).collect(Collectors.toList());\n    System.out.println(\"collect = \" + collect);\n}\n// 结果: collect = [3, 3, 2, 4]\n```\n\n### 2.1.6 map归纳\n接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素。就是根据指定函数获取流中得每个元素得数据并重新组合成一个新的元素。\n```java\npublic static void main(String[] args) {\n    //自己建好得一个获取对象list得方法\n    List<Dish> dishList = Dish.getDishList();\n    //获取每一道菜得名称  并放到一个list中\n    List<String> collect = dishList.stream().map(Dish::getName).collect(Collectors.toList());\n    //collect = [pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon]\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.1.7 flatMap扁平化\n该方法key可以让你把一个流中的每个值都换成另一个流，然后把所有的流都链接起来成为一个流。\n```java\npublic static void main(String[] args) {\n    String[] words = {\"Hello\", \"World\"};\n    List<String> collect = Stream.of(words).        //数组转换流\n            map(w -> w.split(\"\")).  //去掉“”并获取到两个String[]\n            flatMap(Arrays::stream).        //方法调用将两个String[]扁平化为一个stream\n            distinct().                     //去重    \n            collect(Collectors.toList());\n    //collect = [H, e, l, o, W, r, d]\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.1.8 peek\npeek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。\n```java\npublic static void main(String[] args) {\n    List<Integer> numbers = Arrays.asList(2, 3, 4, 5);\n    List<Integer> result =\n            numbers.stream()\n                    .peek(x -> System.out.println(\"from stream: \" + x))\n                    .map(x -> x + 17)\n                    .peek(x -> System.out.println(\"after map: \" + x))\n                    .filter(x -> x % 2 == 0)\n                    .peek(x -> System.out.println(\"after filter: \" + x))\n                    .limit(3)\n                    .peek(x -> System.out.println(\"after limit: \" + x))\n                    .collect(Collectors.toList());\n}\n// 结果：\n//     from stream: 2\n//     after map: 19\n//     from stream: 3\n//     after map: 20\n//     after filter: 20\n//     after limit: 20\n//     from stream: 4\n//     after map: 21\n//     from stream: 5\n//     after map: 22\n//     after filter: 22\n//     after limit: 22\n\n```\n\n### 2.1.9 collect收集\n从上面得代码已经可以看出来，collect是将最终stream中得数据收集起来，最终生成一个list，set，或者map。\n```java\npublic static void main(String[] args) {\n    List<Dish> dishList = Dish.getDishList();\n    // list\n    List<Dish> collect = dishList.stream().limit(2).collect(Collectors.toList());\n    // set\n    Set<Dish> collect1 = dishList.stream().limit(2).collect(Collectors.toSet());\n    // map\n    Map<String, Dish.Type> collect2 = dishList.stream().limit(2).collect(Collectors.toMap(Dish::getName, Dish::getType));\n}\n\n```\n\n## 2.2 终止操作\n- 循环 forEach\n- 计算 min、max、count、average\n- 匹配 anyMatch、allMatch、noneMatch、findFirst、findAny\n- 汇聚 reduce\n- 收集器 collect\n\n## 2.3 查找和匹配\n常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch，anyMatch，noneMatch，findFirst和findAny方法提供了这样的工具。\n查找和匹配都是终端操作。\n\n### 2.3.1 anyMatch\nanyMatch方法可以回答“流中是否有一个元素能匹配到给定的谓词”。会返回一个boolean值。\n```java\npublic class AnyMatch {\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        boolean b = dish.stream().anyMatch(Dish::isVegetarian);\n        System.out.println(b);\n    }\n}\n```\n\n### 2.3.2 allMatch\nallMatch方法和anyMatch类似，校验流中是否都能匹配到给定的谓词。\n```java\nclass AllMatch{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        //是否所有菜的热量都小于1000\n        boolean b = dish.stream().allMatch(d -> d.getCalories() < 1000);\n        System.out.println(b);\n    }\n}\n```\n\n### 2.3.3 noneMatch\nnoneMatch方法可以确保流中没有任何元素与给定的谓词匹配。\n```java\nclass NoneMatch{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        //没有任何菜的热量大于等于1000\n        boolean b = dish.stream().allMatch(d -> d.getCalories() >= 1000);\n        System.out.println(b);\n    }\n}\n```\n`anyMatch`，`noneMatch`，`allMatch`这三个操作都用到了所谓的短路。\n\n### 2.3.4 findAny\nfindAny方法将返回当前流中的符合过滤条件的任意元素。\n```java\nclass FindAny{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        Optional<Dish> any = dish.stream().filter(Dish::isVegetarian).findAny();\n        System.out.println(\"any = \" + any);\n    }\n}\n```\n\n### 2.3.5 findFirst\nfindFirst方法能找到你想要的第一个元素。\n```java\nclass FindFirst{\n    public static void main(String[] args) {\n        List<Dish> dish = Dish.getDish();\n        Optional<Dish> any = dish.stream().filter(Dish::isVegetarian).findFirst();\n        System.out.println(\"any = \" + any);\n    }\n}\n```\n## 2.4 reduce 归约\n此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个 Integer 。这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操\n作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。\n### 2.4.1 元素求和\n```java\npublic static void main(String[] args) {\n    List<Integer> integers = Arrays.asList(1, 2, 3, 6, 8);\n    //求list中的和，以0为基数\n    Integer reduce = integers.stream().reduce(0, (a, b) -> a + b);\n    //Integer的静态方法\n    int sum = integers.stream().reduce(0, Integer::sum);\n    System.out.println(\"reduce = \" + reduce);\n}\n```\n\n### 2.4.2 最大值和最小值\n```java\npublic static void main(String[] args) {\n    List<Integer> integers = Arrays.asList(1, 2, 3, 6, 8);\n    Optional<Integer> min = integers.stream().reduce(Integer::min);\n    System.out.println(\"min = \" + min);\n    Optional<Integer> max = integers.stream().reduce(Integer::max);\n    System.out.println(\"max = \" + max);\n}\n```\n\n## 2.5 Collectors 收集器\n### 2.5.1 查找流中的最大值和最小值 minBy maxBy\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //创建一个Comparator来进行比较  比较菜的卡路里\n    Comparator<Dish> dishComparator = Comparator.comparingInt(Dish::getCalories);\n    //maxBy选出最大值\n    Optional<Dish> collect = dish.stream().collect(Collectors.maxBy(dishComparator));\n    System.out.println(\"collect = \" + collect);\n    //选出最小值\n    Optional<Dish> collect1 = dish.stream().collect(Collectors.minBy(dishComparator));\n    System.out.println(\"collect1 = \" + collect1);\n}\n```\n\n### 2.5.2 汇总 summingInt\n```java\n public static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //计算总和\n    int collect = dish.stream().collect(Collectors.summingInt(Dish::getCalories));\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.5.3 平均数 averagingInt\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //计算平均数\n    Double collect = dish.stream().collect(Collectors.averagingInt(Dish::getCalories));\n    System.out.println(\"collect = \" + collect);\n}\n```\n\n### 2.5.4 连接字符串 joining\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    String collect = dish.stream().map(Dish::getName).collect(Collectors.joining());\n    System.out.println(\"collect = \" + collect);\n}\n```\njoining 工厂方法有一个重载版本可以接受元素之间的分界符，这样你就可以得到一个逗号分隔的菜肴名称列表。\n```java\nString collect = dish.stream().map(Dish::getName).collect(Collectors.joining(\", \"));\n```\n\n### 2.5.5 得到流中的总数 counting\n```java\nlong howManyDishes = dish.stream().collect(Collectors.counting());\n```\n\n## 2.6 分组\n### 2.6.1 分组 groupingBy\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    //groupingBy接受一个function作为参数\n    Map<Dish.Type, List<Dish>> collect = dish.stream().collect(Collectors.groupingBy(Dish::getType));\n    System.out.println(\"collect = \" + collect);\n}\n```\n如果想用以分类的条件可能比简单的属性访问器要复杂。例如，你可能想把热量不到400卡路里的菜划分为“低热量”（diet），热量400到700卡路里的菜划为“普通”（normal），高于700卡路里的划为“高热量”（fat）。由于Dish类的作者没有把这个操作写成一个方法，你无法使用方法引用，但你可以把这个逻辑写成Lambda表达式。\n```java\npublic static void main(String[] args) {\n    List<Dish> dishList = Dish.getDish();\n    Map<String, List<Dish>> collect = dishList.stream().collect(Collectors.groupingBy(dish->{\n        if (dish.getCalories() <= 400) {\n            return \"DIET\";\n        } else if (dish.getCalories() <= 700) {\n            return \"NORMAL\";\n        } else {\n            return \"FAT\";\n        }\n    }));\n    System.out.println(\"collect = \" + collect);\n}\n```\n### 2.6.2 多级分组\n要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准。\n```java\npublic static void main(String[] args) {\n    List<Dish> dish = Dish.getDish();\n    Map<Dish.Type, Map<String, List<Dish>>> collect = dish.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.groupingBy(d -> {\n        if (d.getCalories() <= 400) {\n            return \"DIET\";\n        } else if (d.getCalories() <= 700) {\n            return \"NORMAL\";\n        } else {\n            return \"FAT\";\n        }\n    })));\n    System.out.println(\"collect = \" + collect);\n}\n```\n### 2.6.3 按子组收集数据\n在上一面，我们看到可以把第二个groupingBy收集器传递给外层收集器来实现多级分组。但进一步说，传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy。\n\n例如，要数一数菜单中每类菜有多少个，可以传递counting收集器作为groupingBy收集器的第二个参数。\n\n```java\nMap<Dish.Type, Long> typesCount = dish.stream().collect(groupingBy(Dish::getType, counting()));\n```\n普通的单参数groupingBy(f)（其中`f`是分类函数）实际上是 groupingBy(f,toList()) 的简便写法。\n\n# 3 并行流\n并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。\n\n## 3.1 将顺序流转为并行流\n可以把流转换成并行流，从而让前面的函数归约过程（也就是求和）并行运行——对顺序流调用 parallel 方法:\n```java\npublic static long parallelSum(long n) {\n    return Stream.iterate(1L, i -> i + 1)\n            .limit(n)\n            .parallel()\n            .reduce(0L, Long::sum);\n}\n```\nStream在内部分成了几块。因此可以对不同的块独立并行进行归纳操作，最后，同一个归纳操作会将各个子流的部分归纳结果合并起来，得到整个原始流的归纳结果。\n![Stream并行流](/image/java8Stream.jpg)\n类似地，你只需要对并行流调用 sequential 方法就可以把它变成顺序流。\n\n看看流的parallel方法，你可能会想，并行流用的线程是从哪儿来的？有多少个？怎么自定义这个过程呢？\n并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available-Processors()得到的。\n\n但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common.parallelism来改变线程池大小，如下所示：\n```java\nSystem.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\",\"12\");\n```\n这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议你不要修改它。\n\n## 3.2 分支/合并框架\n分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。\n### 3.2.1 使用RecursiveTask\n要把任务提交到这个池，必须创建RecursiveTask的一个子类，其中R是并行化任务（以\n及所有子任务）产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型（当\n然它可能会更新其他非局部机构）。\n要定义RecursiveTask，只需实现它唯一的抽象方法compute ：\n```java\nprotected abstract R compute();\n```\n这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。\n\n### 3.2.2 使用RecursiveTask求和\n```java\npublic class ForkJoinSumCalculator\n        extends java.util.concurrent.RecursiveTask<Long> {\n    private final long[] numbers;\n    private final int start;\n    private final int end;\n    public static final long THRESHOLD = 10_000;\n\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        //创建一个子任务来为数组得前一半求和\n        ForkJoinSumCalculator leftTask =\n                new ForkJoinSumCalculator(numbers, start, start + length / 2);\n        //利 用 另 一 个ForkJoinPool线程异步执行新创建的子任务\n        leftTask.fork();\n        //创建一个子任务来为数组得后一半求和\n        ForkJoinSumCalculator rightTask =\n                new ForkJoinSumCalculator(numbers, start + length / 2, end);\n        //同步执行第二个子任务，有可能进一步递归\n        Long rightResult = rightTask.compute();\n        //读取第一个任务得结构，未完成就等待\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    private long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n\n    public static long forkJoinSum(long n) {\n        long[] numbers = LongStream.rangeClosed(1, n).toArray();\n        ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n        return new ForkJoinPool().invoke(task);\n    }\n\n    public static void main(String[] args) {\n        long l = ForkJoinSumCalculator.forkJoinSum(5);\n        System.out.println(\"l = \" + l);\n    }\n}\n```\n","slug":"java/Java8-Stream中常用操作","published":1,"updated":"2019-09-05T03:26:27.609Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcoq000ljfus2j65eiy9","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>Java8提供了很多新特性，其中有一个就是基于流Stream的操作。Stream是一组用来处理数组，集合的API</p>\n<h2 id=\"1-1-特性\"><a href=\"#1-1-特性\" class=\"headerlink\" title=\"1.1 特性\"></a>1.1 特性</h2><a id=\"more\"></a>\n<ul>\n<li>不是数据结构，没有内部存储。</li>\n<li>不支持索引访问。</li>\n<li>延迟计算</li>\n<li>支持并行</li>\n<li>很容易生成数据或集合</li>\n<li>支持过滤，查找，转换，汇总，聚合等操作</li>\n</ul>\n<h2 id=\"1-2-运行机制\"><a href=\"#1-2-运行机制\" class=\"headerlink\" title=\"1.2 运行机制\"></a>1.2 运行机制</h2><p>Stream分为源source，中间操作，终止操作。</p>\n<ul>\n<li>流的源可以是一个数组，集合，生成器方法，I/O通道等等。</li>\n<li>一个流可以有零个或多个中间操作，每一个中间操作都会返回一个新的流，供下一个操作使用，一个流只会有一个终止操作。</li>\n<li>Stream只有遇到终止操作，它的源才会开始执行遍历操作。</li>\n</ul>\n<h2 id=\"1-3-Stream的创建\"><a href=\"#1-3-Stream的创建\" class=\"headerlink\" title=\"1.3 Stream的创建\"></a>1.3 Stream的创建</h2><p><code>Stream</code>的创建其实有很多方式，但是我们在平时用到最多的可能就是基于数组的Stream.of()和集合的stream()方法其实它还有很多种的创建方式，下面将一一列出，并且列举相关实例。</p>\n<ul>\n<li>1.通过数组,Stream.of()</li>\n<li>2.通过集合</li>\n<li>3.通过Stream.generate方法来创建</li>\n<li>4.通过Stram.iterate方法</li>\n<li>5.其他API<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreateStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.通过数组,Stream.of()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String[] str = &#123;<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">        Stream&lt;String&gt; str1 = Stream.of(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.通过集合</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; strings = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; stream = strings.stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 3.通过Stream.generate方法来创建</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这是一个无限流，通过这种方法创建在操作的时候最好加上limit进行限制</span></span><br><span class=\"line\">        Stream&lt;Integer&gt; generate = Stream.generate(() -&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        generate.limit(<span class=\"number\">10</span>).forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 4.通过Stram.iterate方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Stream&lt;Integer&gt; iterate = Stream.iterate(<span class=\"number\">1</span>, x -&gt; x +<span class=\"number\">1</span>);</span><br><span class=\"line\">        iterate.forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 5.其他API</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create5</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String str = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        IntStream chars = str.chars();</span><br><span class=\"line\">        chars.forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"2-Stream的常用操作-API\"><a href=\"#2-Stream的常用操作-API\" class=\"headerlink\" title=\"2.Stream的常用操作(API)\"></a>2.Stream的常用操作(API)</h1><h2 id=\"2-1-中间操作\"><a href=\"#2-1-中间操作\" class=\"headerlink\" title=\"2.1 中间操作\"></a>2.1 中间操作</h2><h3 id=\"2-1-1-filter过滤\"><a href=\"#2-1-1-filter过滤\" class=\"headerlink\" title=\"2.1.1 filter过滤\"></a>2.1.1 filter过滤</h3><p>接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。说白了就是给一个条件，filter会根据这个条件截取流中得数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">//截取所有能被2整除得数据</span></span><br><span class=\"line\">    List&lt;Integer&gt; collect = integers.stream().filter(i -&gt; i % <span class=\"number\">2</span> == <span class=\"number\">0</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2-distinct去重\"><a href=\"#2-1-2-distinct去重\" class=\"headerlink\" title=\"2.1.2 distinct去重\"></a>2.1.2 distinct去重</h3><p>返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; collect = numbers.stream().distinct().collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3-sorted排序\"><a href=\"#2-1-3-sorted排序\" class=\"headerlink\" title=\"2.1.3 sorted排序\"></a>2.1.3 sorted排序</h3><p>对流中得数据进行排序，可以以自然序或着用Comparator接口定义的排序规则来排序一个流。Comparator能使用lambada表达式来初始化，还能够逆序一个已经排序的流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">41</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"comment\">//排序默认为顺序  顺序 = [2, 5, 6, 8, 11, 41]</span></span><br><span class=\"line\">    List&lt;Integer&gt; sorted = integers.stream().sorted().collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"顺序 = \"</span> + sorted);</span><br><span class=\"line\">    <span class=\"comment\">//逆序    逆序 = [41, 11, 8, 6, 5, 2]</span></span><br><span class=\"line\">    List&lt;Integer&gt; reverseOrder = integers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"逆序 = \"</span> + reverseOrder);</span><br><span class=\"line\">    <span class=\"comment\">//也可以接收一个lambda</span></span><br><span class=\"line\">    List&lt;Integer&gt; ages = integers.stream().sorted(Comparator.comparing(User::getAge)).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-4-limit截取\"><a href=\"#2-1-4-limit截取\" class=\"headerlink\" title=\"2.1.4 limit截取\"></a>2.1.4 limit截取</h3><p>会返回一个不超过给定长度的流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testLimit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; collect = integers.stream().limit(<span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [1, 2, 1]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-5-skip舍弃\"><a href=\"#2-1-5-skip舍弃\" class=\"headerlink\" title=\"2.1.5 skip舍弃\"></a>2.1.5 skip舍弃</h3><p>会返回一个扔掉了前面n个元素的流。如果流中元素不足n个，则返回一个空流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSkip</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">//丢掉流中得前三个元素  </span></span><br><span class=\"line\">    List&lt;Integer&gt; collect = integers.stream().skip(<span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [3, 3, 2, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-6-map归纳\"><a href=\"#2-1-6-map归纳\" class=\"headerlink\" title=\"2.1.6 map归纳\"></a>2.1.6 map归纳</h3><p>接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素。就是根据指定函数获取流中得每个元素得数据并重新组合成一个新的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//自己建好得一个获取对象list得方法</span></span><br><span class=\"line\">    List&lt;Dish&gt; dishList = Dish.getDishList();</span><br><span class=\"line\">    <span class=\"comment\">//获取每一道菜得名称  并放到一个list中</span></span><br><span class=\"line\">    List&lt;String&gt; collect = dishList.stream().map(Dish::getName).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">//collect = [pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon]</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-7-flatMap扁平化\"><a href=\"#2-1-7-flatMap扁平化\" class=\"headerlink\" title=\"2.1.7 flatMap扁平化\"></a>2.1.7 flatMap扁平化</h3><p>该方法key可以让你把一个流中的每个值都换成另一个流，然后把所有的流都链接起来成为一个流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    String[] words = &#123;<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"World\"</span>&#125;;</span><br><span class=\"line\">    List&lt;String&gt; collect = Stream.of(words).        <span class=\"comment\">//数组转换流</span></span><br><span class=\"line\">            map(w -&gt; w.split(<span class=\"string\">\"\"</span>)).  <span class=\"comment\">//去掉“”并获取到两个String[]</span></span><br><span class=\"line\">            flatMap(Arrays::stream).        <span class=\"comment\">//方法调用将两个String[]扁平化为一个stream</span></span><br><span class=\"line\">            distinct().                     <span class=\"comment\">//去重    </span></span><br><span class=\"line\">            collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">//collect = [H, e, l, o, W, r, d]</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-8-peek\"><a href=\"#2-1-8-peek\" class=\"headerlink\" title=\"2.1.8 peek\"></a>2.1.8 peek</h3><p>peek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; result =</span><br><span class=\"line\">            numbers.stream()</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"from stream: \"</span> + x))</span><br><span class=\"line\">                    .map(x -&gt; x + <span class=\"number\">17</span>)</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"after map: \"</span> + x))</span><br><span class=\"line\">                    .filter(x -&gt; x % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"after filter: \"</span> + x))</span><br><span class=\"line\">                    .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"after limit: \"</span> + x))</span><br><span class=\"line\">                    .collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果：</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 2</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 19</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 3</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 20</span></span><br><span class=\"line\"><span class=\"comment\">//     after filter: 20</span></span><br><span class=\"line\"><span class=\"comment\">//     after limit: 20</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 4</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 21</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 5</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 22</span></span><br><span class=\"line\"><span class=\"comment\">//     after filter: 22</span></span><br><span class=\"line\"><span class=\"comment\">//     after limit: 22</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-9-collect收集\"><a href=\"#2-1-9-collect收集\" class=\"headerlink\" title=\"2.1.9 collect收集\"></a>2.1.9 collect收集</h3><p>从上面得代码已经可以看出来，collect是将最终stream中得数据收集起来，最终生成一个list，set，或者map。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dishList = Dish.getDishList();</span><br><span class=\"line\">    <span class=\"comment\">// list</span></span><br><span class=\"line\">    List&lt;Dish&gt; collect = dishList.stream().limit(<span class=\"number\">2</span>).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// set</span></span><br><span class=\"line\">    Set&lt;Dish&gt; collect1 = dishList.stream().limit(<span class=\"number\">2</span>).collect(Collectors.toSet());</span><br><span class=\"line\">    <span class=\"comment\">// map</span></span><br><span class=\"line\">    Map&lt;String, Dish.Type&gt; collect2 = dishList.stream().limit(<span class=\"number\">2</span>).collect(Collectors.toMap(Dish::getName, Dish::getType));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-终止操作\"><a href=\"#2-2-终止操作\" class=\"headerlink\" title=\"2.2 终止操作\"></a>2.2 终止操作</h2><ul>\n<li>循环 forEach</li>\n<li>计算 min、max、count、average</li>\n<li>匹配 anyMatch、allMatch、noneMatch、findFirst、findAny</li>\n<li>汇聚 reduce</li>\n<li>收集器 collect</li>\n</ul>\n<h2 id=\"2-3-查找和匹配\"><a href=\"#2-3-查找和匹配\" class=\"headerlink\" title=\"2.3 查找和匹配\"></a>2.3 查找和匹配</h2><p>常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch，anyMatch，noneMatch，findFirst和findAny方法提供了这样的工具。<br>查找和匹配都是终端操作。</p>\n<h3 id=\"2-3-1-anyMatch\"><a href=\"#2-3-1-anyMatch\" class=\"headerlink\" title=\"2.3.1 anyMatch\"></a>2.3.1 anyMatch</h3><p>anyMatch方法可以回答“流中是否有一个元素能匹配到给定的谓词”。会返回一个boolean值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnyMatch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = dish.stream().anyMatch(Dish::isVegetarian);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-2-allMatch\"><a href=\"#2-3-2-allMatch\" class=\"headerlink\" title=\"2.3.2 allMatch\"></a>2.3.2 allMatch</h3><p>allMatch方法和anyMatch类似，校验流中是否都能匹配到给定的谓词。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllMatch</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        <span class=\"comment\">//是否所有菜的热量都小于1000</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = dish.stream().allMatch(d -&gt; d.getCalories() &lt; <span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3-noneMatch\"><a href=\"#2-3-3-noneMatch\" class=\"headerlink\" title=\"2.3.3 noneMatch\"></a>2.3.3 noneMatch</h3><p>noneMatch方法可以确保流中没有任何元素与给定的谓词匹配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoneMatch</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        <span class=\"comment\">//没有任何菜的热量大于等于1000</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = dish.stream().allMatch(d -&gt; d.getCalories() &gt;= <span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>anyMatch</code>，<code>noneMatch</code>，<code>allMatch</code>这三个操作都用到了所谓的短路。</p>\n<h3 id=\"2-3-4-findAny\"><a href=\"#2-3-4-findAny\" class=\"headerlink\" title=\"2.3.4 findAny\"></a>2.3.4 findAny</h3><p>findAny方法将返回当前流中的符合过滤条件的任意元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindAny</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        Optional&lt;Dish&gt; any = dish.stream().filter(Dish::isVegetarian).findAny();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"any = \"</span> + any);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-5-findFirst\"><a href=\"#2-3-5-findFirst\" class=\"headerlink\" title=\"2.3.5 findFirst\"></a>2.3.5 findFirst</h3><p>findFirst方法能找到你想要的第一个元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindFirst</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        Optional&lt;Dish&gt; any = dish.stream().filter(Dish::isVegetarian).findFirst();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"any = \"</span> + any);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4-reduce-归约\"><a href=\"#2-4-reduce-归约\" class=\"headerlink\" title=\"2.4 reduce 归约\"></a>2.4 reduce 归约</h2><p>此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个 Integer 。这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操<br>作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。</p>\n<h3 id=\"2-4-1-元素求和\"><a href=\"#2-4-1-元素求和\" class=\"headerlink\" title=\"2.4.1 元素求和\"></a>2.4.1 元素求和</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"comment\">//求list中的和，以0为基数</span></span><br><span class=\"line\">    Integer reduce = integers.stream().reduce(<span class=\"number\">0</span>, (a, b) -&gt; a + b);</span><br><span class=\"line\">    <span class=\"comment\">//Integer的静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = integers.stream().reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"reduce = \"</span> + reduce);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-最大值和最小值\"><a href=\"#2-4-2-最大值和最小值\" class=\"headerlink\" title=\"2.4.2 最大值和最小值\"></a>2.4.2 最大值和最小值</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">    Optional&lt;Integer&gt; min = integers.stream().reduce(Integer::min);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"min = \"</span> + min);</span><br><span class=\"line\">    Optional&lt;Integer&gt; max = integers.stream().reduce(Integer::max);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"max = \"</span> + max);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-Collectors-收集器\"><a href=\"#2-5-Collectors-收集器\" class=\"headerlink\" title=\"2.5 Collectors 收集器\"></a>2.5 Collectors 收集器</h2><h3 id=\"2-5-1-查找流中的最大值和最小值-minBy-maxBy\"><a href=\"#2-5-1-查找流中的最大值和最小值-minBy-maxBy\" class=\"headerlink\" title=\"2.5.1 查找流中的最大值和最小值 minBy maxBy\"></a>2.5.1 查找流中的最大值和最小值 minBy maxBy</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//创建一个Comparator来进行比较  比较菜的卡路里</span></span><br><span class=\"line\">    Comparator&lt;Dish&gt; dishComparator = Comparator.comparingInt(Dish::getCalories);</span><br><span class=\"line\">    <span class=\"comment\">//maxBy选出最大值</span></span><br><span class=\"line\">    Optional&lt;Dish&gt; collect = dish.stream().collect(Collectors.maxBy(dishComparator));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">    <span class=\"comment\">//选出最小值</span></span><br><span class=\"line\">    Optional&lt;Dish&gt; collect1 = dish.stream().collect(Collectors.minBy(dishComparator));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect1 = \"</span> + collect1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-2-汇总-summingInt\"><a href=\"#2-5-2-汇总-summingInt\" class=\"headerlink\" title=\"2.5.2 汇总 summingInt\"></a>2.5.2 汇总 summingInt</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//计算总和</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> collect = dish.stream().collect(Collectors.summingInt(Dish::getCalories));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-3-平均数-averagingInt\"><a href=\"#2-5-3-平均数-averagingInt\" class=\"headerlink\" title=\"2.5.3 平均数 averagingInt\"></a>2.5.3 平均数 averagingInt</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//计算平均数</span></span><br><span class=\"line\">    Double collect = dish.stream().collect(Collectors.averagingInt(Dish::getCalories));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-4-连接字符串-joining\"><a href=\"#2-5-4-连接字符串-joining\" class=\"headerlink\" title=\"2.5.4 连接字符串 joining\"></a>2.5.4 连接字符串 joining</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    String collect = dish.stream().map(Dish::getName).collect(Collectors.joining());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>joining 工厂方法有一个重载版本可以接受元素之间的分界符，这样你就可以得到一个逗号分隔的菜肴名称列表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String collect = dish.stream().map(Dish::getName).collect(Collectors.joining(<span class=\"string\">\", \"</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-5-得到流中的总数-counting\"><a href=\"#2-5-5-得到流中的总数-counting\" class=\"headerlink\" title=\"2.5.5 得到流中的总数 counting\"></a>2.5.5 得到流中的总数 counting</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> howManyDishes = dish.stream().collect(Collectors.counting());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-6-分组\"><a href=\"#2-6-分组\" class=\"headerlink\" title=\"2.6 分组\"></a>2.6 分组</h2><h3 id=\"2-6-1-分组-groupingBy\"><a href=\"#2-6-1-分组-groupingBy\" class=\"headerlink\" title=\"2.6.1 分组 groupingBy\"></a>2.6.1 分组 groupingBy</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//groupingBy接受一个function作为参数</span></span><br><span class=\"line\">    Map&lt;Dish.Type, List&lt;Dish&gt;&gt; collect = dish.stream().collect(Collectors.groupingBy(Dish::getType));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果想用以分类的条件可能比简单的属性访问器要复杂。例如，你可能想把热量不到400卡路里的菜划分为“低热量”（diet），热量400到700卡路里的菜划为“普通”（normal），高于700卡路里的划为“高热量”（fat）。由于Dish类的作者没有把这个操作写成一个方法，你无法使用方法引用，但你可以把这个逻辑写成Lambda表达式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dishList = Dish.getDish();</span><br><span class=\"line\">    Map&lt;String, List&lt;Dish&gt;&gt; collect = dishList.stream().collect(Collectors.groupingBy(dish-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dish.getCalories() &lt;= <span class=\"number\">400</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"DIET\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dish.getCalories() &lt;= <span class=\"number\">700</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"NORMAL\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"FAT\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-6-2-多级分组\"><a href=\"#2-6-2-多级分组\" class=\"headerlink\" title=\"2.6.2 多级分组\"></a>2.6.2 多级分组</h3><p>要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    Map&lt;Dish.Type, Map&lt;String, List&lt;Dish&gt;&gt;&gt; collect = dish.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.groupingBy(d -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d.getCalories() &lt;= <span class=\"number\">400</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"DIET\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (d.getCalories() &lt;= <span class=\"number\">700</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"NORMAL\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"FAT\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-6-3-按子组收集数据\"><a href=\"#2-6-3-按子组收集数据\" class=\"headerlink\" title=\"2.6.3 按子组收集数据\"></a>2.6.3 按子组收集数据</h3><p>在上一面，我们看到可以把第二个groupingBy收集器传递给外层收集器来实现多级分组。但进一步说，传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy。</p>\n<p>例如，要数一数菜单中每类菜有多少个，可以传递counting收集器作为groupingBy收集器的第二个参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Dish.Type, Long&gt; typesCount = dish.stream().collect(groupingBy(Dish::getType, counting()));</span><br></pre></td></tr></table></figure>\n<p>普通的单参数groupingBy(f)（其中<code>f</code>是分类函数）实际上是 groupingBy(f,toList()) 的简便写法。</p>\n<h1 id=\"3-并行流\"><a href=\"#3-并行流\" class=\"headerlink\" title=\"3 并行流\"></a>3 并行流</h1><p>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。</p>\n<h2 id=\"3-1-将顺序流转为并行流\"><a href=\"#3-1-将顺序流转为并行流\" class=\"headerlink\" title=\"3.1 将顺序流转为并行流\"></a>3.1 将顺序流转为并行流</h2><p>可以把流转换成并行流，从而让前面的函数归约过程（也就是求和）并行运行——对顺序流调用 parallel 方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">parallelSum</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Stream.iterate(<span class=\"number\">1L</span>, i -&gt; i + <span class=\"number\">1</span>)</span><br><span class=\"line\">            .limit(n)</span><br><span class=\"line\">            .parallel()</span><br><span class=\"line\">            .reduce(<span class=\"number\">0L</span>, Long::sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Stream在内部分成了几块。因此可以对不同的块独立并行进行归纳操作，最后，同一个归纳操作会将各个子流的部分归纳结果合并起来，得到整个原始流的归纳结果。<br><img src=\"/image/java8Stream.jpg\" alt=\"Stream并行流\"><br>类似地，你只需要对并行流调用 sequential 方法就可以把它变成顺序流。</p>\n<p>看看流的parallel方法，你可能会想，并行流用的线程是从哪儿来的？有多少个？怎么自定义这个过程呢？<br>并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available-Processors()得到的。</p>\n<p>但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common.parallelism来改变线程池大小，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty(<span class=\"string\">\"java.util.concurrent.ForkJoinPool.common.parallelism\"</span>,<span class=\"string\">\"12\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议你不要修改它。</p>\n<h2 id=\"3-2-分支-合并框架\"><a href=\"#3-2-分支-合并框架\" class=\"headerlink\" title=\"3.2 分支/合并框架\"></a>3.2 分支/合并框架</h2><p>分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。</p>\n<h3 id=\"3-2-1-使用RecursiveTask\"><a href=\"#3-2-1-使用RecursiveTask\" class=\"headerlink\" title=\"3.2.1 使用RecursiveTask\"></a>3.2.1 使用RecursiveTask</h3><p>要把任务提交到这个池，必须创建RecursiveTask的一个子类，其中R是并行化任务（以<br>及所有子任务）产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型（当<br>然它可能会更新其他非局部机构）。<br>要定义RecursiveTask，只需实现它唯一的抽象方法compute ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> R <span class=\"title\">compute</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。</p>\n<h3 id=\"3-2-2-使用RecursiveTask求和\"><a href=\"#3-2-2-使用RecursiveTask求和\" class=\"headerlink\" title=\"3.2.2 使用RecursiveTask求和\"></a>3.2.2 使用RecursiveTask求和</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForkJoinSumCalculator</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">util</span>.<span class=\"title\">concurrent</span>.<span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] numbers;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> THRESHOLD = <span class=\"number\">10_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(numbers, <span class=\"number\">0</span>, numbers.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] numbers, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.numbers = numbers;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Long <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = end - start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> computeSequentially();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个子任务来为数组得前一半求和</span></span><br><span class=\"line\">        ForkJoinSumCalculator leftTask =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ForkJoinSumCalculator(numbers, start, start + length / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//利 用 另 一 个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class=\"line\">        leftTask.fork();</span><br><span class=\"line\">        <span class=\"comment\">//创建一个子任务来为数组得后一半求和</span></span><br><span class=\"line\">        ForkJoinSumCalculator rightTask =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ForkJoinSumCalculator(numbers, start + length / <span class=\"number\">2</span>, end);</span><br><span class=\"line\">        <span class=\"comment\">//同步执行第二个子任务，有可能进一步递归</span></span><br><span class=\"line\">        Long rightResult = rightTask.compute();</span><br><span class=\"line\">        <span class=\"comment\">//读取第一个任务得结构，未完成就等待</span></span><br><span class=\"line\">        Long leftResult = leftTask.join();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftResult + rightResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">computeSequentially</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            sum += numbers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">forkJoinSum</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span>[] numbers = LongStream.rangeClosed(<span class=\"number\">1</span>, n).toArray();</span><br><span class=\"line\">        ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> ForkJoinSumCalculator(numbers);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ForkJoinPool().invoke(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> l = ForkJoinSumCalculator.forkJoinSum(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"l = \"</span> + l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>Java8提供了很多新特性，其中有一个就是基于流Stream的操作。Stream是一组用来处理数组，集合的API</p>\n<h2 id=\"1-1-特性\"><a href=\"#1-1-特性\" class=\"headerlink\" title=\"1.1 特性\"></a>1.1 特性</h2>","more":"<ul>\n<li>不是数据结构，没有内部存储。</li>\n<li>不支持索引访问。</li>\n<li>延迟计算</li>\n<li>支持并行</li>\n<li>很容易生成数据或集合</li>\n<li>支持过滤，查找，转换，汇总，聚合等操作</li>\n</ul>\n<h2 id=\"1-2-运行机制\"><a href=\"#1-2-运行机制\" class=\"headerlink\" title=\"1.2 运行机制\"></a>1.2 运行机制</h2><p>Stream分为源source，中间操作，终止操作。</p>\n<ul>\n<li>流的源可以是一个数组，集合，生成器方法，I/O通道等等。</li>\n<li>一个流可以有零个或多个中间操作，每一个中间操作都会返回一个新的流，供下一个操作使用，一个流只会有一个终止操作。</li>\n<li>Stream只有遇到终止操作，它的源才会开始执行遍历操作。</li>\n</ul>\n<h2 id=\"1-3-Stream的创建\"><a href=\"#1-3-Stream的创建\" class=\"headerlink\" title=\"1.3 Stream的创建\"></a>1.3 Stream的创建</h2><p><code>Stream</code>的创建其实有很多方式，但是我们在平时用到最多的可能就是基于数组的Stream.of()和集合的stream()方法其实它还有很多种的创建方式，下面将一一列出，并且列举相关实例。</p>\n<ul>\n<li>1.通过数组,Stream.of()</li>\n<li>2.通过集合</li>\n<li>3.通过Stream.generate方法来创建</li>\n<li>4.通过Stram.iterate方法</li>\n<li>5.其他API<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreateStream</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1.通过数组,Stream.of()</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String[] str = &#123;<span class=\"string\">\"a\"</span>,<span class=\"string\">\"b\"</span>,<span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">        Stream&lt;String&gt; str1 = Stream.of(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.通过集合</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        List&lt;String&gt; strings = Arrays.asList(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>);</span><br><span class=\"line\">        Stream&lt;String&gt; stream = strings.stream();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 3.通过Stream.generate方法来创建</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这是一个无限流，通过这种方法创建在操作的时候最好加上limit进行限制</span></span><br><span class=\"line\">        Stream&lt;Integer&gt; generate = Stream.generate(() -&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">        generate.limit(<span class=\"number\">10</span>).forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">// 4.通过Stram.iterate方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Stream&lt;Integer&gt; iterate = Stream.iterate(<span class=\"number\">1</span>, x -&gt; x +<span class=\"number\">1</span>);</span><br><span class=\"line\">        iterate.forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 5.其他API</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">create5</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String str = <span class=\"string\">\"abc\"</span>;</span><br><span class=\"line\">        IntStream chars = str.chars();</span><br><span class=\"line\">        chars.forEach(x -&gt; System.out.println(x));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h1 id=\"2-Stream的常用操作-API\"><a href=\"#2-Stream的常用操作-API\" class=\"headerlink\" title=\"2.Stream的常用操作(API)\"></a>2.Stream的常用操作(API)</h1><h2 id=\"2-1-中间操作\"><a href=\"#2-1-中间操作\" class=\"headerlink\" title=\"2.1 中间操作\"></a>2.1 中间操作</h2><h3 id=\"2-1-1-filter过滤\"><a href=\"#2-1-1-filter过滤\" class=\"headerlink\" title=\"2.1.1 filter过滤\"></a>2.1.1 filter过滤</h3><p>接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。说白了就是给一个条件，filter会根据这个条件截取流中得数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testFilter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"comment\">//截取所有能被2整除得数据</span></span><br><span class=\"line\">    List&lt;Integer&gt; collect = integers.stream().filter(i -&gt; i % <span class=\"number\">2</span> == <span class=\"number\">0</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-2-distinct去重\"><a href=\"#2-1-2-distinct去重\" class=\"headerlink\" title=\"2.1.2 distinct去重\"></a>2.1.2 distinct去重</h3><p>返回一个元素各异（根据流所生成元素的hashCode和equals方法实现）的流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; collect = numbers.stream().distinct().collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3-sorted排序\"><a href=\"#2-1-3-sorted排序\" class=\"headerlink\" title=\"2.1.3 sorted排序\"></a>2.1.3 sorted排序</h3><p>对流中得数据进行排序，可以以自然序或着用Comparator接口定义的排序规则来排序一个流。Comparator能使用lambada表达式来初始化，还能够逆序一个已经排序的流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">6</span>, <span class=\"number\">41</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\">    <span class=\"comment\">//排序默认为顺序  顺序 = [2, 5, 6, 8, 11, 41]</span></span><br><span class=\"line\">    List&lt;Integer&gt; sorted = integers.stream().sorted().collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"顺序 = \"</span> + sorted);</span><br><span class=\"line\">    <span class=\"comment\">//逆序    逆序 = [41, 11, 8, 6, 5, 2]</span></span><br><span class=\"line\">    List&lt;Integer&gt; reverseOrder = integers.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"逆序 = \"</span> + reverseOrder);</span><br><span class=\"line\">    <span class=\"comment\">//也可以接收一个lambda</span></span><br><span class=\"line\">    List&lt;Integer&gt; ages = integers.stream().sorted(Comparator.comparing(User::getAge)).collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-4-limit截取\"><a href=\"#2-1-4-limit截取\" class=\"headerlink\" title=\"2.1.4 limit截取\"></a>2.1.4 limit截取</h3><p>会返回一个不超过给定长度的流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testLimit</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; collect = integers.stream().limit(<span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [1, 2, 1]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-5-skip舍弃\"><a href=\"#2-1-5-skip舍弃\" class=\"headerlink\" title=\"2.1.5 skip舍弃\"></a>2.1.5 skip舍弃</h3><p>会返回一个扔掉了前面n个元素的流。如果流中元素不足n个，则返回一个空流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testSkip</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"comment\">//丢掉流中得前三个元素  </span></span><br><span class=\"line\">    List&lt;Integer&gt; collect = integers.stream().skip(<span class=\"number\">3</span>).collect(Collectors.toList());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果: collect = [3, 3, 2, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-6-map归纳\"><a href=\"#2-1-6-map归纳\" class=\"headerlink\" title=\"2.1.6 map归纳\"></a>2.1.6 map归纳</h3><p>接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素。就是根据指定函数获取流中得每个元素得数据并重新组合成一个新的元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//自己建好得一个获取对象list得方法</span></span><br><span class=\"line\">    List&lt;Dish&gt; dishList = Dish.getDishList();</span><br><span class=\"line\">    <span class=\"comment\">//获取每一道菜得名称  并放到一个list中</span></span><br><span class=\"line\">    List&lt;String&gt; collect = dishList.stream().map(Dish::getName).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">//collect = [pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon]</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-7-flatMap扁平化\"><a href=\"#2-1-7-flatMap扁平化\" class=\"headerlink\" title=\"2.1.7 flatMap扁平化\"></a>2.1.7 flatMap扁平化</h3><p>该方法key可以让你把一个流中的每个值都换成另一个流，然后把所有的流都链接起来成为一个流。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    String[] words = &#123;<span class=\"string\">\"Hello\"</span>, <span class=\"string\">\"World\"</span>&#125;;</span><br><span class=\"line\">    List&lt;String&gt; collect = Stream.of(words).        <span class=\"comment\">//数组转换流</span></span><br><span class=\"line\">            map(w -&gt; w.split(<span class=\"string\">\"\"</span>)).  <span class=\"comment\">//去掉“”并获取到两个String[]</span></span><br><span class=\"line\">            flatMap(Arrays::stream).        <span class=\"comment\">//方法调用将两个String[]扁平化为一个stream</span></span><br><span class=\"line\">            distinct().                     <span class=\"comment\">//去重    </span></span><br><span class=\"line\">            collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">//collect = [H, e, l, o, W, r, d]</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-8-peek\"><a href=\"#2-1-8-peek\" class=\"headerlink\" title=\"2.1.8 peek\"></a>2.1.8 peek</h3><p>peek的设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; numbers = Arrays.asList(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    List&lt;Integer&gt; result =</span><br><span class=\"line\">            numbers.stream()</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"from stream: \"</span> + x))</span><br><span class=\"line\">                    .map(x -&gt; x + <span class=\"number\">17</span>)</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"after map: \"</span> + x))</span><br><span class=\"line\">                    .filter(x -&gt; x % <span class=\"number\">2</span> == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"after filter: \"</span> + x))</span><br><span class=\"line\">                    .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">                    .peek(x -&gt; System.out.println(<span class=\"string\">\"after limit: \"</span> + x))</span><br><span class=\"line\">                    .collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果：</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 2</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 19</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 3</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 20</span></span><br><span class=\"line\"><span class=\"comment\">//     after filter: 20</span></span><br><span class=\"line\"><span class=\"comment\">//     after limit: 20</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 4</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 21</span></span><br><span class=\"line\"><span class=\"comment\">//     from stream: 5</span></span><br><span class=\"line\"><span class=\"comment\">//     after map: 22</span></span><br><span class=\"line\"><span class=\"comment\">//     after filter: 22</span></span><br><span class=\"line\"><span class=\"comment\">//     after limit: 22</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-9-collect收集\"><a href=\"#2-1-9-collect收集\" class=\"headerlink\" title=\"2.1.9 collect收集\"></a>2.1.9 collect收集</h3><p>从上面得代码已经可以看出来，collect是将最终stream中得数据收集起来，最终生成一个list，set，或者map。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dishList = Dish.getDishList();</span><br><span class=\"line\">    <span class=\"comment\">// list</span></span><br><span class=\"line\">    List&lt;Dish&gt; collect = dishList.stream().limit(<span class=\"number\">2</span>).collect(Collectors.toList());</span><br><span class=\"line\">    <span class=\"comment\">// set</span></span><br><span class=\"line\">    Set&lt;Dish&gt; collect1 = dishList.stream().limit(<span class=\"number\">2</span>).collect(Collectors.toSet());</span><br><span class=\"line\">    <span class=\"comment\">// map</span></span><br><span class=\"line\">    Map&lt;String, Dish.Type&gt; collect2 = dishList.stream().limit(<span class=\"number\">2</span>).collect(Collectors.toMap(Dish::getName, Dish::getType));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-2-终止操作\"><a href=\"#2-2-终止操作\" class=\"headerlink\" title=\"2.2 终止操作\"></a>2.2 终止操作</h2><ul>\n<li>循环 forEach</li>\n<li>计算 min、max、count、average</li>\n<li>匹配 anyMatch、allMatch、noneMatch、findFirst、findAny</li>\n<li>汇聚 reduce</li>\n<li>收集器 collect</li>\n</ul>\n<h2 id=\"2-3-查找和匹配\"><a href=\"#2-3-查找和匹配\" class=\"headerlink\" title=\"2.3 查找和匹配\"></a>2.3 查找和匹配</h2><p>常见的数据处理套路是看看数据集中的某些元素是否匹配一个给定的属性。Stream API通过allMatch，anyMatch，noneMatch，findFirst和findAny方法提供了这样的工具。<br>查找和匹配都是终端操作。</p>\n<h3 id=\"2-3-1-anyMatch\"><a href=\"#2-3-1-anyMatch\" class=\"headerlink\" title=\"2.3.1 anyMatch\"></a>2.3.1 anyMatch</h3><p>anyMatch方法可以回答“流中是否有一个元素能匹配到给定的谓词”。会返回一个boolean值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnyMatch</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = dish.stream().anyMatch(Dish::isVegetarian);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-2-allMatch\"><a href=\"#2-3-2-allMatch\" class=\"headerlink\" title=\"2.3.2 allMatch\"></a>2.3.2 allMatch</h3><p>allMatch方法和anyMatch类似，校验流中是否都能匹配到给定的谓词。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AllMatch</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        <span class=\"comment\">//是否所有菜的热量都小于1000</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = dish.stream().allMatch(d -&gt; d.getCalories() &lt; <span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3-noneMatch\"><a href=\"#2-3-3-noneMatch\" class=\"headerlink\" title=\"2.3.3 noneMatch\"></a>2.3.3 noneMatch</h3><p>noneMatch方法可以确保流中没有任何元素与给定的谓词匹配。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoneMatch</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        <span class=\"comment\">//没有任何菜的热量大于等于1000</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = dish.stream().allMatch(d -&gt; d.getCalories() &gt;= <span class=\"number\">1000</span>);</span><br><span class=\"line\">        System.out.println(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>anyMatch</code>，<code>noneMatch</code>，<code>allMatch</code>这三个操作都用到了所谓的短路。</p>\n<h3 id=\"2-3-4-findAny\"><a href=\"#2-3-4-findAny\" class=\"headerlink\" title=\"2.3.4 findAny\"></a>2.3.4 findAny</h3><p>findAny方法将返回当前流中的符合过滤条件的任意元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindAny</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        Optional&lt;Dish&gt; any = dish.stream().filter(Dish::isVegetarian).findAny();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"any = \"</span> + any);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-5-findFirst\"><a href=\"#2-3-5-findFirst\" class=\"headerlink\" title=\"2.3.5 findFirst\"></a>2.3.5 findFirst</h3><p>findFirst方法能找到你想要的第一个元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FindFirst</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">        Optional&lt;Dish&gt; any = dish.stream().filter(Dish::isVegetarian).findFirst();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"any = \"</span> + any);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4-reduce-归约\"><a href=\"#2-4-reduce-归约\" class=\"headerlink\" title=\"2.4 reduce 归约\"></a>2.4 reduce 归约</h2><p>此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个 Integer 。这样的查询可以被归类为归约操作（将流归约成一个值）。用函数式编程语言的术语来说，这称为折叠（fold），因为你可以将这个操<br>作看成把一张长长的纸（你的流）反复折叠成一个小方块，而这就是折叠操作的结果。</p>\n<h3 id=\"2-4-1-元素求和\"><a href=\"#2-4-1-元素求和\" class=\"headerlink\" title=\"2.4.1 元素求和\"></a>2.4.1 元素求和</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"comment\">//求list中的和，以0为基数</span></span><br><span class=\"line\">    Integer reduce = integers.stream().reduce(<span class=\"number\">0</span>, (a, b) -&gt; a + b);</span><br><span class=\"line\">    <span class=\"comment\">//Integer的静态方法</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = integers.stream().reduce(<span class=\"number\">0</span>, Integer::sum);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"reduce = \"</span> + reduce);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-2-最大值和最小值\"><a href=\"#2-4-2-最大值和最小值\" class=\"headerlink\" title=\"2.4.2 最大值和最小值\"></a>2.4.2 最大值和最小值</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; integers = Arrays.asList(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>);</span><br><span class=\"line\">    Optional&lt;Integer&gt; min = integers.stream().reduce(Integer::min);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"min = \"</span> + min);</span><br><span class=\"line\">    Optional&lt;Integer&gt; max = integers.stream().reduce(Integer::max);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"max = \"</span> + max);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5-Collectors-收集器\"><a href=\"#2-5-Collectors-收集器\" class=\"headerlink\" title=\"2.5 Collectors 收集器\"></a>2.5 Collectors 收集器</h2><h3 id=\"2-5-1-查找流中的最大值和最小值-minBy-maxBy\"><a href=\"#2-5-1-查找流中的最大值和最小值-minBy-maxBy\" class=\"headerlink\" title=\"2.5.1 查找流中的最大值和最小值 minBy maxBy\"></a>2.5.1 查找流中的最大值和最小值 minBy maxBy</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//创建一个Comparator来进行比较  比较菜的卡路里</span></span><br><span class=\"line\">    Comparator&lt;Dish&gt; dishComparator = Comparator.comparingInt(Dish::getCalories);</span><br><span class=\"line\">    <span class=\"comment\">//maxBy选出最大值</span></span><br><span class=\"line\">    Optional&lt;Dish&gt; collect = dish.stream().collect(Collectors.maxBy(dishComparator));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">    <span class=\"comment\">//选出最小值</span></span><br><span class=\"line\">    Optional&lt;Dish&gt; collect1 = dish.stream().collect(Collectors.minBy(dishComparator));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect1 = \"</span> + collect1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-2-汇总-summingInt\"><a href=\"#2-5-2-汇总-summingInt\" class=\"headerlink\" title=\"2.5.2 汇总 summingInt\"></a>2.5.2 汇总 summingInt</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//计算总和</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> collect = dish.stream().collect(Collectors.summingInt(Dish::getCalories));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-3-平均数-averagingInt\"><a href=\"#2-5-3-平均数-averagingInt\" class=\"headerlink\" title=\"2.5.3 平均数 averagingInt\"></a>2.5.3 平均数 averagingInt</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//计算平均数</span></span><br><span class=\"line\">    Double collect = dish.stream().collect(Collectors.averagingInt(Dish::getCalories));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-4-连接字符串-joining\"><a href=\"#2-5-4-连接字符串-joining\" class=\"headerlink\" title=\"2.5.4 连接字符串 joining\"></a>2.5.4 连接字符串 joining</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    String collect = dish.stream().map(Dish::getName).collect(Collectors.joining());</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>joining 工厂方法有一个重载版本可以接受元素之间的分界符，这样你就可以得到一个逗号分隔的菜肴名称列表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String collect = dish.stream().map(Dish::getName).collect(Collectors.joining(<span class=\"string\">\", \"</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-5-5-得到流中的总数-counting\"><a href=\"#2-5-5-得到流中的总数-counting\" class=\"headerlink\" title=\"2.5.5 得到流中的总数 counting\"></a>2.5.5 得到流中的总数 counting</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">long</span> howManyDishes = dish.stream().collect(Collectors.counting());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-6-分组\"><a href=\"#2-6-分组\" class=\"headerlink\" title=\"2.6 分组\"></a>2.6 分组</h2><h3 id=\"2-6-1-分组-groupingBy\"><a href=\"#2-6-1-分组-groupingBy\" class=\"headerlink\" title=\"2.6.1 分组 groupingBy\"></a>2.6.1 分组 groupingBy</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    <span class=\"comment\">//groupingBy接受一个function作为参数</span></span><br><span class=\"line\">    Map&lt;Dish.Type, List&lt;Dish&gt;&gt; collect = dish.stream().collect(Collectors.groupingBy(Dish::getType));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果想用以分类的条件可能比简单的属性访问器要复杂。例如，你可能想把热量不到400卡路里的菜划分为“低热量”（diet），热量400到700卡路里的菜划为“普通”（normal），高于700卡路里的划为“高热量”（fat）。由于Dish类的作者没有把这个操作写成一个方法，你无法使用方法引用，但你可以把这个逻辑写成Lambda表达式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dishList = Dish.getDish();</span><br><span class=\"line\">    Map&lt;String, List&lt;Dish&gt;&gt; collect = dishList.stream().collect(Collectors.groupingBy(dish-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dish.getCalories() &lt;= <span class=\"number\">400</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"DIET\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (dish.getCalories() &lt;= <span class=\"number\">700</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"NORMAL\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"FAT\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-6-2-多级分组\"><a href=\"#2-6-2-多级分组\" class=\"headerlink\" title=\"2.6.2 多级分组\"></a>2.6.2 多级分组</h3><p>要实现多级分组，我们可以使用一个由双参数版本的Collectors.groupingBy工厂方法创建的收集器，它除了普通的分类函数之外，还可以接受collector类型的第二个参数。那么要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Dish&gt; dish = Dish.getDish();</span><br><span class=\"line\">    Map&lt;Dish.Type, Map&lt;String, List&lt;Dish&gt;&gt;&gt; collect = dish.stream().collect(Collectors.groupingBy(Dish::getType, Collectors.groupingBy(d -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (d.getCalories() &lt;= <span class=\"number\">400</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"DIET\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (d.getCalories() &lt;= <span class=\"number\">700</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"NORMAL\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"FAT\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)));</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"collect = \"</span> + collect);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-6-3-按子组收集数据\"><a href=\"#2-6-3-按子组收集数据\" class=\"headerlink\" title=\"2.6.3 按子组收集数据\"></a>2.6.3 按子组收集数据</h3><p>在上一面，我们看到可以把第二个groupingBy收集器传递给外层收集器来实现多级分组。但进一步说，传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy。</p>\n<p>例如，要数一数菜单中每类菜有多少个，可以传递counting收集器作为groupingBy收集器的第二个参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Dish.Type, Long&gt; typesCount = dish.stream().collect(groupingBy(Dish::getType, counting()));</span><br></pre></td></tr></table></figure>\n<p>普通的单参数groupingBy(f)（其中<code>f</code>是分类函数）实际上是 groupingBy(f,toList()) 的简便写法。</p>\n<h1 id=\"3-并行流\"><a href=\"#3-并行流\" class=\"headerlink\" title=\"3 并行流\"></a>3 并行流</h1><p>并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。这样一来，你就可以自动把给定操作的工作负荷分配给多核处理器的所有内核，让它们都忙起来。</p>\n<h2 id=\"3-1-将顺序流转为并行流\"><a href=\"#3-1-将顺序流转为并行流\" class=\"headerlink\" title=\"3.1 将顺序流转为并行流\"></a>3.1 将顺序流转为并行流</h2><p>可以把流转换成并行流，从而让前面的函数归约过程（也就是求和）并行运行——对顺序流调用 parallel 方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">parallelSum</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Stream.iterate(<span class=\"number\">1L</span>, i -&gt; i + <span class=\"number\">1</span>)</span><br><span class=\"line\">            .limit(n)</span><br><span class=\"line\">            .parallel()</span><br><span class=\"line\">            .reduce(<span class=\"number\">0L</span>, Long::sum);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Stream在内部分成了几块。因此可以对不同的块独立并行进行归纳操作，最后，同一个归纳操作会将各个子流的部分归纳结果合并起来，得到整个原始流的归纳结果。<br><img src=\"/image/java8Stream.jpg\" alt=\"Stream并行流\"><br>类似地，你只需要对并行流调用 sequential 方法就可以把它变成顺序流。</p>\n<p>看看流的parallel方法，你可能会想，并行流用的线程是从哪儿来的？有多少个？怎么自定义这个过程呢？<br>并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available-Processors()得到的。</p>\n<p>但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common.parallelism来改变线程池大小，如下所示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.setProperty(<span class=\"string\">\"java.util.concurrent.ForkJoinPool.common.parallelism\"</span>,<span class=\"string\">\"12\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议你不要修改它。</p>\n<h2 id=\"3-2-分支-合并框架\"><a href=\"#3-2-分支-合并框架\" class=\"headerlink\" title=\"3.2 分支/合并框架\"></a>3.2 分支/合并框架</h2><p>分支/合并框架的目的是以递归方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，它把子任务分配给线程池（称为ForkJoinPool）中的工作线程。</p>\n<h3 id=\"3-2-1-使用RecursiveTask\"><a href=\"#3-2-1-使用RecursiveTask\" class=\"headerlink\" title=\"3.2.1 使用RecursiveTask\"></a>3.2.1 使用RecursiveTask</h3><p>要把任务提交到这个池，必须创建RecursiveTask的一个子类，其中R是并行化任务（以<br>及所有子任务）产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型（当<br>然它可能会更新其他非局部机构）。<br>要定义RecursiveTask，只需实现它唯一的抽象方法compute ：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> R <span class=\"title\">compute</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这个方法同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。</p>\n<h3 id=\"3-2-2-使用RecursiveTask求和\"><a href=\"#3-2-2-使用RecursiveTask求和\" class=\"headerlink\" title=\"3.2.2 使用RecursiveTask求和\"></a>3.2.2 使用RecursiveTask求和</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForkJoinSumCalculator</span></span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">extends</span> <span class=\"title\">java</span>.<span class=\"title\">util</span>.<span class=\"title\">concurrent</span>.<span class=\"title\">RecursiveTask</span>&lt;<span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] numbers;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> start;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> end;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> THRESHOLD = <span class=\"number\">10_000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(numbers, <span class=\"number\">0</span>, numbers.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">ForkJoinSumCalculator</span><span class=\"params\">(<span class=\"keyword\">long</span>[] numbers, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.numbers = numbers;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.end = end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Long <span class=\"title\">compute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = end - start;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt;= THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> computeSequentially();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//创建一个子任务来为数组得前一半求和</span></span><br><span class=\"line\">        ForkJoinSumCalculator leftTask =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ForkJoinSumCalculator(numbers, start, start + length / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">//利 用 另 一 个ForkJoinPool线程异步执行新创建的子任务</span></span><br><span class=\"line\">        leftTask.fork();</span><br><span class=\"line\">        <span class=\"comment\">//创建一个子任务来为数组得后一半求和</span></span><br><span class=\"line\">        ForkJoinSumCalculator rightTask =</span><br><span class=\"line\">                <span class=\"keyword\">new</span> ForkJoinSumCalculator(numbers, start + length / <span class=\"number\">2</span>, end);</span><br><span class=\"line\">        <span class=\"comment\">//同步执行第二个子任务，有可能进一步递归</span></span><br><span class=\"line\">        Long rightResult = rightTask.compute();</span><br><span class=\"line\">        <span class=\"comment\">//读取第一个任务得结构，未完成就等待</span></span><br><span class=\"line\">        Long leftResult = leftTask.join();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftResult + rightResult;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">computeSequentially</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class=\"line\">            sum += numbers[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">forkJoinSum</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span>[] numbers = LongStream.rangeClosed(<span class=\"number\">1</span>, n).toArray();</span><br><span class=\"line\">        ForkJoinTask&lt;Long&gt; task = <span class=\"keyword\">new</span> ForkJoinSumCalculator(numbers);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ForkJoinPool().invoke(task);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> l = ForkJoinSumCalculator.forkJoinSum(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"l = \"</span> + l);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"使用Nexus搭建Maven私服(Nexus Repository Manager 3.X)","date":"2019-06-27T03:15:00.000Z","notshow":true,"_content":"# 1.前言\n关于Java项目，一般的公司都会有一个自己的私服来管理各种jar包，其中可能有这么几个原因:\n- 1、不能访问外网，只能通过私服来管理jar包和插件；\n- 2、网速比较慢，通过公司的私服来获取jar包比较快(内网)；\n- 3、内部的的一些jar包放在私服上，比较方便的大家使用。\n<!-- more -->\n# 2.下载与安装\n## 2.1 下载\n这里我会选择nexus最新的3.X的版本去进行搭建。\n[下载地址](https://help.sonatype.com/repomanager3/download)，\n下载可以选择对应的版本有macOS，Windows，unix等不同版本，可以根据自己需要选择。unix版本是支持linux系统的，所以这也是没有linux版本的原因。这里我选择的是unix版本3.17.0-01。\n\n**注意**: Nexus Repository Manager 3.X是一个Java服务器应用程序，安装需要 jdk1.8以上的版本。\n\n## 2.2 安装\n这里我是因为从本机下载，nexus需要安装在服务器上，所以我会多出一步将本地下载文件上传至服务器的步骤。\n### 2.2.1 上传tar.gz文件至服务器(文件已在服务器可忽略)\n以下命令中`xxx.xxx.xxx.xxx`修改为自己服务器的ip地址即可。\n```shell\n$ scp ./nexus-3.17.0-01-unix.tar.gz root@xxx.xxx.xxx.xxx:/data/nexus/\n```\n\n### 2.2.2 解压文件\n首先登陆进入服务器进入刚刚上传的目录，然后开始解压文件。\n```shell\n$ cd /data/nexus;\n$ tar zxvf nexus-3.17.0-01-unix.tar.gz\n```\n\n### 2.2.3 启动nexus\n进入到解压文件的bin目录下，执行`./nexus run`命令即可。\n```shell\n& cd /data/nexus/nexus-3.17.0-01/bin;\n& nohup ./nexus run &\n```\n注意: 在启动时可能出现内存不足的问题，可根据一下方式解决:\nbin目录下有一个nexus.vmoptions文件，编辑它，修改内存的参数适合你的服务器即可。\n```shell\n\n```\n\n# 3. 访问Nexus管理后台\nNexus管理后台地址的默认地址是:[http://localhost:8081/](http://localhost:8081/),点击右上角Sign in登录，默认账号和密码为：admin/admin123。\n\n在Repositories仓库管理界面中有多种默认的仓库，也可以添加新的仓库，本实例直接使用默认的仓库：\nmaven-central，Type为proxy，表示代理仓库。代理仓库用来代理远程仓库（maven-central代理的是超级POM中配置的Maven中央仓库），当在下载组件时，如果代理仓库搜索不到，则会把请求转发到远程仓库从远程仓库下载。从远程仓库下载后会缓存到代理仓库，下次还有该组件的请求则会直接到代理仓库下载，不会再次请求远程仓库。\n\nmaven-releases/maven-snapshots，Type为hosted，表示为宿主仓库。宿主仓库主要用来部署团队内部使用的内部组件，默认的maven-releases和maven-snapshots分别用来部署团队内部的发布版本组件和快照版本组件。\n\n# 4. 配置使用\n## 4.1 配置settings.xml\n```xml\n<settings>\n   <!-- 配置镜像，此处拦截所有远程仓库的请求到代理仓库-->\n  <mirrors>\n    <mirror>\n      <id>nexus</id>\n      <mirrorOf>*</mirrorOf>\n      <url>http://localhost:8081/repository/maven-central/</url>\n    </mirror>\n  </mirrors>\n  <!-- 配置远程库和远程插件库-->\n  <profiles>\n    <profile>\n      <id>nexus</id>\n      <!-- Maven用于填充构建系统本地存储库的远程仓库集合-->\n      <repositories>\n        <repository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </repository>\n      </repositories>\n     <!-- 类似于repositories元素，指定Maven可以在哪里找到Maven插件的远程仓库位置-->\n     <pluginRepositories>\n        <pluginRepository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </pluginRepository>\n      </pluginRepositories>\n    </profile>\n  </profiles>\n  <!-- 激活profiles配置 -->\n  <activeProfiles>\n    <activeProfile>nexus</activeProfile>\n  </activeProfiles>\n</settings>\n```\n\n## 4.2 创建Maven项目配置pom.xml\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.jiafly</groupId>\n  <artifactId>libra-api</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <packaging>jar</packaging>\n\n  <name>libra-api</name>\n  <url>http://maven.apache.org</url>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n```\n配置完成后，执行mvn clean，执行mvn clean需要下载maven-clean-plugin插件，通过Browse界面可以看到因为执行mvn clean而下载的maven-clean-plugin.jar：\n\n## 4.3 配置宿主仓库\n在setting.xml文件中增加如下配置:\n```xml\n<servers>\n     <server>\n        <id>nexus</id>\n        <username>admin</username>\n        <password>admin123</password>\n    </server>\n</servers>\n```\n然后再配置pom.xml文件\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.jiafly</groupId>\n  <artifactId>libra-api</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <packaging>jar</packaging>\n\n  <name>libra-api</name>\n  <url>http://maven.apache.org</url>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <distributionManagement>\n        <repository>\n        <id>nexus</id>\n        <name>maven-releases</name>\n        <url>http://localhost:8081/repository/maven-releases/</url>\n        </repository>\n        <snapshotRepository>\n        <id>nexus</id>\n        <name>maven-snapshots</name>\n        <url>http://localhost:8081/repository/maven-snapshots/</url>\n        </snapshotRepository>\n   </distributionManagement>\n</project>\n```\n执行mvn clean deploy将项目打包并发布到宿主仓库，构建成功后到Browse中maven-snapshots库查看（因为项目版本为0.0.1-SNAPSHOT，是带SNAPSHOT的快照版本）。\n\n**注意**：maven-releases库默认不能重新发布，需要可重新发布则需要修改该仓库配置或者删除已经发布的版本。\n\n**修改配置重新发布**：将maven-releases库中Deployment pollcy改为Allow redeploy既可。\n\n# 5.结语\nMaven对于Javaer说，几乎是天天与其打交道，所以很有必要去了解如果搭建自己的Maven私服仓库。平时多培养自己的动手实践能力，才能在用到的时候不慌。\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。\n\n\n\n\n","source":"_posts/java/使用Nexus搭建Maven私服.md","raw":"---\ntitle: 使用Nexus搭建Maven私服(Nexus Repository Manager 3.X)\ndate: 2019-06-27 11:15:00\ntags:\n    - Maven\n    - Nexus\ncategories:\n    - Maven\nnotshow: true\n---\n# 1.前言\n关于Java项目，一般的公司都会有一个自己的私服来管理各种jar包，其中可能有这么几个原因:\n- 1、不能访问外网，只能通过私服来管理jar包和插件；\n- 2、网速比较慢，通过公司的私服来获取jar包比较快(内网)；\n- 3、内部的的一些jar包放在私服上，比较方便的大家使用。\n<!-- more -->\n# 2.下载与安装\n## 2.1 下载\n这里我会选择nexus最新的3.X的版本去进行搭建。\n[下载地址](https://help.sonatype.com/repomanager3/download)，\n下载可以选择对应的版本有macOS，Windows，unix等不同版本，可以根据自己需要选择。unix版本是支持linux系统的，所以这也是没有linux版本的原因。这里我选择的是unix版本3.17.0-01。\n\n**注意**: Nexus Repository Manager 3.X是一个Java服务器应用程序，安装需要 jdk1.8以上的版本。\n\n## 2.2 安装\n这里我是因为从本机下载，nexus需要安装在服务器上，所以我会多出一步将本地下载文件上传至服务器的步骤。\n### 2.2.1 上传tar.gz文件至服务器(文件已在服务器可忽略)\n以下命令中`xxx.xxx.xxx.xxx`修改为自己服务器的ip地址即可。\n```shell\n$ scp ./nexus-3.17.0-01-unix.tar.gz root@xxx.xxx.xxx.xxx:/data/nexus/\n```\n\n### 2.2.2 解压文件\n首先登陆进入服务器进入刚刚上传的目录，然后开始解压文件。\n```shell\n$ cd /data/nexus;\n$ tar zxvf nexus-3.17.0-01-unix.tar.gz\n```\n\n### 2.2.3 启动nexus\n进入到解压文件的bin目录下，执行`./nexus run`命令即可。\n```shell\n& cd /data/nexus/nexus-3.17.0-01/bin;\n& nohup ./nexus run &\n```\n注意: 在启动时可能出现内存不足的问题，可根据一下方式解决:\nbin目录下有一个nexus.vmoptions文件，编辑它，修改内存的参数适合你的服务器即可。\n```shell\n\n```\n\n# 3. 访问Nexus管理后台\nNexus管理后台地址的默认地址是:[http://localhost:8081/](http://localhost:8081/),点击右上角Sign in登录，默认账号和密码为：admin/admin123。\n\n在Repositories仓库管理界面中有多种默认的仓库，也可以添加新的仓库，本实例直接使用默认的仓库：\nmaven-central，Type为proxy，表示代理仓库。代理仓库用来代理远程仓库（maven-central代理的是超级POM中配置的Maven中央仓库），当在下载组件时，如果代理仓库搜索不到，则会把请求转发到远程仓库从远程仓库下载。从远程仓库下载后会缓存到代理仓库，下次还有该组件的请求则会直接到代理仓库下载，不会再次请求远程仓库。\n\nmaven-releases/maven-snapshots，Type为hosted，表示为宿主仓库。宿主仓库主要用来部署团队内部使用的内部组件，默认的maven-releases和maven-snapshots分别用来部署团队内部的发布版本组件和快照版本组件。\n\n# 4. 配置使用\n## 4.1 配置settings.xml\n```xml\n<settings>\n   <!-- 配置镜像，此处拦截所有远程仓库的请求到代理仓库-->\n  <mirrors>\n    <mirror>\n      <id>nexus</id>\n      <mirrorOf>*</mirrorOf>\n      <url>http://localhost:8081/repository/maven-central/</url>\n    </mirror>\n  </mirrors>\n  <!-- 配置远程库和远程插件库-->\n  <profiles>\n    <profile>\n      <id>nexus</id>\n      <!-- Maven用于填充构建系统本地存储库的远程仓库集合-->\n      <repositories>\n        <repository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </repository>\n      </repositories>\n     <!-- 类似于repositories元素，指定Maven可以在哪里找到Maven插件的远程仓库位置-->\n     <pluginRepositories>\n        <pluginRepository>\n          <id>central</id>\n          <url>http://central</url>\n          <releases><enabled>true</enabled></releases>\n          <snapshots><enabled>true</enabled></snapshots>\n        </pluginRepository>\n      </pluginRepositories>\n    </profile>\n  </profiles>\n  <!-- 激活profiles配置 -->\n  <activeProfiles>\n    <activeProfile>nexus</activeProfile>\n  </activeProfiles>\n</settings>\n```\n\n## 4.2 创建Maven项目配置pom.xml\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.jiafly</groupId>\n  <artifactId>libra-api</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <packaging>jar</packaging>\n\n  <name>libra-api</name>\n  <url>http://maven.apache.org</url>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n```\n配置完成后，执行mvn clean，执行mvn clean需要下载maven-clean-plugin插件，通过Browse界面可以看到因为执行mvn clean而下载的maven-clean-plugin.jar：\n\n## 4.3 配置宿主仓库\n在setting.xml文件中增加如下配置:\n```xml\n<servers>\n     <server>\n        <id>nexus</id>\n        <username>admin</username>\n        <password>admin123</password>\n    </server>\n</servers>\n```\n然后再配置pom.xml文件\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.jiafly</groupId>\n  <artifactId>libra-api</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <packaging>jar</packaging>\n\n  <name>libra-api</name>\n  <url>http://maven.apache.org</url>\n\n  <dependencies>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>3.8.1</version>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n\n  <distributionManagement>\n        <repository>\n        <id>nexus</id>\n        <name>maven-releases</name>\n        <url>http://localhost:8081/repository/maven-releases/</url>\n        </repository>\n        <snapshotRepository>\n        <id>nexus</id>\n        <name>maven-snapshots</name>\n        <url>http://localhost:8081/repository/maven-snapshots/</url>\n        </snapshotRepository>\n   </distributionManagement>\n</project>\n```\n执行mvn clean deploy将项目打包并发布到宿主仓库，构建成功后到Browse中maven-snapshots库查看（因为项目版本为0.0.1-SNAPSHOT，是带SNAPSHOT的快照版本）。\n\n**注意**：maven-releases库默认不能重新发布，需要可重新发布则需要修改该仓库配置或者删除已经发布的版本。\n\n**修改配置重新发布**：将maven-releases库中Deployment pollcy改为Allow redeploy既可。\n\n# 5.结语\nMaven对于Javaer说，几乎是天天与其打交道，所以很有必要去了解如果搭建自己的Maven私服仓库。平时多培养自己的动手实践能力，才能在用到的时候不慌。\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。\n\n\n\n\n","slug":"java/使用Nexus搭建Maven私服","published":1,"updated":"2019-09-05T03:35:33.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcor000qjfusbd4w3w7i","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>关于Java项目，一般的公司都会有一个自己的私服来管理各种jar包，其中可能有这么几个原因:</p>\n<ul>\n<li>1、不能访问外网，只能通过私服来管理jar包和插件；</li>\n<li>2、网速比较慢，通过公司的私服来获取jar包比较快(内网)；</li>\n<li>3、内部的的一些jar包放在私服上，比较方便的大家使用。<a id=\"more\"></a>\n<h1 id=\"2-下载与安装\"><a href=\"#2-下载与安装\" class=\"headerlink\" title=\"2.下载与安装\"></a>2.下载与安装</h1><h2 id=\"2-1-下载\"><a href=\"#2-1-下载\" class=\"headerlink\" title=\"2.1 下载\"></a>2.1 下载</h2>这里我会选择nexus最新的3.X的版本去进行搭建。<br><a href=\"https://help.sonatype.com/repomanager3/download\" target=\"_blank\" rel=\"noopener\">下载地址</a>，<br>下载可以选择对应的版本有macOS，Windows，unix等不同版本，可以根据自己需要选择。unix版本是支持linux系统的，所以这也是没有linux版本的原因。这里我选择的是unix版本3.17.0-01。</li>\n</ul>\n<p><strong>注意</strong>: Nexus Repository Manager 3.X是一个Java服务器应用程序，安装需要 jdk1.8以上的版本。</p>\n<h2 id=\"2-2-安装\"><a href=\"#2-2-安装\" class=\"headerlink\" title=\"2.2 安装\"></a>2.2 安装</h2><p>这里我是因为从本机下载，nexus需要安装在服务器上，所以我会多出一步将本地下载文件上传至服务器的步骤。</p>\n<h3 id=\"2-2-1-上传tar-gz文件至服务器-文件已在服务器可忽略\"><a href=\"#2-2-1-上传tar-gz文件至服务器-文件已在服务器可忽略\" class=\"headerlink\" title=\"2.2.1 上传tar.gz文件至服务器(文件已在服务器可忽略)\"></a>2.2.1 上传tar.gz文件至服务器(文件已在服务器可忽略)</h3><p>以下命令中<code>xxx.xxx.xxx.xxx</code>修改为自己服务器的ip地址即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> scp ./nexus-3.17.0-01-unix.tar.gz root@xxx.xxx.xxx.xxx:/data/nexus/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-解压文件\"><a href=\"#2-2-2-解压文件\" class=\"headerlink\" title=\"2.2.2 解压文件\"></a>2.2.2 解压文件</h3><p>首先登陆进入服务器进入刚刚上传的目录，然后开始解压文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /data/nexus;</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar zxvf nexus-3.17.0-01-unix.tar.gz</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-3-启动nexus\"><a href=\"#2-2-3-启动nexus\" class=\"headerlink\" title=\"2.2.3 启动nexus\"></a>2.2.3 启动nexus</h3><p>进入到解压文件的bin目录下，执行<code>./nexus run</code>命令即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; cd /data/nexus/nexus-3.17.0-01/bin;</span><br><span class=\"line\">&amp; nohup ./nexus run &amp;</span><br></pre></td></tr></table></figure>\n<p>注意: 在启动时可能出现内存不足的问题，可根据一下方式解决:<br>bin目录下有一个nexus.vmoptions文件，编辑它，修改内存的参数适合你的服务器即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-访问Nexus管理后台\"><a href=\"#3-访问Nexus管理后台\" class=\"headerlink\" title=\"3. 访问Nexus管理后台\"></a>3. 访问Nexus管理后台</h1><p>Nexus管理后台地址的默认地址是:<a href=\"http://localhost:8081/\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/</a>,点击右上角Sign in登录，默认账号和密码为：admin/admin123。</p>\n<p>在Repositories仓库管理界面中有多种默认的仓库，也可以添加新的仓库，本实例直接使用默认的仓库：<br>maven-central，Type为proxy，表示代理仓库。代理仓库用来代理远程仓库（maven-central代理的是超级POM中配置的Maven中央仓库），当在下载组件时，如果代理仓库搜索不到，则会把请求转发到远程仓库从远程仓库下载。从远程仓库下载后会缓存到代理仓库，下次还有该组件的请求则会直接到代理仓库下载，不会再次请求远程仓库。</p>\n<p>maven-releases/maven-snapshots，Type为hosted，表示为宿主仓库。宿主仓库主要用来部署团队内部使用的内部组件，默认的maven-releases和maven-snapshots分别用来部署团队内部的发布版本组件和快照版本组件。</p>\n<h1 id=\"4-配置使用\"><a href=\"#4-配置使用\" class=\"headerlink\" title=\"4. 配置使用\"></a>4. 配置使用</h1><h2 id=\"4-1-配置settings-xml\"><a href=\"#4-1-配置settings-xml\" class=\"headerlink\" title=\"4.1 配置settings.xml\"></a>4.1 配置settings.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- 配置镜像，此处拦截所有远程仓库的请求到代理仓库--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://localhost:8081/repository/maven-central/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 配置远程库和远程插件库--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Maven用于填充构建系统本地存储库的远程仓库集合--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://central<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- 类似于repositories元素，指定Maven可以在哪里找到Maven插件的远程仓库位置--&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">pluginRepository</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://central<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">pluginRepository</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 激活profiles配置 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">activeProfiles</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">activeProfile</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">activeProfile</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">activeProfiles</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-创建Maven项目配置pom-xml\"><a href=\"#4-2-创建Maven项目配置pom-xml\" class=\"headerlink\" title=\"4.2 创建Maven项目配置pom.xml\"></a>4.2 创建Maven项目配置pom.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.jiafly<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.apache.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置完成后，执行mvn clean，执行mvn clean需要下载maven-clean-plugin插件，通过Browse界面可以看到因为执行mvn clean而下载的maven-clean-plugin.jar：</p>\n<h2 id=\"4-3-配置宿主仓库\"><a href=\"#4-3-配置宿主仓库\" class=\"headerlink\" title=\"4.3 配置宿主仓库\"></a>4.3 配置宿主仓库</h2><p>在setting.xml文件中增加如下配置:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servers</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>admin<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>admin123<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后再配置pom.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.jiafly<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.apache.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>maven-releases<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://localhost:8081/repository/maven-releases/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>maven-snapshots<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>执行mvn clean deploy将项目打包并发布到宿主仓库，构建成功后到Browse中maven-snapshots库查看（因为项目版本为0.0.1-SNAPSHOT，是带SNAPSHOT的快照版本）。</p>\n<p><strong>注意</strong>：maven-releases库默认不能重新发布，需要可重新发布则需要修改该仓库配置或者删除已经发布的版本。</p>\n<p><strong>修改配置重新发布</strong>：将maven-releases库中Deployment pollcy改为Allow redeploy既可。</p>\n<h1 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5.结语\"></a>5.结语</h1><p>Maven对于Javaer说，几乎是天天与其打交道，所以很有必要去了解如果搭建自己的Maven私服仓库。平时多培养自己的动手实践能力，才能在用到的时候不慌。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>关于Java项目，一般的公司都会有一个自己的私服来管理各种jar包，其中可能有这么几个原因:</p>\n<ul>\n<li>1、不能访问外网，只能通过私服来管理jar包和插件；</li>\n<li>2、网速比较慢，通过公司的私服来获取jar包比较快(内网)；</li>\n<li>3、内部的的一些jar包放在私服上，比较方便的大家使用。","more":"<h1 id=\"2-下载与安装\"><a href=\"#2-下载与安装\" class=\"headerlink\" title=\"2.下载与安装\"></a>2.下载与安装</h1><h2 id=\"2-1-下载\"><a href=\"#2-1-下载\" class=\"headerlink\" title=\"2.1 下载\"></a>2.1 下载</h2>这里我会选择nexus最新的3.X的版本去进行搭建。<br><a href=\"https://help.sonatype.com/repomanager3/download\" target=\"_blank\" rel=\"noopener\">下载地址</a>，<br>下载可以选择对应的版本有macOS，Windows，unix等不同版本，可以根据自己需要选择。unix版本是支持linux系统的，所以这也是没有linux版本的原因。这里我选择的是unix版本3.17.0-01。</li>\n</ul>\n<p><strong>注意</strong>: Nexus Repository Manager 3.X是一个Java服务器应用程序，安装需要 jdk1.8以上的版本。</p>\n<h2 id=\"2-2-安装\"><a href=\"#2-2-安装\" class=\"headerlink\" title=\"2.2 安装\"></a>2.2 安装</h2><p>这里我是因为从本机下载，nexus需要安装在服务器上，所以我会多出一步将本地下载文件上传至服务器的步骤。</p>\n<h3 id=\"2-2-1-上传tar-gz文件至服务器-文件已在服务器可忽略\"><a href=\"#2-2-1-上传tar-gz文件至服务器-文件已在服务器可忽略\" class=\"headerlink\" title=\"2.2.1 上传tar.gz文件至服务器(文件已在服务器可忽略)\"></a>2.2.1 上传tar.gz文件至服务器(文件已在服务器可忽略)</h3><p>以下命令中<code>xxx.xxx.xxx.xxx</code>修改为自己服务器的ip地址即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> scp ./nexus-3.17.0-01-unix.tar.gz root@xxx.xxx.xxx.xxx:/data/nexus/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-2-解压文件\"><a href=\"#2-2-2-解压文件\" class=\"headerlink\" title=\"2.2.2 解压文件\"></a>2.2.2 解压文件</h3><p>首先登陆进入服务器进入刚刚上传的目录，然后开始解压文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /data/nexus;</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> tar zxvf nexus-3.17.0-01-unix.tar.gz</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-3-启动nexus\"><a href=\"#2-2-3-启动nexus\" class=\"headerlink\" title=\"2.2.3 启动nexus\"></a>2.2.3 启动nexus</h3><p>进入到解压文件的bin目录下，执行<code>./nexus run</code>命令即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp; cd /data/nexus/nexus-3.17.0-01/bin;</span><br><span class=\"line\">&amp; nohup ./nexus run &amp;</span><br></pre></td></tr></table></figure>\n<p>注意: 在启动时可能出现内存不足的问题，可根据一下方式解决:<br>bin目录下有一个nexus.vmoptions文件，编辑它，修改内存的参数适合你的服务器即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-访问Nexus管理后台\"><a href=\"#3-访问Nexus管理后台\" class=\"headerlink\" title=\"3. 访问Nexus管理后台\"></a>3. 访问Nexus管理后台</h1><p>Nexus管理后台地址的默认地址是:<a href=\"http://localhost:8081/\" target=\"_blank\" rel=\"noopener\">http://localhost:8081/</a>,点击右上角Sign in登录，默认账号和密码为：admin/admin123。</p>\n<p>在Repositories仓库管理界面中有多种默认的仓库，也可以添加新的仓库，本实例直接使用默认的仓库：<br>maven-central，Type为proxy，表示代理仓库。代理仓库用来代理远程仓库（maven-central代理的是超级POM中配置的Maven中央仓库），当在下载组件时，如果代理仓库搜索不到，则会把请求转发到远程仓库从远程仓库下载。从远程仓库下载后会缓存到代理仓库，下次还有该组件的请求则会直接到代理仓库下载，不会再次请求远程仓库。</p>\n<p>maven-releases/maven-snapshots，Type为hosted，表示为宿主仓库。宿主仓库主要用来部署团队内部使用的内部组件，默认的maven-releases和maven-snapshots分别用来部署团队内部的发布版本组件和快照版本组件。</p>\n<h1 id=\"4-配置使用\"><a href=\"#4-配置使用\" class=\"headerlink\" title=\"4. 配置使用\"></a>4. 配置使用</h1><h2 id=\"4-1-配置settings-xml\"><a href=\"#4-1-配置settings-xml\" class=\"headerlink\" title=\"4.1 配置settings.xml\"></a>4.1 配置settings.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">   <span class=\"comment\">&lt;!-- 配置镜像，此处拦截所有远程仓库的请求到代理仓库--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://localhost:8081/repository/maven-central/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 配置远程库和远程插件库--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- Maven用于填充构建系统本地存储库的远程仓库集合--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://central<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- 类似于repositories元素，指定Maven可以在哪里找到Maven插件的远程仓库位置--&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">pluginRepositories</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">pluginRepository</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://central<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">releases</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">releases</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">snapshots</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">enabled</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">enabled</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">snapshots</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">pluginRepository</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">pluginRepositories</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 激活profiles配置 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">activeProfiles</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">activeProfile</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">activeProfile</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">activeProfiles</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2-创建Maven项目配置pom-xml\"><a href=\"#4-2-创建Maven项目配置pom-xml\" class=\"headerlink\" title=\"4.2 创建Maven项目配置pom.xml\"></a>4.2 创建Maven项目配置pom.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.jiafly<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.apache.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置完成后，执行mvn clean，执行mvn clean需要下载maven-clean-plugin插件，通过Browse界面可以看到因为执行mvn clean而下载的maven-clean-plugin.jar：</p>\n<h2 id=\"4-3-配置宿主仓库\"><a href=\"#4-3-配置宿主仓库\" class=\"headerlink\" title=\"4.3 配置宿主仓库\"></a>4.3 配置宿主仓库</h2><p>在setting.xml文件中增加如下配置:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servers</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>admin<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>admin123<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后再配置pom.xml文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0\"</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">  <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.jiafly<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>libra-api<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://maven.apache.org<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>maven-releases<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://localhost:8081/repository/maven-releases/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>nexus<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>maven-snapshots<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>执行mvn clean deploy将项目打包并发布到宿主仓库，构建成功后到Browse中maven-snapshots库查看（因为项目版本为0.0.1-SNAPSHOT，是带SNAPSHOT的快照版本）。</p>\n<p><strong>注意</strong>：maven-releases库默认不能重新发布，需要可重新发布则需要修改该仓库配置或者删除已经发布的版本。</p>\n<p><strong>修改配置重新发布</strong>：将maven-releases库中Deployment pollcy改为Allow redeploy既可。</p>\n<h1 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5.结语\"></a>5.结语</h1><p>Maven对于Javaer说，几乎是天天与其打交道，所以很有必要去了解如果搭建自己的Maven私服仓库。平时多培养自己的动手实践能力，才能在用到的时候不慌。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>"},{"title":"JVM-内存结构","date":"2019-05-27T16:13:00.000Z","notshow":true,"_content":"# 1.概述\n对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\n\n# 2.运行时数据区域\nJava 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。\n<!-- more -->\n\n![jvm-memory-structure](/image/jvm/jvm-memory-structure.jpg)\n\n`JDK 1.8` 同 `JDK 1.7` 相比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：`元数据空间并不在 JVM 中了，而是使用本地内存`。\n\n**线程私有的：**\n- 程序计数器\n- 虚拟机栈\n- 本地方法栈\n\n**线程共享的：**\n- 堆\n- 方法区(JDK 1.8被元空间取代)\n- 直接内存 (非运行时数据区的一部分)\n\n# 1 程序计数器（PC 寄存器）\n\n## 1.1 程序计数器的定义\n\n程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`。\n\n## 1.2 程序计数器的作用\n\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。\n- 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。\n\n## 1.3 程序计数器的特点\n\n- 是一块较小的内存空间。\n- 线程私有，每条线程都有自己的程序计数器。\n- 生命周期：随着线程的创建而创建，随着线程的结束而销毁。\n- 是唯一一个不会出现`OutOfMemoryError`的内存区域。\n\n# 2 Java 虚拟机栈（Java 栈）\n\n## 2.1 Java 虚拟机栈的定义\n\nJava 虚拟机栈是描述 Java 方法运行过程的内存模型。\n\nJava 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：\n\n- 局部变量表\n- 操作数栈\n- 动态链接\n- 方法出口信息\n\n![jvm-stack](/image/jvm/jvm-stack.jpg)\n\n## 2.2 压栈出栈过程\n\n当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。\n\nJava 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。\n\n方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。\n\n> 由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。\n\n## 2.3 Java 虚拟机栈的特点\n\n- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。\n- Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。\n  - StackOverFlowError  若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。\n  - OutOfMemoryError  若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。\n- Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。\n\n> 出现 StackOverFlowError 时，内存空间可能还有很多。\n\n# 3 本地方法栈（C 栈）\n\n## 3.1 本地方法栈的定义\n\n本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。\n\n## 3.2 栈帧变化过程\n\n本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。\n\n方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。\n\n> 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。\n\n# 4 堆\n\n## 4.1 堆的定义\n\n堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。\n\n## 4.2 堆的特点\n\n- 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。\n- 在虚拟机启动时创建。\n- 是垃圾回收的主要场所。\n- 进一步可分为：新生代\\(Eden区  From Survior  To Survivor\\)、老年代。\n\n不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。\n\n堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。\n\n> Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。\n\n# 5 方法区\n\n## 5.1 方法区的定义\n\nJava 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：  \n\n\n- 已经被虚拟机加载的类信息\n- 常量\n- 静态变量\n- 即时编译器编译后的代码\n\n## 5.2 方法区的特点\n\n- 线程共享。  方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。\n- 永久代。  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。\n- 内存回收效率低。  方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。\n- Java 虚拟机规范对方法区的要求比较宽松。  和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。\n\n## 5.3 运行时常量池\n\n方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。\n\n当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern\\(\\) 方法就能在运行期间向常量池中添加字符串常量。\n\n# 6 直接内存（堆外内存）\n\n直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。\n\n## 6.1 操作直接内存\n\n在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的`DirectByteBuffer`对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。\n\n直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。\n\n## 6.2 直接内存与堆内存比较\n\n- 直接内存申请空间耗费更高的性能\n- 直接内存读取 IO 的性能要优于普通的堆内存。\n- 直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO\n- 堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO\n\n> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。\n\n\n","source":"_posts/jvm/JVM-内存结构.md","raw":"---\ntitle: JVM-内存结构\ndate: 2019-05-28 00:13:00\ntags:\n    - JVM\n    - JVM内存结构\ncategories:\n    - JVM\nnotshow: true\n---\n# 1.概述\n对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。\n\n# 2.运行时数据区域\nJava 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。\n<!-- more -->\n\n![jvm-memory-structure](/image/jvm/jvm-memory-structure.jpg)\n\n`JDK 1.8` 同 `JDK 1.7` 相比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：`元数据空间并不在 JVM 中了，而是使用本地内存`。\n\n**线程私有的：**\n- 程序计数器\n- 虚拟机栈\n- 本地方法栈\n\n**线程共享的：**\n- 堆\n- 方法区(JDK 1.8被元空间取代)\n- 直接内存 (非运行时数据区的一部分)\n\n# 1 程序计数器（PC 寄存器）\n\n## 1.1 程序计数器的定义\n\n程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`。\n\n## 1.2 程序计数器的作用\n\n- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。\n- 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。\n\n## 1.3 程序计数器的特点\n\n- 是一块较小的内存空间。\n- 线程私有，每条线程都有自己的程序计数器。\n- 生命周期：随着线程的创建而创建，随着线程的结束而销毁。\n- 是唯一一个不会出现`OutOfMemoryError`的内存区域。\n\n# 2 Java 虚拟机栈（Java 栈）\n\n## 2.1 Java 虚拟机栈的定义\n\nJava 虚拟机栈是描述 Java 方法运行过程的内存模型。\n\nJava 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：\n\n- 局部变量表\n- 操作数栈\n- 动态链接\n- 方法出口信息\n\n![jvm-stack](/image/jvm/jvm-stack.jpg)\n\n## 2.2 压栈出栈过程\n\n当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。\n\nJava 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。\n\n方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。\n\n> 由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。\n\n## 2.3 Java 虚拟机栈的特点\n\n- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。\n- Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。\n  - StackOverFlowError  若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。\n  - OutOfMemoryError  若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。\n- Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。\n\n> 出现 StackOverFlowError 时，内存空间可能还有很多。\n\n# 3 本地方法栈（C 栈）\n\n## 3.1 本地方法栈的定义\n\n本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。\n\n## 3.2 栈帧变化过程\n\n本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。\n\n方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。\n\n> 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。\n\n# 4 堆\n\n## 4.1 堆的定义\n\n堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。\n\n## 4.2 堆的特点\n\n- 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。\n- 在虚拟机启动时创建。\n- 是垃圾回收的主要场所。\n- 进一步可分为：新生代\\(Eden区  From Survior  To Survivor\\)、老年代。\n\n不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。\n\n堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。\n\n> Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。\n\n# 5 方法区\n\n## 5.1 方法区的定义\n\nJava 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：  \n\n\n- 已经被虚拟机加载的类信息\n- 常量\n- 静态变量\n- 即时编译器编译后的代码\n\n## 5.2 方法区的特点\n\n- 线程共享。  方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。\n- 永久代。  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。\n- 内存回收效率低。  方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。\n- Java 虚拟机规范对方法区的要求比较宽松。  和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。\n\n## 5.3 运行时常量池\n\n方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。\n\n当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern\\(\\) 方法就能在运行期间向常量池中添加字符串常量。\n\n# 6 直接内存（堆外内存）\n\n直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。\n\n## 6.1 操作直接内存\n\n在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的`DirectByteBuffer`对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。\n\n直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。\n\n## 6.2 直接内存与堆内存比较\n\n- 直接内存申请空间耗费更高的性能\n- 直接内存读取 IO 的性能要优于普通的堆内存。\n- 直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO\n- 堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO\n\n> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。\n\n\n","slug":"jvm/JVM-内存结构","published":1,"updated":"2019-09-05T03:26:34.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcos000rjfus1pmq4ts1","content":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h1><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h1 id=\"2-运行时数据区域\"><a href=\"#2-运行时数据区域\" class=\"headerlink\" title=\"2.运行时数据区域\"></a>2.运行时数据区域</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"/image/jvm/jvm-memory-structure.jpg\" alt=\"jvm-memory-structure\"></p>\n<p><code>JDK 1.8</code> 同 <code>JDK 1.7</code> 相比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<code>元数据空间并不在 JVM 中了，而是使用本地内存</code>。</p>\n<p><strong>线程私有的：</strong></p>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n</ul>\n<p><strong>线程共享的：</strong></p>\n<ul>\n<li>堆</li>\n<li>方法区(JDK 1.8被元空间取代)</li>\n<li>直接内存 (非运行时数据区的一部分)</li>\n</ul>\n<h1 id=\"1-程序计数器（PC-寄存器）\"><a href=\"#1-程序计数器（PC-寄存器）\" class=\"headerlink\" title=\"1 程序计数器（PC 寄存器）\"></a>1 程序计数器（PC 寄存器）</h1><h2 id=\"1-1-程序计数器的定义\"><a href=\"#1-1-程序计数器的定义\" class=\"headerlink\" title=\"1.1 程序计数器的定义\"></a>1.1 程序计数器的定义</h2><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p>\n<h2 id=\"1-2-程序计数器的作用\"><a href=\"#1-2-程序计数器的作用\" class=\"headerlink\" title=\"1.2 程序计数器的作用\"></a>1.2 程序计数器的作用</h2><ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li>\n<li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li>\n</ul>\n<h2 id=\"1-3-程序计数器的特点\"><a href=\"#1-3-程序计数器的特点\" class=\"headerlink\" title=\"1.3 程序计数器的特点\"></a>1.3 程序计数器的特点</h2><ul>\n<li>是一块较小的内存空间。</li>\n<li>线程私有，每条线程都有自己的程序计数器。</li>\n<li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li>\n<li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</li>\n</ul>\n<h1 id=\"2-Java-虚拟机栈（Java-栈）\"><a href=\"#2-Java-虚拟机栈（Java-栈）\" class=\"headerlink\" title=\"2 Java 虚拟机栈（Java 栈）\"></a>2 Java 虚拟机栈（Java 栈）</h1><h2 id=\"2-1-Java-虚拟机栈的定义\"><a href=\"#2-1-Java-虚拟机栈的定义\" class=\"headerlink\" title=\"2.1 Java 虚拟机栈的定义\"></a>2.1 Java 虚拟机栈的定义</h2><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p>\n<p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p>\n<ul>\n<li>局部变量表</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法出口信息</li>\n</ul>\n<p><img src=\"/image/jvm/jvm-stack.jpg\" alt=\"jvm-stack\"></p>\n<h2 id=\"2-2-压栈出栈过程\"><a href=\"#2-2-压栈出栈过程\" class=\"headerlink\" title=\"2.2 压栈出栈过程\"></a>2.2 压栈出栈过程</h2><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p>\n<p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>\n<p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p>\n<blockquote>\n<p>由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p>\n</blockquote>\n<h2 id=\"2-3-Java-虚拟机栈的特点\"><a href=\"#2-3-Java-虚拟机栈的特点\" class=\"headerlink\" title=\"2.3 Java 虚拟机栈的特点\"></a>2.3 Java 虚拟机栈的特点</h2><ul>\n<li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li>\n<li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul>\n<li>StackOverFlowError  若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li>\n<li>OutOfMemoryError  若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li>\n</ul>\n</li>\n<li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li>\n</ul>\n<blockquote>\n<p>出现 StackOverFlowError 时，内存空间可能还有很多。</p>\n</blockquote>\n<h1 id=\"3-本地方法栈（C-栈）\"><a href=\"#3-本地方法栈（C-栈）\" class=\"headerlink\" title=\"3 本地方法栈（C 栈）\"></a>3 本地方法栈（C 栈）</h1><h2 id=\"3-1-本地方法栈的定义\"><a href=\"#3-1-本地方法栈的定义\" class=\"headerlink\" title=\"3.1 本地方法栈的定义\"></a>3.1 本地方法栈的定义</h2><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>\n<h2 id=\"3-2-栈帧变化过程\"><a href=\"#3-2-栈帧变化过程\" class=\"headerlink\" title=\"3.2 栈帧变化过程\"></a>3.2 栈帧变化过程</h2><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p>\n<p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p>\n<blockquote>\n<p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p>\n</blockquote>\n<h1 id=\"4-堆\"><a href=\"#4-堆\" class=\"headerlink\" title=\"4 堆\"></a>4 堆</h1><h2 id=\"4-1-堆的定义\"><a href=\"#4-1-堆的定义\" class=\"headerlink\" title=\"4.1 堆的定义\"></a>4.1 堆的定义</h2><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p>\n<h2 id=\"4-2-堆的特点\"><a href=\"#4-2-堆的特点\" class=\"headerlink\" title=\"4.2 堆的特点\"></a>4.2 堆的特点</h2><ul>\n<li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li>\n<li>在虚拟机启动时创建。</li>\n<li>是垃圾回收的主要场所。</li>\n<li>进一步可分为：新生代(Eden区  From Survior  To Survivor)、老年代。</li>\n</ul>\n<p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p>\n<p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</p>\n<blockquote>\n<p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p>\n</blockquote>\n<h1 id=\"5-方法区\"><a href=\"#5-方法区\" class=\"headerlink\" title=\"5 方法区\"></a>5 方法区</h1><h2 id=\"5-1-方法区的定义\"><a href=\"#5-1-方法区的定义\" class=\"headerlink\" title=\"5.1 方法区的定义\"></a>5.1 方法区的定义</h2><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：  </p>\n<ul>\n<li>已经被虚拟机加载的类信息</li>\n<li>常量</li>\n<li>静态变量</li>\n<li>即时编译器编译后的代码</li>\n</ul>\n<h2 id=\"5-2-方法区的特点\"><a href=\"#5-2-方法区的特点\" class=\"headerlink\" title=\"5.2 方法区的特点\"></a>5.2 方法区的特点</h2><ul>\n<li>线程共享。  方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li>\n<li>永久代。  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li>\n<li>内存回收效率低。  方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li>\n<li>Java 虚拟机规范对方法区的要求比较宽松。  和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li>\n</ul>\n<h2 id=\"5-3-运行时常量池\"><a href=\"#5-3-运行时常量池\" class=\"headerlink\" title=\"5.3 运行时常量池\"></a>5.3 运行时常量池</h2><p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p>\n<p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。</p>\n<h1 id=\"6-直接内存（堆外内存）\"><a href=\"#6-直接内存（堆外内存）\" class=\"headerlink\" title=\"6 直接内存（堆外内存）\"></a>6 直接内存（堆外内存）</h1><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p>\n<h2 id=\"6-1-操作直接内存\"><a href=\"#6-1-操作直接内存\" class=\"headerlink\" title=\"6.1 操作直接内存\"></a>6.1 操作直接内存</h2><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p>\n<p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p>\n<h2 id=\"6-2-直接内存与堆内存比较\"><a href=\"#6-2-直接内存与堆内存比较\" class=\"headerlink\" title=\"6.2 直接内存与堆内存比较\"></a>6.2 直接内存与堆内存比较</h2><ul>\n<li>直接内存申请空间耗费更高的性能</li>\n<li>直接内存读取 IO 的性能要优于普通的堆内存。</li>\n<li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li>\n<li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li>\n</ul>\n<blockquote>\n<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h1><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>\n<h1 id=\"2-运行时数据区域\"><a href=\"#2-运行时数据区域\" class=\"headerlink\" title=\"2.运行时数据区域\"></a>2.运行时数据区域</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面会介绍到。</p>","more":"<p><img src=\"/image/jvm/jvm-memory-structure.jpg\" alt=\"jvm-memory-structure\"></p>\n<p><code>JDK 1.8</code> 同 <code>JDK 1.7</code> 相比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<code>元数据空间并不在 JVM 中了，而是使用本地内存</code>。</p>\n<p><strong>线程私有的：</strong></p>\n<ul>\n<li>程序计数器</li>\n<li>虚拟机栈</li>\n<li>本地方法栈</li>\n</ul>\n<p><strong>线程共享的：</strong></p>\n<ul>\n<li>堆</li>\n<li>方法区(JDK 1.8被元空间取代)</li>\n<li>直接内存 (非运行时数据区的一部分)</li>\n</ul>\n<h1 id=\"1-程序计数器（PC-寄存器）\"><a href=\"#1-程序计数器（PC-寄存器）\" class=\"headerlink\" title=\"1 程序计数器（PC 寄存器）\"></a>1 程序计数器（PC 寄存器）</h1><h2 id=\"1-1-程序计数器的定义\"><a href=\"#1-1-程序计数器的定义\" class=\"headerlink\" title=\"1.1 程序计数器的定义\"></a>1.1 程序计数器的定义</h2><p>程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个本地方法，那么此时程序计数器为<code>Undefined</code>。</p>\n<h2 id=\"1-2-程序计数器的作用\"><a href=\"#1-2-程序计数器的作用\" class=\"headerlink\" title=\"1.2 程序计数器的作用\"></a>1.2 程序计数器的作用</h2><ul>\n<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li>\n<li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li>\n</ul>\n<h2 id=\"1-3-程序计数器的特点\"><a href=\"#1-3-程序计数器的特点\" class=\"headerlink\" title=\"1.3 程序计数器的特点\"></a>1.3 程序计数器的特点</h2><ul>\n<li>是一块较小的内存空间。</li>\n<li>线程私有，每条线程都有自己的程序计数器。</li>\n<li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li>\n<li>是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。</li>\n</ul>\n<h1 id=\"2-Java-虚拟机栈（Java-栈）\"><a href=\"#2-Java-虚拟机栈（Java-栈）\" class=\"headerlink\" title=\"2 Java 虚拟机栈（Java 栈）\"></a>2 Java 虚拟机栈（Java 栈）</h1><h2 id=\"2-1-Java-虚拟机栈的定义\"><a href=\"#2-1-Java-虚拟机栈的定义\" class=\"headerlink\" title=\"2.1 Java 虚拟机栈的定义\"></a>2.1 Java 虚拟机栈的定义</h2><p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p>\n<p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p>\n<ul>\n<li>局部变量表</li>\n<li>操作数栈</li>\n<li>动态链接</li>\n<li>方法出口信息</li>\n</ul>\n<p><img src=\"/image/jvm/jvm-stack.jpg\" alt=\"jvm-stack\"></p>\n<h2 id=\"2-2-压栈出栈过程\"><a href=\"#2-2-压栈出栈过程\" class=\"headerlink\" title=\"2.2 压栈出栈过程\"></a>2.2 压栈出栈过程</h2><p>当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。</p>\n<p>Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>\n<p>方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。</p>\n<blockquote>\n<p>由于Java 虚拟机栈是与线程对应的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</p>\n</blockquote>\n<h2 id=\"2-3-Java-虚拟机栈的特点\"><a href=\"#2-3-Java-虚拟机栈的特点\" class=\"headerlink\" title=\"2.3 Java 虚拟机栈的特点\"></a>2.3 Java 虚拟机栈的特点</h2><ul>\n<li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。</li>\n<li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<ul>\n<li>StackOverFlowError  若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。</li>\n<li>OutOfMemoryError  若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。</li>\n</ul>\n</li>\n<li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li>\n</ul>\n<blockquote>\n<p>出现 StackOverFlowError 时，内存空间可能还有很多。</p>\n</blockquote>\n<h1 id=\"3-本地方法栈（C-栈）\"><a href=\"#3-本地方法栈（C-栈）\" class=\"headerlink\" title=\"3 本地方法栈（C 栈）\"></a>3 本地方法栈（C 栈）</h1><h2 id=\"3-1-本地方法栈的定义\"><a href=\"#3-1-本地方法栈的定义\" class=\"headerlink\" title=\"3.1 本地方法栈的定义\"></a>3.1 本地方法栈的定义</h2><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>\n<h2 id=\"3-2-栈帧变化过程\"><a href=\"#3-2-栈帧变化过程\" class=\"headerlink\" title=\"3.2 栈帧变化过程\"></a>3.2 栈帧变化过程</h2><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。</p>\n<p>方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p>\n<blockquote>\n<p>如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。</p>\n</blockquote>\n<h1 id=\"4-堆\"><a href=\"#4-堆\" class=\"headerlink\" title=\"4 堆\"></a>4 堆</h1><h2 id=\"4-1-堆的定义\"><a href=\"#4-1-堆的定义\" class=\"headerlink\" title=\"4.1 堆的定义\"></a>4.1 堆的定义</h2><p>堆是用来存放对象的内存空间，几乎所有的对象都存储在堆中。</p>\n<h2 id=\"4-2-堆的特点\"><a href=\"#4-2-堆的特点\" class=\"headerlink\" title=\"4.2 堆的特点\"></a>4.2 堆的特点</h2><ul>\n<li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li>\n<li>在虚拟机启动时创建。</li>\n<li>是垃圾回收的主要场所。</li>\n<li>进一步可分为：新生代(Eden区  From Survior  To Survivor)、老年代。</li>\n</ul>\n<p>不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p>\n<p>堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。</p>\n<blockquote>\n<p>Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。</p>\n</blockquote>\n<h1 id=\"5-方法区\"><a href=\"#5-方法区\" class=\"headerlink\" title=\"5 方法区\"></a>5 方法区</h1><h2 id=\"5-1-方法区的定义\"><a href=\"#5-1-方法区的定义\" class=\"headerlink\" title=\"5.1 方法区的定义\"></a>5.1 方法区的定义</h2><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：  </p>\n<ul>\n<li>已经被虚拟机加载的类信息</li>\n<li>常量</li>\n<li>静态变量</li>\n<li>即时编译器编译后的代码</li>\n</ul>\n<h2 id=\"5-2-方法区的特点\"><a href=\"#5-2-方法区的特点\" class=\"headerlink\" title=\"5.2 方法区的特点\"></a>5.2 方法区的特点</h2><ul>\n<li>线程共享。  方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。</li>\n<li>永久代。  方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li>\n<li>内存回收效率低。  方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。</li>\n<li>Java 虚拟机规范对方法区的要求比较宽松。  和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。</li>\n</ul>\n<h2 id=\"5-3-运行时常量池\"><a href=\"#5-3-运行时常量池\" class=\"headerlink\" title=\"5.3 运行时常量池\"></a>5.3 运行时常量池</h2><p>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</p>\n<p>当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池中添加字符串常量。</p>\n<h1 id=\"6-直接内存（堆外内存）\"><a href=\"#6-直接内存（堆外内存）\" class=\"headerlink\" title=\"6 直接内存（堆外内存）\"></a>6 直接内存（堆外内存）</h1><p>直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。</p>\n<h2 id=\"6-1-操作直接内存\"><a href=\"#6-1-操作直接内存\" class=\"headerlink\" title=\"6.1 操作直接内存\"></a>6.1 操作直接内存</h2><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的<code>DirectByteBuffer</code>对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。</p>\n<p>直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。</p>\n<h2 id=\"6-2-直接内存与堆内存比较\"><a href=\"#6-2-直接内存与堆内存比较\" class=\"headerlink\" title=\"6.2 直接内存与堆内存比较\"></a>6.2 直接内存与堆内存比较</h2><ul>\n<li>直接内存申请空间耗费更高的性能</li>\n<li>直接内存读取 IO 的性能要优于普通的堆内存。</li>\n<li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li>\n<li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li>\n</ul>\n<blockquote>\n<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置<code>-Xmx</code>等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现<code>OutOfMemoryError</code>异常。</p>\n</blockquote>"},{"title":"JVM系列-自带故障处理工具","date":"2019-06-26T16:05:00.000Z","notshow":true,"_content":"# 1.前言\nJava与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。\n\n我们在定位JVM的问题是往往会借助各种工具去定位JVM异常，Sun公司就提供了一些工具，这些工具的功能都十分强大，能帮助我们定位故障问题，解决程序性能等问题。\n<!-- more -->\n# 2.JVM自带命令行工具\nSum公司提供提供的JVM监控和故障处理工具主要是下表列出的几个，我们在了解了它们的使用之后能为我们带来极大的便利，当然现在很多公司也为我们提供了很多图形化的工具，如：JProfile等，但是我还是觉得了解JDK自带的工具还是很有必要的，毕竟JProfile也是收费的，我在使用JProfile的时候就因为激活码的问题而折腾了好久，最终好像只有JProfile 9版本的才能使用网上的激活码免费使用。\n\n| **名称** | **主要作用** |\n| :-----: | :----- |\n| jps | JVM process Status Tool，显示系统内所有的HotSpot虚拟机进程 |\n| jstat | JVM Statistics Monitoring Tool，用于手机HotSpot虚拟机各方面的运行数据 |\n| jinfo | Configuration Info for Java，显示虚拟机配置信息 |\n| jmap | Memory Map for Java，生成虚拟机内存转储快照（heapdump文件） |\n| jhat | JVM Heap Dump Browser，用户分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果 |\n|jstack | Stack Trace for Java，显示虚拟机线程快照 |\n\n## 2.1 **jps**命令\n用与获取java进程的LVMID，对于本地虚拟机来说LVMID和PID是相同的。这个命令是基础，许多命令都是依赖这个命令输出的PID才能操作。所以比较重要。\n- 命令格式\n>jps [options] <pid>\n- 命令参数\n\n|**参数** | **作用**|\n| :-----: | :----- |\n|-q | 只输出pid 省略主类名称|\n|-m | 输出JVM进程启动是传递给主类main()函数的参数|\n|-l | 输出主类的全名，如果是Jar包，则输出Jar路径|\n|-v | 输出JVM进程启动是的参数|\n\n- 执行样例 \njps -l \n```shell\nliuyi@liuyideMacBook-Pro:~$ jps -l\n568\n26985 sun.tools.jps.Jps\n26732 org.jetbrains.jps.cmdline.Launcher\n26588 org.jetbrains.idea.maven.server.RemoteMavenServer\n26733 com.jiafly.libra.LibraPayApplication\n```\n\n\n## 2.2 **jstat**命令\n用于见识虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据。但是他没有图形界面，只能纯文本展示。\n- 命令格式\n>jstat [option vmid [interval[s|ms] [count]]]\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jstat -options\n-class 监视类装载，卸载数量，总空间以及类装载所消耗的时间\n-compiler 输出JIT编译器编译过的方法，耗时信息\n-gc 监视Java堆，Eden区 S0,S1 元空间等容量信息\n-gccapacity 与-gc基本相同，但主要关注Java堆各个区域使用到的最大 最小空间\n-gccause 与-gcutil功能一样，但是会输出导致上一次GC产生的原因\n-gcmetacapacity 元空间使用到的最大 最小空间\n-gcnew 监视新生代GC状况\n-gcnewcapacity 新生代使用到的最大 最小空间\n-gcold 监视老年代GC状况\n-gcoldcapacity 老年代使用到的最大 最小空间\n-gcutil 监视内容与-gc基本相同，但输出主要管制已使用空间占总空间占比\n-printcompilation 输出已经被JIT编译的方法\n```\n- 执行样例\njstat -gcutil 26733\n```shell\nliuyi@liuyideMacBook-Pro:~$ jstat -gcutil 26733\n  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT\n  0.00   0.00  15.73  26.29  96.45  94.00     10    0.109     3    0.249    0.358\n```\n    + 0：幸存1区当前使用比例\n    + S1：幸存2区当前使用比例\n    + E：伊甸园区使用比例\n    + O：老年代使用比例\n    + M：元数据区使用比例\n    + CCS：压缩使用比例\n    + YGC：年轻代垃圾回收次数\n    + FGC：老年代垃圾回收次数\n    + FGCT：老年代垃圾回收消耗时间\n    + GCT：垃圾回收消耗总时间\n\n## 2.3 **jinfo**命令\n- 命令格式\n>jinfo [option] <pid>\n\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jinfo -h\nUsage:\n    jinfo [option] <pid>\n        (to connect to running process)\n    jinfo [option] <executable <core>\n        (to connect to a core file)\n    jinfo [option] [server_id@]<remote server IP or hostname>\n        (to connect to remote debug server)\n\nwhere <option> is one of:\n    -flag <name>         to print the value of the named VM flag\n    -flag [+|-]<name>    to enable or disable the named VM flag\n    -flag <name>=<value> to set the named VM flag to the given value\n    -flags               to print VM flags\n    -sysprops            to print Java system properties\n    <no option>          to print both of the above\n    -h | -help           to print this help message\n```\n- 执行样例\n```shell\nliuyi@liuyideMacBook-Pro:~$ jinfo -flag ReservedCodeCacheSize 27043\n-XX:ReservedCodeCacheSize=251658240\n```\n\n## 2.4 **jmap**命令\n- 命令格式\n>jmap [option] <pid>\n\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jmap -h\nUsage:\n    jmap [option] <pid>\n        (to connect to running process)\n    jmap [option] <executable <core>\n        (to connect to a core file)\n    jmap [option] [server_id@]<remote server IP or hostname>\n        (to connect to remote debug server)\n\nwhere <option> is one of:\n    <none>               to print same info as Solaris pmap\n    -heap                to print java heap summary\n    -histo[:live]        to print histogram of java object heap; if the \"live\"\n                         suboption is specified, only count live objects\n    -clstats             to print class loader statistics\n    -finalizerinfo       to print information on objects awaiting finalization\n    -dump:<dump-options> to dump java heap in hprof binary format\n                         dump-options:\n                           live         dump only live objects; if not specified,\n                                        all objects in the heap are dumped.\n                           format=b     binary format\n                           file=<file>  dump heap to <file>\n                         Example: jmap -dump:live,format=b,file=heap.bin <pid>\n    -F                   force. Use with -dump:<dump-options> <pid> or -histo\n                         to force a heap dump or histogram when <pid> does not\n                         respond. The \"live\" suboption is not supported\n                         in this mode.\n    -h | -help           to print this help message\n    -J<flag>             to pass <flag> directly to the runtime system\n```\n- 执行样例\n```shell\njmap -dump:format=b,file=eclipse.bin 3500\n```\n\n## 2.5 **jhat**命令\n与jmap搭配使用，用来分析jmap生成的dump文件。内置了HTTP/HTML服务器，可以在浏览器中查看。\n- 执行样例\njhat eclipse.bin\n执行后屏幕显示“Server is ready.”然后再浏览器输入[http://localhost:7000](http://localhost:7000)就可以看到分析结果。\n\n## 2.6 **jstack**命令\nJava堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照。用于定位线程出现长时间停顿的原因，如：线程间死锁，死循环，请求外部资源导致长时间等待等。\n- 命令格式\njstack [option] pid\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jstack -h\nUsage:\n    jstack [-l] <pid>\n        (to connect to running process)\n    jstack -F [-m] [-l] <pid>\n        (to connect to a hung process)\n    jstack [-m] [-l] <executable> <core>\n        (to connect to a core file)\n    jstack [-m] [-l] [server_id@]<remote server IP or hostname>\n        (to connect to a remote debug server)\n\nOptions:\n    -F  to force a thread dump. Use when jstack <pid> does not respond (process is hung)\n    -m  to print both java and native frames (mixed mode)\n    -l  long listing. Prints additional information about locks\n    -h or -help to print this help message\n```\n- 执行样例\njstack -l 27043\n\n# 3.JVM自带可视化工具\nJVM自带的可视化工具在分析JVM问题的时候还是很有用处的，能够直观的从图形界面看出变化。方便我们能快速定位到JVM的问题。\n## 3.1 JConsole: Java监视与管理控制台\n\n## 3.2 VisualVM: 多合一故障处理工具\n\n\n\n","source":"_posts/jvm/JVM系列-JVM自带工具.md","raw":"---\ntitle: JVM系列-自带故障处理工具\ndate: 2019-06-27 00:05:00\ntags:\n    - JVM\n    - 工具\ncategories:\n    - JVM\nnotshow: true\n---\n# 1.前言\nJava与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。\n\n我们在定位JVM的问题是往往会借助各种工具去定位JVM异常，Sun公司就提供了一些工具，这些工具的功能都十分强大，能帮助我们定位故障问题，解决程序性能等问题。\n<!-- more -->\n# 2.JVM自带命令行工具\nSum公司提供提供的JVM监控和故障处理工具主要是下表列出的几个，我们在了解了它们的使用之后能为我们带来极大的便利，当然现在很多公司也为我们提供了很多图形化的工具，如：JProfile等，但是我还是觉得了解JDK自带的工具还是很有必要的，毕竟JProfile也是收费的，我在使用JProfile的时候就因为激活码的问题而折腾了好久，最终好像只有JProfile 9版本的才能使用网上的激活码免费使用。\n\n| **名称** | **主要作用** |\n| :-----: | :----- |\n| jps | JVM process Status Tool，显示系统内所有的HotSpot虚拟机进程 |\n| jstat | JVM Statistics Monitoring Tool，用于手机HotSpot虚拟机各方面的运行数据 |\n| jinfo | Configuration Info for Java，显示虚拟机配置信息 |\n| jmap | Memory Map for Java，生成虚拟机内存转储快照（heapdump文件） |\n| jhat | JVM Heap Dump Browser，用户分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果 |\n|jstack | Stack Trace for Java，显示虚拟机线程快照 |\n\n## 2.1 **jps**命令\n用与获取java进程的LVMID，对于本地虚拟机来说LVMID和PID是相同的。这个命令是基础，许多命令都是依赖这个命令输出的PID才能操作。所以比较重要。\n- 命令格式\n>jps [options] <pid>\n- 命令参数\n\n|**参数** | **作用**|\n| :-----: | :----- |\n|-q | 只输出pid 省略主类名称|\n|-m | 输出JVM进程启动是传递给主类main()函数的参数|\n|-l | 输出主类的全名，如果是Jar包，则输出Jar路径|\n|-v | 输出JVM进程启动是的参数|\n\n- 执行样例 \njps -l \n```shell\nliuyi@liuyideMacBook-Pro:~$ jps -l\n568\n26985 sun.tools.jps.Jps\n26732 org.jetbrains.jps.cmdline.Launcher\n26588 org.jetbrains.idea.maven.server.RemoteMavenServer\n26733 com.jiafly.libra.LibraPayApplication\n```\n\n\n## 2.2 **jstat**命令\n用于见识虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据。但是他没有图形界面，只能纯文本展示。\n- 命令格式\n>jstat [option vmid [interval[s|ms] [count]]]\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jstat -options\n-class 监视类装载，卸载数量，总空间以及类装载所消耗的时间\n-compiler 输出JIT编译器编译过的方法，耗时信息\n-gc 监视Java堆，Eden区 S0,S1 元空间等容量信息\n-gccapacity 与-gc基本相同，但主要关注Java堆各个区域使用到的最大 最小空间\n-gccause 与-gcutil功能一样，但是会输出导致上一次GC产生的原因\n-gcmetacapacity 元空间使用到的最大 最小空间\n-gcnew 监视新生代GC状况\n-gcnewcapacity 新生代使用到的最大 最小空间\n-gcold 监视老年代GC状况\n-gcoldcapacity 老年代使用到的最大 最小空间\n-gcutil 监视内容与-gc基本相同，但输出主要管制已使用空间占总空间占比\n-printcompilation 输出已经被JIT编译的方法\n```\n- 执行样例\njstat -gcutil 26733\n```shell\nliuyi@liuyideMacBook-Pro:~$ jstat -gcutil 26733\n  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT\n  0.00   0.00  15.73  26.29  96.45  94.00     10    0.109     3    0.249    0.358\n```\n    + 0：幸存1区当前使用比例\n    + S1：幸存2区当前使用比例\n    + E：伊甸园区使用比例\n    + O：老年代使用比例\n    + M：元数据区使用比例\n    + CCS：压缩使用比例\n    + YGC：年轻代垃圾回收次数\n    + FGC：老年代垃圾回收次数\n    + FGCT：老年代垃圾回收消耗时间\n    + GCT：垃圾回收消耗总时间\n\n## 2.3 **jinfo**命令\n- 命令格式\n>jinfo [option] <pid>\n\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jinfo -h\nUsage:\n    jinfo [option] <pid>\n        (to connect to running process)\n    jinfo [option] <executable <core>\n        (to connect to a core file)\n    jinfo [option] [server_id@]<remote server IP or hostname>\n        (to connect to remote debug server)\n\nwhere <option> is one of:\n    -flag <name>         to print the value of the named VM flag\n    -flag [+|-]<name>    to enable or disable the named VM flag\n    -flag <name>=<value> to set the named VM flag to the given value\n    -flags               to print VM flags\n    -sysprops            to print Java system properties\n    <no option>          to print both of the above\n    -h | -help           to print this help message\n```\n- 执行样例\n```shell\nliuyi@liuyideMacBook-Pro:~$ jinfo -flag ReservedCodeCacheSize 27043\n-XX:ReservedCodeCacheSize=251658240\n```\n\n## 2.4 **jmap**命令\n- 命令格式\n>jmap [option] <pid>\n\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jmap -h\nUsage:\n    jmap [option] <pid>\n        (to connect to running process)\n    jmap [option] <executable <core>\n        (to connect to a core file)\n    jmap [option] [server_id@]<remote server IP or hostname>\n        (to connect to remote debug server)\n\nwhere <option> is one of:\n    <none>               to print same info as Solaris pmap\n    -heap                to print java heap summary\n    -histo[:live]        to print histogram of java object heap; if the \"live\"\n                         suboption is specified, only count live objects\n    -clstats             to print class loader statistics\n    -finalizerinfo       to print information on objects awaiting finalization\n    -dump:<dump-options> to dump java heap in hprof binary format\n                         dump-options:\n                           live         dump only live objects; if not specified,\n                                        all objects in the heap are dumped.\n                           format=b     binary format\n                           file=<file>  dump heap to <file>\n                         Example: jmap -dump:live,format=b,file=heap.bin <pid>\n    -F                   force. Use with -dump:<dump-options> <pid> or -histo\n                         to force a heap dump or histogram when <pid> does not\n                         respond. The \"live\" suboption is not supported\n                         in this mode.\n    -h | -help           to print this help message\n    -J<flag>             to pass <flag> directly to the runtime system\n```\n- 执行样例\n```shell\njmap -dump:format=b,file=eclipse.bin 3500\n```\n\n## 2.5 **jhat**命令\n与jmap搭配使用，用来分析jmap生成的dump文件。内置了HTTP/HTML服务器，可以在浏览器中查看。\n- 执行样例\njhat eclipse.bin\n执行后屏幕显示“Server is ready.”然后再浏览器输入[http://localhost:7000](http://localhost:7000)就可以看到分析结果。\n\n## 2.6 **jstack**命令\nJava堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照。用于定位线程出现长时间停顿的原因，如：线程间死锁，死循环，请求外部资源导致长时间等待等。\n- 命令格式\njstack [option] pid\n- 命令参数\n```shell\nliuyi@liuyideMacBook-Pro:~$ jstack -h\nUsage:\n    jstack [-l] <pid>\n        (to connect to running process)\n    jstack -F [-m] [-l] <pid>\n        (to connect to a hung process)\n    jstack [-m] [-l] <executable> <core>\n        (to connect to a core file)\n    jstack [-m] [-l] [server_id@]<remote server IP or hostname>\n        (to connect to a remote debug server)\n\nOptions:\n    -F  to force a thread dump. Use when jstack <pid> does not respond (process is hung)\n    -m  to print both java and native frames (mixed mode)\n    -l  long listing. Prints additional information about locks\n    -h or -help to print this help message\n```\n- 执行样例\njstack -l 27043\n\n# 3.JVM自带可视化工具\nJVM自带的可视化工具在分析JVM问题的时候还是很有用处的，能够直观的从图形界面看出变化。方便我们能快速定位到JVM的问题。\n## 3.1 JConsole: Java监视与管理控制台\n\n## 3.2 VisualVM: 多合一故障处理工具\n\n\n\n","slug":"jvm/JVM系列-JVM自带工具","published":1,"updated":"2019-09-05T03:26:33.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcou000vjfus2kht2mdn","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>\n<p>我们在定位JVM的问题是往往会借助各种工具去定位JVM异常，Sun公司就提供了一些工具，这些工具的功能都十分强大，能帮助我们定位故障问题，解决程序性能等问题。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-JVM自带命令行工具\"><a href=\"#2-JVM自带命令行工具\" class=\"headerlink\" title=\"2.JVM自带命令行工具\"></a>2.JVM自带命令行工具</h1><p>Sum公司提供提供的JVM监控和故障处理工具主要是下表列出的几个，我们在了解了它们的使用之后能为我们带来极大的便利，当然现在很多公司也为我们提供了很多图形化的工具，如：JProfile等，但是我还是觉得了解JDK自带的工具还是很有必要的，毕竟JProfile也是收费的，我在使用JProfile的时候就因为激活码的问题而折腾了好久，最终好像只有JProfile 9版本的才能使用网上的激活码免费使用。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>名称</strong></th>\n<th align=\"left\"><strong>主要作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">jps</td>\n<td align=\"left\">JVM process Status Tool，显示系统内所有的HotSpot虚拟机进程</td>\n</tr>\n<tr>\n<td align=\"center\">jstat</td>\n<td align=\"left\">JVM Statistics Monitoring Tool，用于手机HotSpot虚拟机各方面的运行数据</td>\n</tr>\n<tr>\n<td align=\"center\">jinfo</td>\n<td align=\"left\">Configuration Info for Java，显示虚拟机配置信息</td>\n</tr>\n<tr>\n<td align=\"center\">jmap</td>\n<td align=\"left\">Memory Map for Java，生成虚拟机内存转储快照（heapdump文件）</td>\n</tr>\n<tr>\n<td align=\"center\">jhat</td>\n<td align=\"left\">JVM Heap Dump Browser，用户分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>\n</tr>\n<tr>\n<td align=\"center\">jstack</td>\n<td align=\"left\">Stack Trace for Java，显示虚拟机线程快照</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-1-jps命令\"><a href=\"#2-1-jps命令\" class=\"headerlink\" title=\"2.1 jps命令\"></a>2.1 <strong>jps</strong>命令</h2><p>用与获取java进程的LVMID，对于本地虚拟机来说LVMID和PID是相同的。这个命令是基础，许多命令都是依赖这个命令输出的PID才能操作。所以比较重要。</p>\n<ul>\n<li>命令格式<blockquote>\n<p>jps [options] <pid></p>\n</blockquote>\n</li>\n<li>命令参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th align=\"left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-q</td>\n<td align=\"left\">只输出pid 省略主类名称</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"left\">输出JVM进程启动是传递给主类main()函数的参数</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"left\">输出主类的全名，如果是Jar包，则输出Jar路径</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"left\">输出JVM进程启动是的参数</td>\n</tr>\n</tbody></table>\n<ul>\n<li>执行样例<br>jps -l <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jps -l</span><br><span class=\"line\">568</span><br><span class=\"line\">26985 sun.tools.jps.Jps</span><br><span class=\"line\">26732 org.jetbrains.jps.cmdline.Launcher</span><br><span class=\"line\">26588 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class=\"line\">26733 com.jiafly.libra.LibraPayApplication</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h2 id=\"2-2-jstat命令\"><a href=\"#2-2-jstat命令\" class=\"headerlink\" title=\"2.2 jstat命令\"></a>2.2 <strong>jstat</strong>命令</h2><p>用于见识虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据。但是他没有图形界面，只能纯文本展示。</p>\n<ul>\n<li>命令格式<blockquote>\n<p>jstat [option vmid [interval[s|ms] [count]]]</p>\n</blockquote>\n</li>\n<li>命令参数<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jstat -options</span><br><span class=\"line\">-class 监视类装载，卸载数量，总空间以及类装载所消耗的时间</span><br><span class=\"line\">-compiler 输出JIT编译器编译过的方法，耗时信息</span><br><span class=\"line\">-gc 监视Java堆，Eden区 S0,S1 元空间等容量信息</span><br><span class=\"line\">-gccapacity 与-gc基本相同，但主要关注Java堆各个区域使用到的最大 最小空间</span><br><span class=\"line\">-gccause 与-gcutil功能一样，但是会输出导致上一次GC产生的原因</span><br><span class=\"line\">-gcmetacapacity 元空间使用到的最大 最小空间</span><br><span class=\"line\">-gcnew 监视新生代GC状况</span><br><span class=\"line\">-gcnewcapacity 新生代使用到的最大 最小空间</span><br><span class=\"line\">-gcold 监视老年代GC状况</span><br><span class=\"line\">-gcoldcapacity 老年代使用到的最大 最小空间</span><br><span class=\"line\">-gcutil 监视内容与-gc基本相同，但输出主要管制已使用空间占总空间占比</span><br><span class=\"line\">-printcompilation 输出已经被JIT编译的方法</span><br></pre></td></tr></table></figure></li>\n<li>执行样例<br>jstat -gcutil 26733<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jstat -gcutil 26733</span><br><span class=\"line\">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class=\"line\">  0.00   0.00  15.73  26.29  96.45  94.00     10    0.109     3    0.249    0.358</span><br></pre></td></tr></table></figure>\n<ul>\n<li>0：幸存1区当前使用比例</li>\n<li>S1：幸存2区当前使用比例</li>\n<li>E：伊甸园区使用比例</li>\n<li>O：老年代使用比例</li>\n<li>M：元数据区使用比例</li>\n<li>CCS：压缩使用比例</li>\n<li>YGC：年轻代垃圾回收次数</li>\n<li>FGC：老年代垃圾回收次数</li>\n<li>FGCT：老年代垃圾回收消耗时间</li>\n<li>GCT：垃圾回收消耗总时间</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-3-jinfo命令\"><a href=\"#2-3-jinfo命令\" class=\"headerlink\" title=\"2.3 jinfo命令\"></a>2.3 <strong>jinfo</strong>命令</h2><ul>\n<li><p>命令格式</p>\n<blockquote>\n<p>jinfo [option] <pid></p>\n</blockquote>\n</li>\n<li><p>命令参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jinfo -h</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jinfo [option] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">where &lt;option&gt; is one of:</span><br><span class=\"line\">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class=\"line\">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class=\"line\">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class=\"line\">    -flags               to print VM flags</span><br><span class=\"line\">    -sysprops            to print Java system properties</span><br><span class=\"line\">    &lt;no option&gt;          to print both of the above</span><br><span class=\"line\">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure></li>\n<li><p>执行样例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jinfo -flag ReservedCodeCacheSize 27043</span><br><span class=\"line\">-XX:ReservedCodeCacheSize=251658240</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"2-4-jmap命令\"><a href=\"#2-4-jmap命令\" class=\"headerlink\" title=\"2.4 jmap命令\"></a>2.4 <strong>jmap</strong>命令</h2><ul>\n<li><p>命令格式</p>\n<blockquote>\n<p>jmap [option] <pid></p>\n</blockquote>\n</li>\n<li><p>命令参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jmap -h</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jmap [option] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">where &lt;option&gt; is one of:</span><br><span class=\"line\">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class=\"line\">    -heap                to print java heap summary</span><br><span class=\"line\">    -histo[:live]        to print histogram of java object heap; if the \"live\"</span><br><span class=\"line\">                         suboption is specified, only count live objects</span><br><span class=\"line\">    -clstats             to print class loader statistics</span><br><span class=\"line\">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class=\"line\">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class=\"line\">                         dump-options:</span><br><span class=\"line\">                           live         dump only live objects; if not specified,</span><br><span class=\"line\">                                        all objects in the heap are dumped.</span><br><span class=\"line\">                           format=b     binary format</span><br><span class=\"line\">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class=\"line\">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class=\"line\">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class=\"line\">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class=\"line\">                         respond. The \"live\" suboption is not supported</span><br><span class=\"line\">                         in this mode.</span><br><span class=\"line\">    -h | -help           to print this help message</span><br><span class=\"line\">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure></li>\n<li><p>执行样例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:format=b,file=eclipse.bin 3500</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"2-5-jhat命令\"><a href=\"#2-5-jhat命令\" class=\"headerlink\" title=\"2.5 jhat命令\"></a>2.5 <strong>jhat</strong>命令</h2><p>与jmap搭配使用，用来分析jmap生成的dump文件。内置了HTTP/HTML服务器，可以在浏览器中查看。</p>\n<ul>\n<li>执行样例<br>jhat eclipse.bin<br>执行后屏幕显示“Server is ready.”然后再浏览器输入<a href=\"http://localhost:7000\" target=\"_blank\" rel=\"noopener\">http://localhost:7000</a>就可以看到分析结果。</li>\n</ul>\n<h2 id=\"2-6-jstack命令\"><a href=\"#2-6-jstack命令\" class=\"headerlink\" title=\"2.6 jstack命令\"></a>2.6 <strong>jstack</strong>命令</h2><p>Java堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照。用于定位线程出现长时间停顿的原因，如：线程间死锁，死循环，请求外部资源导致长时间等待等。</p>\n<ul>\n<li>命令格式<br>jstack [option] pid</li>\n<li>命令参数<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jstack -h</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jstack [-l] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to a hung process)</span><br><span class=\"line\">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to a remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class=\"line\">    -m  to print both java and native frames (mixed mode)</span><br><span class=\"line\">    -l  long listing. Prints additional information about locks</span><br><span class=\"line\">    -h or -help to print this help message</span><br></pre></td></tr></table></figure></li>\n<li>执行样例<br>jstack -l 27043</li>\n</ul>\n<h1 id=\"3-JVM自带可视化工具\"><a href=\"#3-JVM自带可视化工具\" class=\"headerlink\" title=\"3.JVM自带可视化工具\"></a>3.JVM自带可视化工具</h1><p>JVM自带的可视化工具在分析JVM问题的时候还是很有用处的，能够直观的从图形界面看出变化。方便我们能快速定位到JVM的问题。</p>\n<h2 id=\"3-1-JConsole-Java监视与管理控制台\"><a href=\"#3-1-JConsole-Java监视与管理控制台\" class=\"headerlink\" title=\"3.1 JConsole: Java监视与管理控制台\"></a>3.1 JConsole: Java监视与管理控制台</h2><h2 id=\"3-2-VisualVM-多合一故障处理工具\"><a href=\"#3-2-VisualVM-多合一故障处理工具\" class=\"headerlink\" title=\"3.2 VisualVM: 多合一故障处理工具\"></a>3.2 VisualVM: 多合一故障处理工具</h2>","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>\n<p>我们在定位JVM的问题是往往会借助各种工具去定位JVM异常，Sun公司就提供了一些工具，这些工具的功能都十分强大，能帮助我们定位故障问题，解决程序性能等问题。</p>","more":"<h1 id=\"2-JVM自带命令行工具\"><a href=\"#2-JVM自带命令行工具\" class=\"headerlink\" title=\"2.JVM自带命令行工具\"></a>2.JVM自带命令行工具</h1><p>Sum公司提供提供的JVM监控和故障处理工具主要是下表列出的几个，我们在了解了它们的使用之后能为我们带来极大的便利，当然现在很多公司也为我们提供了很多图形化的工具，如：JProfile等，但是我还是觉得了解JDK自带的工具还是很有必要的，毕竟JProfile也是收费的，我在使用JProfile的时候就因为激活码的问题而折腾了好久，最终好像只有JProfile 9版本的才能使用网上的激活码免费使用。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>名称</strong></th>\n<th align=\"left\"><strong>主要作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">jps</td>\n<td align=\"left\">JVM process Status Tool，显示系统内所有的HotSpot虚拟机进程</td>\n</tr>\n<tr>\n<td align=\"center\">jstat</td>\n<td align=\"left\">JVM Statistics Monitoring Tool，用于手机HotSpot虚拟机各方面的运行数据</td>\n</tr>\n<tr>\n<td align=\"center\">jinfo</td>\n<td align=\"left\">Configuration Info for Java，显示虚拟机配置信息</td>\n</tr>\n<tr>\n<td align=\"center\">jmap</td>\n<td align=\"left\">Memory Map for Java，生成虚拟机内存转储快照（heapdump文件）</td>\n</tr>\n<tr>\n<td align=\"center\">jhat</td>\n<td align=\"left\">JVM Heap Dump Browser，用户分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</td>\n</tr>\n<tr>\n<td align=\"center\">jstack</td>\n<td align=\"left\">Stack Trace for Java，显示虚拟机线程快照</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-1-jps命令\"><a href=\"#2-1-jps命令\" class=\"headerlink\" title=\"2.1 jps命令\"></a>2.1 <strong>jps</strong>命令</h2><p>用与获取java进程的LVMID，对于本地虚拟机来说LVMID和PID是相同的。这个命令是基础，许多命令都是依赖这个命令输出的PID才能操作。所以比较重要。</p>\n<ul>\n<li>命令格式<blockquote>\n<p>jps [options] <pid></p>\n</blockquote>\n</li>\n<li>命令参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>参数</strong></th>\n<th align=\"left\"><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">-q</td>\n<td align=\"left\">只输出pid 省略主类名称</td>\n</tr>\n<tr>\n<td align=\"center\">-m</td>\n<td align=\"left\">输出JVM进程启动是传递给主类main()函数的参数</td>\n</tr>\n<tr>\n<td align=\"center\">-l</td>\n<td align=\"left\">输出主类的全名，如果是Jar包，则输出Jar路径</td>\n</tr>\n<tr>\n<td align=\"center\">-v</td>\n<td align=\"left\">输出JVM进程启动是的参数</td>\n</tr>\n</tbody></table>\n<ul>\n<li>执行样例<br>jps -l <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jps -l</span><br><span class=\"line\">568</span><br><span class=\"line\">26985 sun.tools.jps.Jps</span><br><span class=\"line\">26732 org.jetbrains.jps.cmdline.Launcher</span><br><span class=\"line\">26588 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class=\"line\">26733 com.jiafly.libra.LibraPayApplication</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<h2 id=\"2-2-jstat命令\"><a href=\"#2-2-jstat命令\" class=\"headerlink\" title=\"2.2 jstat命令\"></a>2.2 <strong>jstat</strong>命令</h2><p>用于见识虚拟机各种运行状态信息的命令行工具。可以显示本地或者远程虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据。但是他没有图形界面，只能纯文本展示。</p>\n<ul>\n<li>命令格式<blockquote>\n<p>jstat [option vmid [interval[s|ms] [count]]]</p>\n</blockquote>\n</li>\n<li>命令参数<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jstat -options</span><br><span class=\"line\">-class 监视类装载，卸载数量，总空间以及类装载所消耗的时间</span><br><span class=\"line\">-compiler 输出JIT编译器编译过的方法，耗时信息</span><br><span class=\"line\">-gc 监视Java堆，Eden区 S0,S1 元空间等容量信息</span><br><span class=\"line\">-gccapacity 与-gc基本相同，但主要关注Java堆各个区域使用到的最大 最小空间</span><br><span class=\"line\">-gccause 与-gcutil功能一样，但是会输出导致上一次GC产生的原因</span><br><span class=\"line\">-gcmetacapacity 元空间使用到的最大 最小空间</span><br><span class=\"line\">-gcnew 监视新生代GC状况</span><br><span class=\"line\">-gcnewcapacity 新生代使用到的最大 最小空间</span><br><span class=\"line\">-gcold 监视老年代GC状况</span><br><span class=\"line\">-gcoldcapacity 老年代使用到的最大 最小空间</span><br><span class=\"line\">-gcutil 监视内容与-gc基本相同，但输出主要管制已使用空间占总空间占比</span><br><span class=\"line\">-printcompilation 输出已经被JIT编译的方法</span><br></pre></td></tr></table></figure></li>\n<li>执行样例<br>jstat -gcutil 26733<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jstat -gcutil 26733</span><br><span class=\"line\">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class=\"line\">  0.00   0.00  15.73  26.29  96.45  94.00     10    0.109     3    0.249    0.358</span><br></pre></td></tr></table></figure>\n<ul>\n<li>0：幸存1区当前使用比例</li>\n<li>S1：幸存2区当前使用比例</li>\n<li>E：伊甸园区使用比例</li>\n<li>O：老年代使用比例</li>\n<li>M：元数据区使用比例</li>\n<li>CCS：压缩使用比例</li>\n<li>YGC：年轻代垃圾回收次数</li>\n<li>FGC：老年代垃圾回收次数</li>\n<li>FGCT：老年代垃圾回收消耗时间</li>\n<li>GCT：垃圾回收消耗总时间</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-3-jinfo命令\"><a href=\"#2-3-jinfo命令\" class=\"headerlink\" title=\"2.3 jinfo命令\"></a>2.3 <strong>jinfo</strong>命令</h2><ul>\n<li><p>命令格式</p>\n<blockquote>\n<p>jinfo [option] <pid></p>\n</blockquote>\n</li>\n<li><p>命令参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jinfo -h</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jinfo [option] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">where &lt;option&gt; is one of:</span><br><span class=\"line\">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class=\"line\">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class=\"line\">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class=\"line\">    -flags               to print VM flags</span><br><span class=\"line\">    -sysprops            to print Java system properties</span><br><span class=\"line\">    &lt;no option&gt;          to print both of the above</span><br><span class=\"line\">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure></li>\n<li><p>执行样例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jinfo -flag ReservedCodeCacheSize 27043</span><br><span class=\"line\">-XX:ReservedCodeCacheSize=251658240</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"2-4-jmap命令\"><a href=\"#2-4-jmap命令\" class=\"headerlink\" title=\"2.4 jmap命令\"></a>2.4 <strong>jmap</strong>命令</h2><ul>\n<li><p>命令格式</p>\n<blockquote>\n<p>jmap [option] <pid></p>\n</blockquote>\n</li>\n<li><p>命令参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jmap -h</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jmap [option] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">where &lt;option&gt; is one of:</span><br><span class=\"line\">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class=\"line\">    -heap                to print java heap summary</span><br><span class=\"line\">    -histo[:live]        to print histogram of java object heap; if the \"live\"</span><br><span class=\"line\">                         suboption is specified, only count live objects</span><br><span class=\"line\">    -clstats             to print class loader statistics</span><br><span class=\"line\">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class=\"line\">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class=\"line\">                         dump-options:</span><br><span class=\"line\">                           live         dump only live objects; if not specified,</span><br><span class=\"line\">                                        all objects in the heap are dumped.</span><br><span class=\"line\">                           format=b     binary format</span><br><span class=\"line\">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class=\"line\">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class=\"line\">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class=\"line\">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class=\"line\">                         respond. The \"live\" suboption is not supported</span><br><span class=\"line\">                         in this mode.</span><br><span class=\"line\">    -h | -help           to print this help message</span><br><span class=\"line\">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure></li>\n<li><p>执行样例</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmap -dump:format=b,file=eclipse.bin 3500</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"2-5-jhat命令\"><a href=\"#2-5-jhat命令\" class=\"headerlink\" title=\"2.5 jhat命令\"></a>2.5 <strong>jhat</strong>命令</h2><p>与jmap搭配使用，用来分析jmap生成的dump文件。内置了HTTP/HTML服务器，可以在浏览器中查看。</p>\n<ul>\n<li>执行样例<br>jhat eclipse.bin<br>执行后屏幕显示“Server is ready.”然后再浏览器输入<a href=\"http://localhost:7000\" target=\"_blank\" rel=\"noopener\">http://localhost:7000</a>就可以看到分析结果。</li>\n</ul>\n<h2 id=\"2-6-jstack命令\"><a href=\"#2-6-jstack命令\" class=\"headerlink\" title=\"2.6 jstack命令\"></a>2.6 <strong>jstack</strong>命令</h2><p>Java堆栈跟踪工具，用于生成虚拟机当前时刻的线程快照。用于定位线程出现长时间停顿的原因，如：线程间死锁，死循环，请求外部资源导致长时间等待等。</p>\n<ul>\n<li>命令格式<br>jstack [option] pid</li>\n<li>命令参数<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">liuyi@liuyideMacBook-Pro:~$ jstack -h</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jstack [-l] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to a hung process)</span><br><span class=\"line\">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to a remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">Options:</span><br><span class=\"line\">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class=\"line\">    -m  to print both java and native frames (mixed mode)</span><br><span class=\"line\">    -l  long listing. Prints additional information about locks</span><br><span class=\"line\">    -h or -help to print this help message</span><br></pre></td></tr></table></figure></li>\n<li>执行样例<br>jstack -l 27043</li>\n</ul>\n<h1 id=\"3-JVM自带可视化工具\"><a href=\"#3-JVM自带可视化工具\" class=\"headerlink\" title=\"3.JVM自带可视化工具\"></a>3.JVM自带可视化工具</h1><p>JVM自带的可视化工具在分析JVM问题的时候还是很有用处的，能够直观的从图形界面看出变化。方便我们能快速定位到JVM的问题。</p>\n<h2 id=\"3-1-JConsole-Java监视与管理控制台\"><a href=\"#3-1-JConsole-Java监视与管理控制台\" class=\"headerlink\" title=\"3.1 JConsole: Java监视与管理控制台\"></a>3.1 JConsole: Java监视与管理控制台</h2><h2 id=\"3-2-VisualVM-多合一故障处理工具\"><a href=\"#3-2-VisualVM-多合一故障处理工具\" class=\"headerlink\" title=\"3.2 VisualVM: 多合一故障处理工具\"></a>3.2 VisualVM: 多合一故障处理工具</h2>"},{"title":"JVM系列-垃圾回收(GC)","date":"2019-05-27T04:00:00.000Z","notshow":true,"_content":"# 1.GC概述\n一说到GC我们就很容易的联想到了Java，并把它当做是Java的附属。其实不然，GC的历史早在1960年的Lisp语言上就被使用，所以它的产生比Java还早，只能说Java借鉴了这种技术，并且有更多的实现算法。\n<!-- more -->\n## 1.1 什么是GC\n**GC**(Garbage Collection) 从字面意思上看就是`垃圾收集`的意思。这里的垃圾也就是在系统运行过程中所产生的一些已经无用的对象，而这些无用的对象是占据着一点的内存空间的，如果这些对象不及时被释放掉，长此以往，就会导致内存用完，也就是内存溢出。垃圾回收就是保证这些无用的对象能够及时的被回收，保证系统的正常运行。在Java中GC的作用的对象主要是堆和永久区的无用对象。\n\n## 1.2 GC的优点\n在C和C++语言中主要是由程序员手动去管理内存释放垃圾的回收，但是在Java语言则实现了许多垃圾回收算法，JVM能够自动回收无用对象，而不需要有Javaer手动去操作。这样大大提升了我们在写代码时候的效率，因为不需要过多的去考虑内存的使用情况了，注意：这里是`不需要过多`而不是不需要考虑，对于Java进阶者来说JVM的调优也是相当重要的。\n\n# 2.对象已死？\n我们都知道无用的对象将会被GC，但是如何确定一个对象是无用对象呢，在这里Java主要有三种方法。\n- **引用计数法**\n- **可达性分析算法**\n- **回收方法区**\n\n## 2.1 引用计数法\n引用计数法是垃圾回收器的早期策略。在这个方法中堆中的每个对象都有一个计数，当被引用时计数+1 当失去一个引用时就+1。任何一个引用计数为0的对象都会被垃圾回收。\n\n这种算法也存在两个问题:\n- 频繁的对对象计数+1或者-1操作，影响性能\n- 循环引用问题\n    例如:当一个对象A被根节点R引用，然后A又被B引用，B被C引用，C又被A引用，这样ABC三个对象就是循环引用，A的引用计数为2 当根节点不再引用A的时候 A对象其实在内存中也没什么作用了，但是此时A的引用计数还是1，不可能被回收，所以内存就得不到释放。\n\n## 2.2 可达性分析法\n可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。\n\n在Java语言中，可作为GC Root的对象包括下面几种：\n- a.虚拟机栈中引用的对象（栈帧中的本地变量表）\n- b.方法区中类静态属性引用的对象  \n- c.方法区中常量引用的对象 \n- d.本地方法栈中JNI（Native方法）引用的对象 \n\n即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。\n- **第一次标记**\n如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记\n- **第二次标记**\n第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。\n\n第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。\n\n## 2.3 回收方法区\n方法区存储内容是否需要回收的判断和上面介绍的两种方法是不一样的。\n\n方法区主要回收的内容有：废弃`常量`和`无用的类`。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：\n- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例\n- 加载该类的ClassLoader已经被回收\n- 该类对应的java.lang.Class对象没有在任何地方被引用。即:无法在任何地方通过反射访问该类的方法\n\n# 3.GC算法\n关于垃圾回收的算法在java中主要有一下四种，这四种也是各有优缺点，所以对于不同的对象收集也是采用了不同的算法实现。\n- **标记-清除算法**\n- **标记-整理算法**\n- **复制算法**\n- **分代收集算法**\n\n## 3.1 标记-清除算法\n### 3.1.1 介绍\n标记-清除算法是现代垃圾回收算法的思想基础。\n\n标记-清除算法的做法是在堆内存即将耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两个阶段的操作:标记阶段和清除阶段。\n- **标记**\n标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。\n- **清除**\n清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。\n\n### 3.1.2 优缺点\n- **效率问题**\n因为(**标记**)需要遍历堆中的所有对象，而且(**清除**)在GC的时候会暂停整个程序，所以效率比较低。\n- **空间问题**\n标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n## 3.2 复制算法\n### 3.2.1 介绍\n它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n\n目前商用虚拟机大都使用这一算法回收新生代。将内存划分为一个较大的 Eden 区和两块较小的 Survivor。在HotSpot虚拟机中 Eden：Survivor = 8：1\n### 3.2.2 优缺点\n- 优点\n    - 该算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指 \n针，按顺序分配内存即可，实现简单，运行高效。\n- 缺点\n    - 可用的内存空间仅仅只有原内存空间的一半，也就是说有一半的内存空间被浪费。  \n\n## 3.3 标记-整理算法\n### 3.3.1 介绍\n在复制算法中如果该内存区域对象存活率较高的话，就需要频繁的复制操作，效率非常低下（比如老年代中的对内存区域）这时候`标记-整理算法`就适合用于这种存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化，使得空闲空间连续。和标记-清除算法一样，标记-整理算法也分为两个阶段。\n- **标记** \n遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。\n- **整理** \n将所有的存活对象移动到内存的一端。之后，清理边界外所有的空间。\n\n### 3.3.2 优缺点\n- 优点\n    - 堆利用效率高\n    - 无碎片\n    - 对象顺序未变\n\n## 3.4 分代收集算法\n### 3.4.1 介绍\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为`新生代`和`老年代`，这样就可以根据各个年代的特点采用最适合的收集算法。在**新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法只需要付出少量存活对象的复制成本就可以完成**。而**老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收**。`方法区永久代`，回收方法和`老年代`相同。\n\n\n# 4.STW(stop-the-world)\nSTW是Java中一种全局暂停的现象。`全局停顿`是指所有Java代码停止，native代码可以执行，但不能和JVM交互，STW多半由于GC引起的。例如:\n- Dump线程\n- 死锁检查\n- 堆Dump\n\n## 4.1 GC时为什么会有STW？\n就像我们在聚会的时候，有个保洁进到房间里打扫卫生，刚打扫完又有新的垃圾会扔在地上，房间就永远都打扫不干净。除非我们聚会结束没有人了，这时候打扫才不会产生新的垃圾。同理JVM也是这样，如果想要GC所有的垃圾就会有全局的停顿，以保障所有的垃圾都会被回收。\n\n## 4.2 STW的危害\n- 长时间服务停止，没有响应\n- 遇到HA系统(双机集群系统)，可能引起主备切换，严重危害生产环境。\n\n# 5.结语\nJVM对于javaer进阶是有着非常重要的作用的，而GC可以说是JVM中比较重要的一块了，掌握GC也有利于我们能更加明确的了解JVM。从而在我们以后的工作中，能够考虑到关于内存回收，不在让内存成为我们程序运行的瓶颈。\n\n\n一起加油吧。\n\n\n\n","source":"_posts/jvm/JVM系列-垃圾回收(GC).md","raw":"---\ntitle: JVM系列-垃圾回收(GC)\ndate: 2019-05-27 12:00:00\ntags:\n    - JVM\n    - GC\n    - 垃圾回收\ncategories:\n    - JVM\nnotshow: true\n---\n# 1.GC概述\n一说到GC我们就很容易的联想到了Java，并把它当做是Java的附属。其实不然，GC的历史早在1960年的Lisp语言上就被使用，所以它的产生比Java还早，只能说Java借鉴了这种技术，并且有更多的实现算法。\n<!-- more -->\n## 1.1 什么是GC\n**GC**(Garbage Collection) 从字面意思上看就是`垃圾收集`的意思。这里的垃圾也就是在系统运行过程中所产生的一些已经无用的对象，而这些无用的对象是占据着一点的内存空间的，如果这些对象不及时被释放掉，长此以往，就会导致内存用完，也就是内存溢出。垃圾回收就是保证这些无用的对象能够及时的被回收，保证系统的正常运行。在Java中GC的作用的对象主要是堆和永久区的无用对象。\n\n## 1.2 GC的优点\n在C和C++语言中主要是由程序员手动去管理内存释放垃圾的回收，但是在Java语言则实现了许多垃圾回收算法，JVM能够自动回收无用对象，而不需要有Javaer手动去操作。这样大大提升了我们在写代码时候的效率，因为不需要过多的去考虑内存的使用情况了，注意：这里是`不需要过多`而不是不需要考虑，对于Java进阶者来说JVM的调优也是相当重要的。\n\n# 2.对象已死？\n我们都知道无用的对象将会被GC，但是如何确定一个对象是无用对象呢，在这里Java主要有三种方法。\n- **引用计数法**\n- **可达性分析算法**\n- **回收方法区**\n\n## 2.1 引用计数法\n引用计数法是垃圾回收器的早期策略。在这个方法中堆中的每个对象都有一个计数，当被引用时计数+1 当失去一个引用时就+1。任何一个引用计数为0的对象都会被垃圾回收。\n\n这种算法也存在两个问题:\n- 频繁的对对象计数+1或者-1操作，影响性能\n- 循环引用问题\n    例如:当一个对象A被根节点R引用，然后A又被B引用，B被C引用，C又被A引用，这样ABC三个对象就是循环引用，A的引用计数为2 当根节点不再引用A的时候 A对象其实在内存中也没什么作用了，但是此时A的引用计数还是1，不可能被回收，所以内存就得不到释放。\n\n## 2.2 可达性分析法\n可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。\n\n在Java语言中，可作为GC Root的对象包括下面几种：\n- a.虚拟机栈中引用的对象（栈帧中的本地变量表）\n- b.方法区中类静态属性引用的对象  \n- c.方法区中常量引用的对象 \n- d.本地方法栈中JNI（Native方法）引用的对象 \n\n即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。\n- **第一次标记**\n如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记\n- **第二次标记**\n第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。\n\n第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。\n\n## 2.3 回收方法区\n方法区存储内容是否需要回收的判断和上面介绍的两种方法是不一样的。\n\n方法区主要回收的内容有：废弃`常量`和`无用的类`。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：\n- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例\n- 加载该类的ClassLoader已经被回收\n- 该类对应的java.lang.Class对象没有在任何地方被引用。即:无法在任何地方通过反射访问该类的方法\n\n# 3.GC算法\n关于垃圾回收的算法在java中主要有一下四种，这四种也是各有优缺点，所以对于不同的对象收集也是采用了不同的算法实现。\n- **标记-清除算法**\n- **标记-整理算法**\n- **复制算法**\n- **分代收集算法**\n\n## 3.1 标记-清除算法\n### 3.1.1 介绍\n标记-清除算法是现代垃圾回收算法的思想基础。\n\n标记-清除算法的做法是在堆内存即将耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两个阶段的操作:标记阶段和清除阶段。\n- **标记**\n标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。\n- **清除**\n清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。\n\n### 3.1.2 优缺点\n- **效率问题**\n因为(**标记**)需要遍历堆中的所有对象，而且(**清除**)在GC的时候会暂停整个程序，所以效率比较低。\n- **空间问题**\n标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n## 3.2 复制算法\n### 3.2.1 介绍\n它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n\n目前商用虚拟机大都使用这一算法回收新生代。将内存划分为一个较大的 Eden 区和两块较小的 Survivor。在HotSpot虚拟机中 Eden：Survivor = 8：1\n### 3.2.2 优缺点\n- 优点\n    - 该算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指 \n针，按顺序分配内存即可，实现简单，运行高效。\n- 缺点\n    - 可用的内存空间仅仅只有原内存空间的一半，也就是说有一半的内存空间被浪费。  \n\n## 3.3 标记-整理算法\n### 3.3.1 介绍\n在复制算法中如果该内存区域对象存活率较高的话，就需要频繁的复制操作，效率非常低下（比如老年代中的对内存区域）这时候`标记-整理算法`就适合用于这种存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化，使得空闲空间连续。和标记-清除算法一样，标记-整理算法也分为两个阶段。\n- **标记** \n遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。\n- **整理** \n将所有的存活对象移动到内存的一端。之后，清理边界外所有的空间。\n\n### 3.3.2 优缺点\n- 优点\n    - 堆利用效率高\n    - 无碎片\n    - 对象顺序未变\n\n## 3.4 分代收集算法\n### 3.4.1 介绍\n当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为`新生代`和`老年代`，这样就可以根据各个年代的特点采用最适合的收集算法。在**新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法只需要付出少量存活对象的复制成本就可以完成**。而**老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收**。`方法区永久代`，回收方法和`老年代`相同。\n\n\n# 4.STW(stop-the-world)\nSTW是Java中一种全局暂停的现象。`全局停顿`是指所有Java代码停止，native代码可以执行，但不能和JVM交互，STW多半由于GC引起的。例如:\n- Dump线程\n- 死锁检查\n- 堆Dump\n\n## 4.1 GC时为什么会有STW？\n就像我们在聚会的时候，有个保洁进到房间里打扫卫生，刚打扫完又有新的垃圾会扔在地上，房间就永远都打扫不干净。除非我们聚会结束没有人了，这时候打扫才不会产生新的垃圾。同理JVM也是这样，如果想要GC所有的垃圾就会有全局的停顿，以保障所有的垃圾都会被回收。\n\n## 4.2 STW的危害\n- 长时间服务停止，没有响应\n- 遇到HA系统(双机集群系统)，可能引起主备切换，严重危害生产环境。\n\n# 5.结语\nJVM对于javaer进阶是有着非常重要的作用的，而GC可以说是JVM中比较重要的一块了，掌握GC也有利于我们能更加明确的了解JVM。从而在我们以后的工作中，能够考虑到关于内存回收，不在让内存成为我们程序运行的瓶颈。\n\n\n一起加油吧。\n\n\n\n","slug":"jvm/JVM系列-垃圾回收(GC)","published":1,"updated":"2019-09-05T03:26:32.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcou000xjfusbovqbhwe","content":"<h1 id=\"1-GC概述\"><a href=\"#1-GC概述\" class=\"headerlink\" title=\"1.GC概述\"></a>1.GC概述</h1><p>一说到GC我们就很容易的联想到了Java，并把它当做是Java的附属。其实不然，GC的历史早在1960年的Lisp语言上就被使用，所以它的产生比Java还早，只能说Java借鉴了这种技术，并且有更多的实现算法。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-1-什么是GC\"><a href=\"#1-1-什么是GC\" class=\"headerlink\" title=\"1.1 什么是GC\"></a>1.1 什么是GC</h2><p><strong>GC</strong>(Garbage Collection) 从字面意思上看就是<code>垃圾收集</code>的意思。这里的垃圾也就是在系统运行过程中所产生的一些已经无用的对象，而这些无用的对象是占据着一点的内存空间的，如果这些对象不及时被释放掉，长此以往，就会导致内存用完，也就是内存溢出。垃圾回收就是保证这些无用的对象能够及时的被回收，保证系统的正常运行。在Java中GC的作用的对象主要是堆和永久区的无用对象。</p>\n<h2 id=\"1-2-GC的优点\"><a href=\"#1-2-GC的优点\" class=\"headerlink\" title=\"1.2 GC的优点\"></a>1.2 GC的优点</h2><p>在C和C++语言中主要是由程序员手动去管理内存释放垃圾的回收，但是在Java语言则实现了许多垃圾回收算法，JVM能够自动回收无用对象，而不需要有Javaer手动去操作。这样大大提升了我们在写代码时候的效率，因为不需要过多的去考虑内存的使用情况了，注意：这里是<code>不需要过多</code>而不是不需要考虑，对于Java进阶者来说JVM的调优也是相当重要的。</p>\n<h1 id=\"2-对象已死？\"><a href=\"#2-对象已死？\" class=\"headerlink\" title=\"2.对象已死？\"></a>2.对象已死？</h1><p>我们都知道无用的对象将会被GC，但是如何确定一个对象是无用对象呢，在这里Java主要有三种方法。</p>\n<ul>\n<li><strong>引用计数法</strong></li>\n<li><strong>可达性分析算法</strong></li>\n<li><strong>回收方法区</strong></li>\n</ul>\n<h2 id=\"2-1-引用计数法\"><a href=\"#2-1-引用计数法\" class=\"headerlink\" title=\"2.1 引用计数法\"></a>2.1 引用计数法</h2><p>引用计数法是垃圾回收器的早期策略。在这个方法中堆中的每个对象都有一个计数，当被引用时计数+1 当失去一个引用时就+1。任何一个引用计数为0的对象都会被垃圾回收。</p>\n<p>这种算法也存在两个问题:</p>\n<ul>\n<li>频繁的对对象计数+1或者-1操作，影响性能</li>\n<li>循环引用问题<br>  例如:当一个对象A被根节点R引用，然后A又被B引用，B被C引用，C又被A引用，这样ABC三个对象就是循环引用，A的引用计数为2 当根节点不再引用A的时候 A对象其实在内存中也没什么作用了，但是此时A的引用计数还是1，不可能被回收，所以内存就得不到释放。</li>\n</ul>\n<h2 id=\"2-2-可达性分析法\"><a href=\"#2-2-可达性分析法\" class=\"headerlink\" title=\"2.2 可达性分析法\"></a>2.2 可达性分析法</h2><p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p>\n<p>在Java语言中，可作为GC Root的对象包括下面几种：</p>\n<ul>\n<li>a.虚拟机栈中引用的对象（栈帧中的本地变量表）</li>\n<li>b.方法区中类静态属性引用的对象  </li>\n<li>c.方法区中常量引用的对象 </li>\n<li>d.本地方法栈中JNI（Native方法）引用的对象 </li>\n</ul>\n<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p>\n<ul>\n<li><strong>第一次标记</strong><br>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记</li>\n<li><strong>第二次标记</strong><br>第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</li>\n</ul>\n<p>第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p>\n<h2 id=\"2-3-回收方法区\"><a href=\"#2-3-回收方法区\" class=\"headerlink\" title=\"2.3 回收方法区\"></a>2.3 回收方法区</h2><p>方法区存储内容是否需要回收的判断和上面介绍的两种方法是不一样的。</p>\n<p>方法区主要回收的内容有：废弃<code>常量</code>和<code>无用的类</code>。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li>\n<li>加载该类的ClassLoader已经被回收</li>\n<li>该类对应的java.lang.Class对象没有在任何地方被引用。即:无法在任何地方通过反射访问该类的方法</li>\n</ul>\n<h1 id=\"3-GC算法\"><a href=\"#3-GC算法\" class=\"headerlink\" title=\"3.GC算法\"></a>3.GC算法</h1><p>关于垃圾回收的算法在java中主要有一下四种，这四种也是各有优缺点，所以对于不同的对象收集也是采用了不同的算法实现。</p>\n<ul>\n<li><strong>标记-清除算法</strong></li>\n<li><strong>标记-整理算法</strong></li>\n<li><strong>复制算法</strong></li>\n<li><strong>分代收集算法</strong></li>\n</ul>\n<h2 id=\"3-1-标记-清除算法\"><a href=\"#3-1-标记-清除算法\" class=\"headerlink\" title=\"3.1 标记-清除算法\"></a>3.1 标记-清除算法</h2><h3 id=\"3-1-1-介绍\"><a href=\"#3-1-1-介绍\" class=\"headerlink\" title=\"3.1.1 介绍\"></a>3.1.1 介绍</h3><p>标记-清除算法是现代垃圾回收算法的思想基础。</p>\n<p>标记-清除算法的做法是在堆内存即将耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两个阶段的操作:标记阶段和清除阶段。</p>\n<ul>\n<li><strong>标记</strong><br>标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li>\n<li><strong>清除</strong><br>清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li>\n</ul>\n<h3 id=\"3-1-2-优缺点\"><a href=\"#3-1-2-优缺点\" class=\"headerlink\" title=\"3.1.2 优缺点\"></a>3.1.2 优缺点</h3><ul>\n<li><strong>效率问题</strong><br>因为(<strong>标记</strong>)需要遍历堆中的所有对象，而且(<strong>清除</strong>)在GC的时候会暂停整个程序，所以效率比较低。</li>\n<li><strong>空间问题</strong><br>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>\n</ul>\n<h2 id=\"3-2-复制算法\"><a href=\"#3-2-复制算法\" class=\"headerlink\" title=\"3.2 复制算法\"></a>3.2 复制算法</h2><h3 id=\"3-2-1-介绍\"><a href=\"#3-2-1-介绍\" class=\"headerlink\" title=\"3.2.1 介绍\"></a>3.2.1 介绍</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>\n<p>目前商用虚拟机大都使用这一算法回收新生代。将内存划分为一个较大的 Eden 区和两块较小的 Survivor。在HotSpot虚拟机中 Eden：Survivor = 8：1</p>\n<h3 id=\"3-2-2-优缺点\"><a href=\"#3-2-2-优缺点\" class=\"headerlink\" title=\"3.2.2 优缺点\"></a>3.2.2 优缺点</h3><ul>\n<li>优点<ul>\n<li>该算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指<br>针，按顺序分配内存即可，实现简单，运行高效。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>可用的内存空间仅仅只有原内存空间的一半，也就是说有一半的内存空间被浪费。  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-3-标记-整理算法\"><a href=\"#3-3-标记-整理算法\" class=\"headerlink\" title=\"3.3 标记-整理算法\"></a>3.3 标记-整理算法</h2><h3 id=\"3-3-1-介绍\"><a href=\"#3-3-1-介绍\" class=\"headerlink\" title=\"3.3.1 介绍\"></a>3.3.1 介绍</h3><p>在复制算法中如果该内存区域对象存活率较高的话，就需要频繁的复制操作，效率非常低下（比如老年代中的对内存区域）这时候<code>标记-整理算法</code>就适合用于这种存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化，使得空闲空间连续。和标记-清除算法一样，标记-整理算法也分为两个阶段。</p>\n<ul>\n<li><strong>标记</strong><br>遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li>\n<li><strong>整理</strong><br>将所有的存活对象移动到内存的一端。之后，清理边界外所有的空间。</li>\n</ul>\n<h3 id=\"3-3-2-优缺点\"><a href=\"#3-3-2-优缺点\" class=\"headerlink\" title=\"3.3.2 优缺点\"></a>3.3.2 优缺点</h3><ul>\n<li>优点<ul>\n<li>堆利用效率高</li>\n<li>无碎片</li>\n<li>对象顺序未变</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-4-分代收集算法\"><a href=\"#3-4-分代收集算法\" class=\"headerlink\" title=\"3.4 分代收集算法\"></a>3.4 分代收集算法</h2><h3 id=\"3-4-1-介绍\"><a href=\"#3-4-1-介绍\" class=\"headerlink\" title=\"3.4.1 介绍\"></a>3.4.1 介绍</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为<code>新生代</code>和<code>老年代</code>，这样就可以根据各个年代的特点采用最适合的收集算法。在<strong>新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法只需要付出少量存活对象的复制成本就可以完成</strong>。而<strong>老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收</strong>。<code>方法区永久代</code>，回收方法和<code>老年代</code>相同。</p>\n<h1 id=\"4-STW-stop-the-world\"><a href=\"#4-STW-stop-the-world\" class=\"headerlink\" title=\"4.STW(stop-the-world)\"></a>4.STW(stop-the-world)</h1><p>STW是Java中一种全局暂停的现象。<code>全局停顿</code>是指所有Java代码停止，native代码可以执行，但不能和JVM交互，STW多半由于GC引起的。例如:</p>\n<ul>\n<li>Dump线程</li>\n<li>死锁检查</li>\n<li>堆Dump</li>\n</ul>\n<h2 id=\"4-1-GC时为什么会有STW？\"><a href=\"#4-1-GC时为什么会有STW？\" class=\"headerlink\" title=\"4.1 GC时为什么会有STW？\"></a>4.1 GC时为什么会有STW？</h2><p>就像我们在聚会的时候，有个保洁进到房间里打扫卫生，刚打扫完又有新的垃圾会扔在地上，房间就永远都打扫不干净。除非我们聚会结束没有人了，这时候打扫才不会产生新的垃圾。同理JVM也是这样，如果想要GC所有的垃圾就会有全局的停顿，以保障所有的垃圾都会被回收。</p>\n<h2 id=\"4-2-STW的危害\"><a href=\"#4-2-STW的危害\" class=\"headerlink\" title=\"4.2 STW的危害\"></a>4.2 STW的危害</h2><ul>\n<li>长时间服务停止，没有响应</li>\n<li>遇到HA系统(双机集群系统)，可能引起主备切换，严重危害生产环境。</li>\n</ul>\n<h1 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5.结语\"></a>5.结语</h1><p>JVM对于javaer进阶是有着非常重要的作用的，而GC可以说是JVM中比较重要的一块了，掌握GC也有利于我们能更加明确的了解JVM。从而在我们以后的工作中，能够考虑到关于内存回收，不在让内存成为我们程序运行的瓶颈。</p>\n<p>一起加油吧。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-GC概述\"><a href=\"#1-GC概述\" class=\"headerlink\" title=\"1.GC概述\"></a>1.GC概述</h1><p>一说到GC我们就很容易的联想到了Java，并把它当做是Java的附属。其实不然，GC的历史早在1960年的Lisp语言上就被使用，所以它的产生比Java还早，只能说Java借鉴了这种技术，并且有更多的实现算法。</p>","more":"<h2 id=\"1-1-什么是GC\"><a href=\"#1-1-什么是GC\" class=\"headerlink\" title=\"1.1 什么是GC\"></a>1.1 什么是GC</h2><p><strong>GC</strong>(Garbage Collection) 从字面意思上看就是<code>垃圾收集</code>的意思。这里的垃圾也就是在系统运行过程中所产生的一些已经无用的对象，而这些无用的对象是占据着一点的内存空间的，如果这些对象不及时被释放掉，长此以往，就会导致内存用完，也就是内存溢出。垃圾回收就是保证这些无用的对象能够及时的被回收，保证系统的正常运行。在Java中GC的作用的对象主要是堆和永久区的无用对象。</p>\n<h2 id=\"1-2-GC的优点\"><a href=\"#1-2-GC的优点\" class=\"headerlink\" title=\"1.2 GC的优点\"></a>1.2 GC的优点</h2><p>在C和C++语言中主要是由程序员手动去管理内存释放垃圾的回收，但是在Java语言则实现了许多垃圾回收算法，JVM能够自动回收无用对象，而不需要有Javaer手动去操作。这样大大提升了我们在写代码时候的效率，因为不需要过多的去考虑内存的使用情况了，注意：这里是<code>不需要过多</code>而不是不需要考虑，对于Java进阶者来说JVM的调优也是相当重要的。</p>\n<h1 id=\"2-对象已死？\"><a href=\"#2-对象已死？\" class=\"headerlink\" title=\"2.对象已死？\"></a>2.对象已死？</h1><p>我们都知道无用的对象将会被GC，但是如何确定一个对象是无用对象呢，在这里Java主要有三种方法。</p>\n<ul>\n<li><strong>引用计数法</strong></li>\n<li><strong>可达性分析算法</strong></li>\n<li><strong>回收方法区</strong></li>\n</ul>\n<h2 id=\"2-1-引用计数法\"><a href=\"#2-1-引用计数法\" class=\"headerlink\" title=\"2.1 引用计数法\"></a>2.1 引用计数法</h2><p>引用计数法是垃圾回收器的早期策略。在这个方法中堆中的每个对象都有一个计数，当被引用时计数+1 当失去一个引用时就+1。任何一个引用计数为0的对象都会被垃圾回收。</p>\n<p>这种算法也存在两个问题:</p>\n<ul>\n<li>频繁的对对象计数+1或者-1操作，影响性能</li>\n<li>循环引用问题<br>  例如:当一个对象A被根节点R引用，然后A又被B引用，B被C引用，C又被A引用，这样ABC三个对象就是循环引用，A的引用计数为2 当根节点不再引用A的时候 A对象其实在内存中也没什么作用了，但是此时A的引用计数还是1，不可能被回收，所以内存就得不到释放。</li>\n</ul>\n<h2 id=\"2-2-可达性分析法\"><a href=\"#2-2-可达性分析法\" class=\"headerlink\" title=\"2.2 可达性分析法\"></a>2.2 可达性分析法</h2><p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p>\n<p>在Java语言中，可作为GC Root的对象包括下面几种：</p>\n<ul>\n<li>a.虚拟机栈中引用的对象（栈帧中的本地变量表）</li>\n<li>b.方法区中类静态属性引用的对象  </li>\n<li>c.方法区中常量引用的对象 </li>\n<li>d.本地方法栈中JNI（Native方法）引用的对象 </li>\n</ul>\n<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p>\n<ul>\n<li><strong>第一次标记</strong><br>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记</li>\n<li><strong>第二次标记</strong><br>第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</li>\n</ul>\n<p>第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p>\n<h2 id=\"2-3-回收方法区\"><a href=\"#2-3-回收方法区\" class=\"headerlink\" title=\"2.3 回收方法区\"></a>2.3 回收方法区</h2><p>方法区存储内容是否需要回收的判断和上面介绍的两种方法是不一样的。</p>\n<p>方法区主要回收的内容有：废弃<code>常量</code>和<code>无用的类</code>。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li>\n<li>加载该类的ClassLoader已经被回收</li>\n<li>该类对应的java.lang.Class对象没有在任何地方被引用。即:无法在任何地方通过反射访问该类的方法</li>\n</ul>\n<h1 id=\"3-GC算法\"><a href=\"#3-GC算法\" class=\"headerlink\" title=\"3.GC算法\"></a>3.GC算法</h1><p>关于垃圾回收的算法在java中主要有一下四种，这四种也是各有优缺点，所以对于不同的对象收集也是采用了不同的算法实现。</p>\n<ul>\n<li><strong>标记-清除算法</strong></li>\n<li><strong>标记-整理算法</strong></li>\n<li><strong>复制算法</strong></li>\n<li><strong>分代收集算法</strong></li>\n</ul>\n<h2 id=\"3-1-标记-清除算法\"><a href=\"#3-1-标记-清除算法\" class=\"headerlink\" title=\"3.1 标记-清除算法\"></a>3.1 标记-清除算法</h2><h3 id=\"3-1-1-介绍\"><a href=\"#3-1-1-介绍\" class=\"headerlink\" title=\"3.1.1 介绍\"></a>3.1.1 介绍</h3><p>标记-清除算法是现代垃圾回收算法的思想基础。</p>\n<p>标记-清除算法的做法是在堆内存即将耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两个阶段的操作:标记阶段和清除阶段。</p>\n<ul>\n<li><strong>标记</strong><br>标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li>\n<li><strong>清除</strong><br>清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。</li>\n</ul>\n<h3 id=\"3-1-2-优缺点\"><a href=\"#3-1-2-优缺点\" class=\"headerlink\" title=\"3.1.2 优缺点\"></a>3.1.2 优缺点</h3><ul>\n<li><strong>效率问题</strong><br>因为(<strong>标记</strong>)需要遍历堆中的所有对象，而且(<strong>清除</strong>)在GC的时候会暂停整个程序，所以效率比较低。</li>\n<li><strong>空间问题</strong><br>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>\n</ul>\n<h2 id=\"3-2-复制算法\"><a href=\"#3-2-复制算法\" class=\"headerlink\" title=\"3.2 复制算法\"></a>3.2 复制算法</h2><h3 id=\"3-2-1-介绍\"><a href=\"#3-2-1-介绍\" class=\"headerlink\" title=\"3.2.1 介绍\"></a>3.2.1 介绍</h3><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>\n<p>目前商用虚拟机大都使用这一算法回收新生代。将内存划分为一个较大的 Eden 区和两块较小的 Survivor。在HotSpot虚拟机中 Eden：Survivor = 8：1</p>\n<h3 id=\"3-2-2-优缺点\"><a href=\"#3-2-2-优缺点\" class=\"headerlink\" title=\"3.2.2 优缺点\"></a>3.2.2 优缺点</h3><ul>\n<li>优点<ul>\n<li>该算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指<br>针，按顺序分配内存即可，实现简单，运行高效。</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>可用的内存空间仅仅只有原内存空间的一半，也就是说有一半的内存空间被浪费。  </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-3-标记-整理算法\"><a href=\"#3-3-标记-整理算法\" class=\"headerlink\" title=\"3.3 标记-整理算法\"></a>3.3 标记-整理算法</h2><h3 id=\"3-3-1-介绍\"><a href=\"#3-3-1-介绍\" class=\"headerlink\" title=\"3.3.1 介绍\"></a>3.3.1 介绍</h3><p>在复制算法中如果该内存区域对象存活率较高的话，就需要频繁的复制操作，效率非常低下（比如老年代中的对内存区域）这时候<code>标记-整理算法</code>就适合用于这种存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化，使得空闲空间连续。和标记-清除算法一样，标记-整理算法也分为两个阶段。</p>\n<ul>\n<li><strong>标记</strong><br>遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。</li>\n<li><strong>整理</strong><br>将所有的存活对象移动到内存的一端。之后，清理边界外所有的空间。</li>\n</ul>\n<h3 id=\"3-3-2-优缺点\"><a href=\"#3-3-2-优缺点\" class=\"headerlink\" title=\"3.3.2 优缺点\"></a>3.3.2 优缺点</h3><ul>\n<li>优点<ul>\n<li>堆利用效率高</li>\n<li>无碎片</li>\n<li>对象顺序未变</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-4-分代收集算法\"><a href=\"#3-4-分代收集算法\" class=\"headerlink\" title=\"3.4 分代收集算法\"></a>3.4 分代收集算法</h2><h3 id=\"3-4-1-介绍\"><a href=\"#3-4-1-介绍\" class=\"headerlink\" title=\"3.4.1 介绍\"></a>3.4.1 介绍</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为<code>新生代</code>和<code>老年代</code>，这样就可以根据各个年代的特点采用最适合的收集算法。在<strong>新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法只需要付出少量存活对象的复制成本就可以完成</strong>。而<strong>老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收</strong>。<code>方法区永久代</code>，回收方法和<code>老年代</code>相同。</p>\n<h1 id=\"4-STW-stop-the-world\"><a href=\"#4-STW-stop-the-world\" class=\"headerlink\" title=\"4.STW(stop-the-world)\"></a>4.STW(stop-the-world)</h1><p>STW是Java中一种全局暂停的现象。<code>全局停顿</code>是指所有Java代码停止，native代码可以执行，但不能和JVM交互，STW多半由于GC引起的。例如:</p>\n<ul>\n<li>Dump线程</li>\n<li>死锁检查</li>\n<li>堆Dump</li>\n</ul>\n<h2 id=\"4-1-GC时为什么会有STW？\"><a href=\"#4-1-GC时为什么会有STW？\" class=\"headerlink\" title=\"4.1 GC时为什么会有STW？\"></a>4.1 GC时为什么会有STW？</h2><p>就像我们在聚会的时候，有个保洁进到房间里打扫卫生，刚打扫完又有新的垃圾会扔在地上，房间就永远都打扫不干净。除非我们聚会结束没有人了，这时候打扫才不会产生新的垃圾。同理JVM也是这样，如果想要GC所有的垃圾就会有全局的停顿，以保障所有的垃圾都会被回收。</p>\n<h2 id=\"4-2-STW的危害\"><a href=\"#4-2-STW的危害\" class=\"headerlink\" title=\"4.2 STW的危害\"></a>4.2 STW的危害</h2><ul>\n<li>长时间服务停止，没有响应</li>\n<li>遇到HA系统(双机集群系统)，可能引起主备切换，严重危害生产环境。</li>\n</ul>\n<h1 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5.结语\"></a>5.结语</h1><p>JVM对于javaer进阶是有着非常重要的作用的，而GC可以说是JVM中比较重要的一块了，掌握GC也有利于我们能更加明确的了解JVM。从而在我们以后的工作中，能够考虑到关于内存回收，不在让内存成为我们程序运行的瓶颈。</p>\n<p>一起加油吧。</p>"},{"title":"一次Spring Security造成的内存泄露","date":"2019-06-28T02:56:00.000Z","notshow":true,"_content":"# 1.前言\n前段时间项目采用Spring Security作为权限框架应用到现有项目中，一切就那么正常的上线了，然而在上线一段时间后，服务监控就在报警，JVM内存泄露了。如是就是接下来的一段异常处理之旅。\n<!-- more -->\n# 2.内存泄露解决流程\n## 2.1 生成线上最新的堆dump文件\n使用命令jmap生成线上java程序的dump文件，我们都知道在这个文件中可以查看堆内对象示例的统计信息、查看ClassLoader的信息以及finalizer队列。\n\n## 2.2 使用MAT(Memory Analyzer Tool)打开生成的dump文件\n打开后入图所示:\n![MAT](/image/jvm/mat-1.jpeg)\n\n## 2.3 MAT分析\n在Histogram中会列出每个类的实例，可通过分析查出是由于Spring Security造成的问题。\n\n\n# 3.解决\n出现内存溢出的原因是因为Spring Security在用户登录的时候默认创建了session，但是用户在登录的时候又不传session，这就导致每个用户每次进入都会重新创建session，session的有效时间是30分钟，这就导致了内存泄露。最后的解决方案是在Security的配置中增加一句:\n```java\n.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n```\n就可以了。\n\n# 4.总结\n这个问题其实是归结于自己对于Spring Security不熟悉的原因导致的，解决只需一行代码，但是在问题的发现过程还是值得自己思考的。以及在解决问题时候遇到的一些问题和自己解决这些问题时候的一些经验都是有利于自己的提升，毕竟是实际遇到的问题，自己的理解方面也会大有不同。\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。\n\n\n\n\n","source":"_posts/jvm/一次Spring Security造成的内存泄露.md","raw":"---\ntitle: 一次Spring Security造成的内存泄露\ndate: 2019-06-28 10:56:00\ntags:\n    - JVM\n    - 内存泄露\n    - 实战\ncategories:\n    - JVM\nnotshow: true\n---\n# 1.前言\n前段时间项目采用Spring Security作为权限框架应用到现有项目中，一切就那么正常的上线了，然而在上线一段时间后，服务监控就在报警，JVM内存泄露了。如是就是接下来的一段异常处理之旅。\n<!-- more -->\n# 2.内存泄露解决流程\n## 2.1 生成线上最新的堆dump文件\n使用命令jmap生成线上java程序的dump文件，我们都知道在这个文件中可以查看堆内对象示例的统计信息、查看ClassLoader的信息以及finalizer队列。\n\n## 2.2 使用MAT(Memory Analyzer Tool)打开生成的dump文件\n打开后入图所示:\n![MAT](/image/jvm/mat-1.jpeg)\n\n## 2.3 MAT分析\n在Histogram中会列出每个类的实例，可通过分析查出是由于Spring Security造成的问题。\n\n\n# 3.解决\n出现内存溢出的原因是因为Spring Security在用户登录的时候默认创建了session，但是用户在登录的时候又不传session，这就导致每个用户每次进入都会重新创建session，session的有效时间是30分钟，这就导致了内存泄露。最后的解决方案是在Security的配置中增加一句:\n```java\n.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n```\n就可以了。\n\n# 4.总结\n这个问题其实是归结于自己对于Spring Security不熟悉的原因导致的，解决只需一行代码，但是在问题的发现过程还是值得自己思考的。以及在解决问题时候遇到的一些问题和自己解决这些问题时候的一些经验都是有利于自己的提升，毕竟是实际遇到的问题，自己的理解方面也会大有不同。\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。\n\n\n\n\n","slug":"jvm/一次Spring Security造成的内存泄露","published":1,"updated":"2019-09-05T03:26:30.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcov0011jfush1gsal8n","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>前段时间项目采用Spring Security作为权限框架应用到现有项目中，一切就那么正常的上线了，然而在上线一段时间后，服务监控就在报警，JVM内存泄露了。如是就是接下来的一段异常处理之旅。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-内存泄露解决流程\"><a href=\"#2-内存泄露解决流程\" class=\"headerlink\" title=\"2.内存泄露解决流程\"></a>2.内存泄露解决流程</h1><h2 id=\"2-1-生成线上最新的堆dump文件\"><a href=\"#2-1-生成线上最新的堆dump文件\" class=\"headerlink\" title=\"2.1 生成线上最新的堆dump文件\"></a>2.1 生成线上最新的堆dump文件</h2><p>使用命令jmap生成线上java程序的dump文件，我们都知道在这个文件中可以查看堆内对象示例的统计信息、查看ClassLoader的信息以及finalizer队列。</p>\n<h2 id=\"2-2-使用MAT-Memory-Analyzer-Tool-打开生成的dump文件\"><a href=\"#2-2-使用MAT-Memory-Analyzer-Tool-打开生成的dump文件\" class=\"headerlink\" title=\"2.2 使用MAT(Memory Analyzer Tool)打开生成的dump文件\"></a>2.2 使用MAT(Memory Analyzer Tool)打开生成的dump文件</h2><p>打开后入图所示:<br><img src=\"/image/jvm/mat-1.jpeg\" alt=\"MAT\"></p>\n<h2 id=\"2-3-MAT分析\"><a href=\"#2-3-MAT分析\" class=\"headerlink\" title=\"2.3 MAT分析\"></a>2.3 MAT分析</h2><p>在Histogram中会列出每个类的实例，可通过分析查出是由于Spring Security造成的问题。</p>\n<h1 id=\"3-解决\"><a href=\"#3-解决\" class=\"headerlink\" title=\"3.解决\"></a>3.解决</h1><p>出现内存溢出的原因是因为Spring Security在用户登录的时候默认创建了session，但是用户在登录的时候又不传session，这就导致每个用户每次进入都会重新创建session，session的有效时间是30分钟，这就导致了内存泄露。最后的解决方案是在Security的配置中增加一句:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br></pre></td></tr></table></figure>\n<p>就可以了。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h1><p>这个问题其实是归结于自己对于Spring Security不熟悉的原因导致的，解决只需一行代码，但是在问题的发现过程还是值得自己思考的。以及在解决问题时候遇到的一些问题和自己解决这些问题时候的一些经验都是有利于自己的提升，毕竟是实际遇到的问题，自己的理解方面也会大有不同。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>前段时间项目采用Spring Security作为权限框架应用到现有项目中，一切就那么正常的上线了，然而在上线一段时间后，服务监控就在报警，JVM内存泄露了。如是就是接下来的一段异常处理之旅。</p>","more":"<h1 id=\"2-内存泄露解决流程\"><a href=\"#2-内存泄露解决流程\" class=\"headerlink\" title=\"2.内存泄露解决流程\"></a>2.内存泄露解决流程</h1><h2 id=\"2-1-生成线上最新的堆dump文件\"><a href=\"#2-1-生成线上最新的堆dump文件\" class=\"headerlink\" title=\"2.1 生成线上最新的堆dump文件\"></a>2.1 生成线上最新的堆dump文件</h2><p>使用命令jmap生成线上java程序的dump文件，我们都知道在这个文件中可以查看堆内对象示例的统计信息、查看ClassLoader的信息以及finalizer队列。</p>\n<h2 id=\"2-2-使用MAT-Memory-Analyzer-Tool-打开生成的dump文件\"><a href=\"#2-2-使用MAT-Memory-Analyzer-Tool-打开生成的dump文件\" class=\"headerlink\" title=\"2.2 使用MAT(Memory Analyzer Tool)打开生成的dump文件\"></a>2.2 使用MAT(Memory Analyzer Tool)打开生成的dump文件</h2><p>打开后入图所示:<br><img src=\"/image/jvm/mat-1.jpeg\" alt=\"MAT\"></p>\n<h2 id=\"2-3-MAT分析\"><a href=\"#2-3-MAT分析\" class=\"headerlink\" title=\"2.3 MAT分析\"></a>2.3 MAT分析</h2><p>在Histogram中会列出每个类的实例，可通过分析查出是由于Spring Security造成的问题。</p>\n<h1 id=\"3-解决\"><a href=\"#3-解决\" class=\"headerlink\" title=\"3.解决\"></a>3.解决</h1><p>出现内存溢出的原因是因为Spring Security在用户登录的时候默认创建了session，但是用户在登录的时候又不传session，这就导致每个用户每次进入都会重新创建session，session的有效时间是30分钟，这就导致了内存泄露。最后的解决方案是在Security的配置中增加一句:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br></pre></td></tr></table></figure>\n<p>就可以了。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4.总结\"></a>4.总结</h1><p>这个问题其实是归结于自己对于Spring Security不熟悉的原因导致的，解决只需一行代码，但是在问题的发现过程还是值得自己思考的。以及在解决问题时候遇到的一些问题和自己解决这些问题时候的一些经验都是有利于自己的提升，毕竟是实际遇到的问题，自己的理解方面也会大有不同。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>"},{"title":"JMeter基础使用指南","date":"2019-06-21T07:25:00.000Z","notshow":true,"_content":"# 1.前言\n最近开发完项目需要对接口进行压力测试，于是就想到了JMeter,正好借此机会对JMeter的安装使用流程记录一下，既可以加深自己的记忆，也能在之后别人咨询的时候有文章可供其参考。\n<!-- more -->\n# 2.JMeter安装\n## 2.1 下载JMeter\n使用工具之前肯定是需要安装的。这里提供[JMeter的官网](http://jmeter.apache.org/)，可以在[这里](http://jmeter.apache.org/download_jmeter.cgi)下载JMeter。\n\n\n## 2.2 安装JMeter\n>JMeter的运行必须依赖Java环境，所以必须确保你的机器已经安装了JDK。在这里就不介绍JDK的安装了，默认你机器的JDK已经安装可以使用。\n\n下载JMeter以后解压到你指定的目录，我的是保存在`/data/utils/apache-jmeter-5.0`这个目录。然后进入到`bin`目录，如果是在linux或者macOS系统上直接运行`jmeter.sh`文件或者`jmeter`，但如果是在Windows系统则直接运行`jmeter.bat`文件。运行以后你可以看到JMeter就启动了。\n![JMeter主界面](/image/jmeter/jmeter-main.jpg)\n\n对于英语不好的同学可以切换一下语言，如下图:\n![JMeter切换语言](/image/jmeter/jmeter-language.jpg)\n\n这样JMeter就安装完成了，接下来就是使用JMeter的具体功能了。\n\n# 3.JMeter使用\n## 3.1 添加线程组(用户)\n如图右键点击Test Plan 就会弹出选择框根据选择框，如图操作添加即可。创建需要保存成jmx文件，选择文件要保存的位置即可。\n![创建线程组](/image/jmeter/jmeter-create.jpg)\n\n## 3.2 添加测试接口\n如下图：添加http接口\n![添加测试接口](/image/jmeter/jmeter-http.jpg)\n\n在测试接口中添加接口请求信息 包括请求方式，请求地址，端口，以及参数等。\n![测试接口数据](/image/jmeter/jmeter-interface.jpg)\n\n## 3.3 添加监视器\n执行完成以后我们需要知道执行结果数据，这里JMeter也提供了监视器供我们去直观的查看接口执行信息。\n![添加监听器](/image/jmeter/jmeter-listen.jpg)\n\n\n## 3.4 启动测试用例\n在JMeter最上方有一个绿色的按钮启动即可，我们也可在线程组页面修改线程数，是否一直执行等数据。\n\n# 4.查看执行后的数据\n我们在上面添加了监视器，在执行的时候我们可以切换到监视器的视图中查看执行的情况，接口的响应时间，响应状态等情况，以方便我们对程序作出合适的修改，提高效率。\n\n- 结果树:\n![结果树](/image/jmeter/jmeter-resulttree.jpg)\n- 汇总报告:\n![汇总报告](/image/jmeter/jmeter-result.jpg)\n\n# 结语\n通过以上操作就完成了一个接口的测试了，上面演示的只是get请求，post请求的参是body，使用的格式是Json。\n\n以上只是初步的使用了JMeter工具，在不会使用JMeter的时候我也只能自己使用脚本语言(Ruby)开启多线程去调用。相比之下，JMeter还是非常简单的，即使没有编程基础一样可以做压测，是不是很棒？\n\n\n\n\n\n","source":"_posts/test/JMeter基础使用指南.md","raw":"---\ntitle: JMeter基础使用指南\ndate: 2019-06-21 15:25:00\ntags: \n    - JMeter\n    - 测试\ncategories: \n    - 测试\nnotshow: true\n---\n# 1.前言\n最近开发完项目需要对接口进行压力测试，于是就想到了JMeter,正好借此机会对JMeter的安装使用流程记录一下，既可以加深自己的记忆，也能在之后别人咨询的时候有文章可供其参考。\n<!-- more -->\n# 2.JMeter安装\n## 2.1 下载JMeter\n使用工具之前肯定是需要安装的。这里提供[JMeter的官网](http://jmeter.apache.org/)，可以在[这里](http://jmeter.apache.org/download_jmeter.cgi)下载JMeter。\n\n\n## 2.2 安装JMeter\n>JMeter的运行必须依赖Java环境，所以必须确保你的机器已经安装了JDK。在这里就不介绍JDK的安装了，默认你机器的JDK已经安装可以使用。\n\n下载JMeter以后解压到你指定的目录，我的是保存在`/data/utils/apache-jmeter-5.0`这个目录。然后进入到`bin`目录，如果是在linux或者macOS系统上直接运行`jmeter.sh`文件或者`jmeter`，但如果是在Windows系统则直接运行`jmeter.bat`文件。运行以后你可以看到JMeter就启动了。\n![JMeter主界面](/image/jmeter/jmeter-main.jpg)\n\n对于英语不好的同学可以切换一下语言，如下图:\n![JMeter切换语言](/image/jmeter/jmeter-language.jpg)\n\n这样JMeter就安装完成了，接下来就是使用JMeter的具体功能了。\n\n# 3.JMeter使用\n## 3.1 添加线程组(用户)\n如图右键点击Test Plan 就会弹出选择框根据选择框，如图操作添加即可。创建需要保存成jmx文件，选择文件要保存的位置即可。\n![创建线程组](/image/jmeter/jmeter-create.jpg)\n\n## 3.2 添加测试接口\n如下图：添加http接口\n![添加测试接口](/image/jmeter/jmeter-http.jpg)\n\n在测试接口中添加接口请求信息 包括请求方式，请求地址，端口，以及参数等。\n![测试接口数据](/image/jmeter/jmeter-interface.jpg)\n\n## 3.3 添加监视器\n执行完成以后我们需要知道执行结果数据，这里JMeter也提供了监视器供我们去直观的查看接口执行信息。\n![添加监听器](/image/jmeter/jmeter-listen.jpg)\n\n\n## 3.4 启动测试用例\n在JMeter最上方有一个绿色的按钮启动即可，我们也可在线程组页面修改线程数，是否一直执行等数据。\n\n# 4.查看执行后的数据\n我们在上面添加了监视器，在执行的时候我们可以切换到监视器的视图中查看执行的情况，接口的响应时间，响应状态等情况，以方便我们对程序作出合适的修改，提高效率。\n\n- 结果树:\n![结果树](/image/jmeter/jmeter-resulttree.jpg)\n- 汇总报告:\n![汇总报告](/image/jmeter/jmeter-result.jpg)\n\n# 结语\n通过以上操作就完成了一个接口的测试了，上面演示的只是get请求，post请求的参是body，使用的格式是Json。\n\n以上只是初步的使用了JMeter工具，在不会使用JMeter的时候我也只能自己使用脚本语言(Ruby)开启多线程去调用。相比之下，JMeter还是非常简单的，即使没有编程基础一样可以做压测，是不是很棒？\n\n\n\n\n\n","slug":"test/JMeter基础使用指南","published":1,"updated":"2019-09-05T03:35:31.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcow0013jfus4xvee4rf","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>最近开发完项目需要对接口进行压力测试，于是就想到了JMeter,正好借此机会对JMeter的安装使用流程记录一下，既可以加深自己的记忆，也能在之后别人咨询的时候有文章可供其参考。</p>\n<a id=\"more\"></a>\n<h1 id=\"2-JMeter安装\"><a href=\"#2-JMeter安装\" class=\"headerlink\" title=\"2.JMeter安装\"></a>2.JMeter安装</h1><h2 id=\"2-1-下载JMeter\"><a href=\"#2-1-下载JMeter\" class=\"headerlink\" title=\"2.1 下载JMeter\"></a>2.1 下载JMeter</h2><p>使用工具之前肯定是需要安装的。这里提供<a href=\"http://jmeter.apache.org/\" target=\"_blank\" rel=\"noopener\">JMeter的官网</a>，可以在<a href=\"http://jmeter.apache.org/download_jmeter.cgi\" target=\"_blank\" rel=\"noopener\">这里</a>下载JMeter。</p>\n<h2 id=\"2-2-安装JMeter\"><a href=\"#2-2-安装JMeter\" class=\"headerlink\" title=\"2.2 安装JMeter\"></a>2.2 安装JMeter</h2><blockquote>\n<p>JMeter的运行必须依赖Java环境，所以必须确保你的机器已经安装了JDK。在这里就不介绍JDK的安装了，默认你机器的JDK已经安装可以使用。</p>\n</blockquote>\n<p>下载JMeter以后解压到你指定的目录，我的是保存在<code>/data/utils/apache-jmeter-5.0</code>这个目录。然后进入到<code>bin</code>目录，如果是在linux或者macOS系统上直接运行<code>jmeter.sh</code>文件或者<code>jmeter</code>，但如果是在Windows系统则直接运行<code>jmeter.bat</code>文件。运行以后你可以看到JMeter就启动了。<br><img src=\"/image/jmeter/jmeter-main.jpg\" alt=\"JMeter主界面\"></p>\n<p>对于英语不好的同学可以切换一下语言，如下图:<br><img src=\"/image/jmeter/jmeter-language.jpg\" alt=\"JMeter切换语言\"></p>\n<p>这样JMeter就安装完成了，接下来就是使用JMeter的具体功能了。</p>\n<h1 id=\"3-JMeter使用\"><a href=\"#3-JMeter使用\" class=\"headerlink\" title=\"3.JMeter使用\"></a>3.JMeter使用</h1><h2 id=\"3-1-添加线程组-用户\"><a href=\"#3-1-添加线程组-用户\" class=\"headerlink\" title=\"3.1 添加线程组(用户)\"></a>3.1 添加线程组(用户)</h2><p>如图右键点击Test Plan 就会弹出选择框根据选择框，如图操作添加即可。创建需要保存成jmx文件，选择文件要保存的位置即可。<br><img src=\"/image/jmeter/jmeter-create.jpg\" alt=\"创建线程组\"></p>\n<h2 id=\"3-2-添加测试接口\"><a href=\"#3-2-添加测试接口\" class=\"headerlink\" title=\"3.2 添加测试接口\"></a>3.2 添加测试接口</h2><p>如下图：添加http接口<br><img src=\"/image/jmeter/jmeter-http.jpg\" alt=\"添加测试接口\"></p>\n<p>在测试接口中添加接口请求信息 包括请求方式，请求地址，端口，以及参数等。<br><img src=\"/image/jmeter/jmeter-interface.jpg\" alt=\"测试接口数据\"></p>\n<h2 id=\"3-3-添加监视器\"><a href=\"#3-3-添加监视器\" class=\"headerlink\" title=\"3.3 添加监视器\"></a>3.3 添加监视器</h2><p>执行完成以后我们需要知道执行结果数据，这里JMeter也提供了监视器供我们去直观的查看接口执行信息。<br><img src=\"/image/jmeter/jmeter-listen.jpg\" alt=\"添加监听器\"></p>\n<h2 id=\"3-4-启动测试用例\"><a href=\"#3-4-启动测试用例\" class=\"headerlink\" title=\"3.4 启动测试用例\"></a>3.4 启动测试用例</h2><p>在JMeter最上方有一个绿色的按钮启动即可，我们也可在线程组页面修改线程数，是否一直执行等数据。</p>\n<h1 id=\"4-查看执行后的数据\"><a href=\"#4-查看执行后的数据\" class=\"headerlink\" title=\"4.查看执行后的数据\"></a>4.查看执行后的数据</h1><p>我们在上面添加了监视器，在执行的时候我们可以切换到监视器的视图中查看执行的情况，接口的响应时间，响应状态等情况，以方便我们对程序作出合适的修改，提高效率。</p>\n<ul>\n<li>结果树:<br><img src=\"/image/jmeter/jmeter-resulttree.jpg\" alt=\"结果树\"></li>\n<li>汇总报告:<br><img src=\"/image/jmeter/jmeter-result.jpg\" alt=\"汇总报告\"></li>\n</ul>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过以上操作就完成了一个接口的测试了，上面演示的只是get请求，post请求的参是body，使用的格式是Json。</p>\n<p>以上只是初步的使用了JMeter工具，在不会使用JMeter的时候我也只能自己使用脚本语言(Ruby)开启多线程去调用。相比之下，JMeter还是非常简单的，即使没有编程基础一样可以做压测，是不是很棒？</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>最近开发完项目需要对接口进行压力测试，于是就想到了JMeter,正好借此机会对JMeter的安装使用流程记录一下，既可以加深自己的记忆，也能在之后别人咨询的时候有文章可供其参考。</p>","more":"<h1 id=\"2-JMeter安装\"><a href=\"#2-JMeter安装\" class=\"headerlink\" title=\"2.JMeter安装\"></a>2.JMeter安装</h1><h2 id=\"2-1-下载JMeter\"><a href=\"#2-1-下载JMeter\" class=\"headerlink\" title=\"2.1 下载JMeter\"></a>2.1 下载JMeter</h2><p>使用工具之前肯定是需要安装的。这里提供<a href=\"http://jmeter.apache.org/\" target=\"_blank\" rel=\"noopener\">JMeter的官网</a>，可以在<a href=\"http://jmeter.apache.org/download_jmeter.cgi\" target=\"_blank\" rel=\"noopener\">这里</a>下载JMeter。</p>\n<h2 id=\"2-2-安装JMeter\"><a href=\"#2-2-安装JMeter\" class=\"headerlink\" title=\"2.2 安装JMeter\"></a>2.2 安装JMeter</h2><blockquote>\n<p>JMeter的运行必须依赖Java环境，所以必须确保你的机器已经安装了JDK。在这里就不介绍JDK的安装了，默认你机器的JDK已经安装可以使用。</p>\n</blockquote>\n<p>下载JMeter以后解压到你指定的目录，我的是保存在<code>/data/utils/apache-jmeter-5.0</code>这个目录。然后进入到<code>bin</code>目录，如果是在linux或者macOS系统上直接运行<code>jmeter.sh</code>文件或者<code>jmeter</code>，但如果是在Windows系统则直接运行<code>jmeter.bat</code>文件。运行以后你可以看到JMeter就启动了。<br><img src=\"/image/jmeter/jmeter-main.jpg\" alt=\"JMeter主界面\"></p>\n<p>对于英语不好的同学可以切换一下语言，如下图:<br><img src=\"/image/jmeter/jmeter-language.jpg\" alt=\"JMeter切换语言\"></p>\n<p>这样JMeter就安装完成了，接下来就是使用JMeter的具体功能了。</p>\n<h1 id=\"3-JMeter使用\"><a href=\"#3-JMeter使用\" class=\"headerlink\" title=\"3.JMeter使用\"></a>3.JMeter使用</h1><h2 id=\"3-1-添加线程组-用户\"><a href=\"#3-1-添加线程组-用户\" class=\"headerlink\" title=\"3.1 添加线程组(用户)\"></a>3.1 添加线程组(用户)</h2><p>如图右键点击Test Plan 就会弹出选择框根据选择框，如图操作添加即可。创建需要保存成jmx文件，选择文件要保存的位置即可。<br><img src=\"/image/jmeter/jmeter-create.jpg\" alt=\"创建线程组\"></p>\n<h2 id=\"3-2-添加测试接口\"><a href=\"#3-2-添加测试接口\" class=\"headerlink\" title=\"3.2 添加测试接口\"></a>3.2 添加测试接口</h2><p>如下图：添加http接口<br><img src=\"/image/jmeter/jmeter-http.jpg\" alt=\"添加测试接口\"></p>\n<p>在测试接口中添加接口请求信息 包括请求方式，请求地址，端口，以及参数等。<br><img src=\"/image/jmeter/jmeter-interface.jpg\" alt=\"测试接口数据\"></p>\n<h2 id=\"3-3-添加监视器\"><a href=\"#3-3-添加监视器\" class=\"headerlink\" title=\"3.3 添加监视器\"></a>3.3 添加监视器</h2><p>执行完成以后我们需要知道执行结果数据，这里JMeter也提供了监视器供我们去直观的查看接口执行信息。<br><img src=\"/image/jmeter/jmeter-listen.jpg\" alt=\"添加监听器\"></p>\n<h2 id=\"3-4-启动测试用例\"><a href=\"#3-4-启动测试用例\" class=\"headerlink\" title=\"3.4 启动测试用例\"></a>3.4 启动测试用例</h2><p>在JMeter最上方有一个绿色的按钮启动即可，我们也可在线程组页面修改线程数，是否一直执行等数据。</p>\n<h1 id=\"4-查看执行后的数据\"><a href=\"#4-查看执行后的数据\" class=\"headerlink\" title=\"4.查看执行后的数据\"></a>4.查看执行后的数据</h1><p>我们在上面添加了监视器，在执行的时候我们可以切换到监视器的视图中查看执行的情况，接口的响应时间，响应状态等情况，以方便我们对程序作出合适的修改，提高效率。</p>\n<ul>\n<li>结果树:<br><img src=\"/image/jmeter/jmeter-resulttree.jpg\" alt=\"结果树\"></li>\n<li>汇总报告:<br><img src=\"/image/jmeter/jmeter-result.jpg\" alt=\"汇总报告\"></li>\n</ul>\n<h1 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h1><p>通过以上操作就完成了一个接口的测试了，上面演示的只是get请求，post请求的参是body，使用的格式是Json。</p>\n<p>以上只是初步的使用了JMeter工具，在不会使用JMeter的时候我也只能自己使用脚本语言(Ruby)开启多线程去调用。相比之下，JMeter还是非常简单的，即使没有编程基础一样可以做压测，是不是很棒？</p>"},{"title":"Vim详解","date":"2019-07-10T03:57:00.000Z","notshow":true,"_content":"# 1.前言\n一直觉得linux相比于windows系统不知好用了多少倍，第一是linux的`terminal`终端，第二是linux安装软件太方便了，所以我个人对于linux简直是爱不释手。不过现在Windows10好像也引入了终端吧。而且德国等好几个国家也在从Windows系统切换到linux系统，足以说明了linux的强大。毕竟我们在用git等工具的时候可不想在去安装什么git工具。直接几个命令搞定的事情不是很好嘛。\n<!-- more -->\n对于会linux的同学来说，vim的使用更是家常便饭了，所以提高vim的编辑效率是很有必要的。比较如果一篇文章很长我们不可能通过上下左右去移动光标到我们想要的位置，对吧。\n\n# 2.Vim介绍及快捷键\n## 2.1 vim的几种模式\nvim总共有四种模式，首次打开处于正常模式中。\n\n- 正常模式(Normal-mode)\n启动vim后默认处于正常模式。不论位于什么模式，按下`esc`键(有时需要按两下）都会进入正常模式。\n\n- 插入模式(Insert-mode)\n在正常模式中按下`i`,`I`,`a`,`A`等键，会进入插入模式。现在只用记住按`i`键会进行插入模式。在插入模式中，击键时会写入相应的字符。\n\n- 命令模式(Command-mode)\n在正常模式中，按下`:`（英文冒号）键，会进入命令模式。在命令模式中可以执行一些输入并执行一些vim或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。\n\n常用的命令有：`:q`（退出）、`:q!`（强制退出不保存）、`:w`（保存）、`:wq`（保存并退出）。\n\n- 可视模式(Visual-mode)\n在正常模式中按下`v`, `V`, `Ctrl`+`v`，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。\n\n我们比较常用的一般是在正常模式，插入模式，命令模式中切换，可视模式其实用到的比较少的。\n\n## 2.2 Vim快捷键\n### 2.2.1 启动vim命令（test为文件）\n命令 | 描述 | 举例\n:---- | :---- | :----\n`vim -r file` | 恢复上次异常退出的文件 | `vim -r test`\n`vim -R file` | 以只读的方式打开文件，但可以强制保存 | `vim -R test`\n`vim -M file` | 以只读的方式打开文件，不可以强制保存 | `vim -M test`\n`vim + file` | 从文件的末尾开始 | `vim + test`\n`vim +num file` | 从第num行开始 | `vim +4 test`\n`vim +/string file` | 打开file，并将光标停留在第一个找到的string的行首 | `vim +/string file`\n\n### 2.2.2 文档操作命令\n命令 | 描述 \n:---- | :---- \n`:set nu` | 显示行号\n`:set nonu` | 不显示行号\n`:q` | 退出，如果有修改不能退出\n`:q!` | 强制退出，但不保存\n`:w` | 保存\n`:wq` 或 `ZZ` 或 `:x` | 保存并退出\n`:saveas newfile.txt` | 另存为新的文件newfile.txt\n`:f` 或 `control` +`g`| 显示文档名，是否修改，和光标处于第几行\n`:e` | 重新加载当前文档，如果有修改则失败，必须保存或丢弃\n`:e!` | 重新加载当前文档，并丢弃已做的改动\n\n### 2.2.3 光标移动(所有操作命令都是在正常模式下)\n命令 | 描述 \n:---- | :---- \n`h` 或 `Backspace`键 | 左移一个字符 可配合数字使用 如: `2h`\n`l` 或 `space` | 右移一个字符 可配合数字使用 如: `3l`\n`j` | 下移一行\n`k` | 上移一行\n`gj` | 移动到一段内的下一行\n`gk` | 移动到一段内的上一行\n`+` 或 `Enter` | 把光标移至下一行第一个非空白字符\n`-` | 把光标移至上一行第一个非空白字符\n`w` | 前移一个单词，光标停在下一个单词开头\n`e` | 前移一个单词，光标停在下一个单词末尾\n`W` | 移动下一个单词开头，但忽略一些标点\n`E` | 移动到下一个单词末尾，如果词尾有标点，则移动到标点\n`b` | 后移一个单词，光标停在上一个单词开头\n`B` | 移动到上一个单词开头，忽略一些标点\n`ge` | 后移一个单词，光标停在上一个单词末尾\n`gE` | 同`ge` ，不过单词包含单词相邻的标点\n`(` 或 `{` | 向前移动到段落开头\n`)` 或 `}`| 向后移动到段落末尾\n`0` | 移动到行首\n`g0` | 移到光标所在屏幕行行首，针对一行太长的情况\n`^` | 移动到本行第一个非空白字符\n`g^` | 移动到当前屏幕行第一个非空字符处，针对一行太长的情况\n`$` | 移动到行尾\n`g$` | 移动光标所在屏幕行行尾\n`H` | 把光标移到屏幕最顶端一行\n`M` | 把光标移到屏幕中间一行\n`L` | 把光标移到屏幕最底端一行\n`gg` | 移动到文件头部\n`G` | 移动到文件尾部\n`nG` | 移动到文件第n行\n\n### 2.2.4 翻屏\n命令 | 描述 \n:---- | :---- \n`ctrl` + `f` | 下翻一屏\n`ctrl` + `b` | 上翻一屏\n`ctrl` + `d` | 下翻半屏\n`ctrl` + `u` | 上翻半屏\n`ctrl` + `e` | 向下滚动一行\n`ctrl` + `y` | 向上滚动一行\n`n%` | 到文件n%的位置\n`zz` | 将当前行移动到屏幕中央\n`zt` | 将当前行移动到屏幕顶端\n`zb` | 将当前行移动到屏幕底端\n\n\n### 2.2.5 查找\n命令 | 描述 \n:---- | :---- \n`/内容` | 在后面的文本中查找`内容`，`n`向后查找下一个，`N`向前查找下一个\n`?内容` | 在前面的文本中查找`内容`，`n`向后查找下一个，`N`向前查找下一个\n`/内容/+number` | 将光标停在包含`内容`的行后面第number行上，`n`向后查找下一个，`N`向前查找下一个\n`/内容/-number` | 将光标停在包含`内容`的行前面第number行上，`n`向后查找下一个，`N`向前查找下一个\n\n### 2.2.6 替换\n命令 | 描述 \n:---- | :---- \n`:s/old/new` | 用new替换当前行第一个old\n`:s/old/new/g` | 用new替换当前行所有的old\n`:n1,n2s/old/new/g` | 用new替换文件n1行到n2行所有的old\n`:%s/old/new/g` | 用new替换文件中所有的old\n`:%s/^/xxx/g` | 在每一行的行首插入xxx，^表示行首\n`:%s/$/xxx/g` | 在每一行的行尾插入xxx，$表示行尾\n\n所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。\n\n### 2.2.7 撤销与重做\n命令 | 描述 \n:---- | :---- \n`[n] u` | 取消一(n)个改动\n`:undo 5` | 撤销5个改变\n`:undolist` | 你的撤销历史\n`ctrl + r` | 重做最后的改动\n`U` | 取消当前行中所有的改动\n`:earlier 5m` | 回到5分钟前 \n`:later 30s` | 前进30秒 \n\n### 2.2.8 剪切，复制和粘贴\n命令 | 描述 \n:---- | :---- \n`[n]x` | 剪切光标右边n个字符，相当于d[n]l\n`[n]X` | 剪切光标左边n个字符，相当于d[n]h\n`yy` 或 `Y` | 复制整行文本\n`y[n]w` | 复制一(n)个词\n`y[n]l` | 复制光标右边1(n)个字符\n`y[n]h` | 复制光标左边1(n)个字符\n`y$` | 从光标当前位置复制到行尾\n`y0` | 从光标当前位置复制到行首\n`y1G` 或 `ygg` | 复制光标以上的所有行\n`yG` | 复制光标以下的所有行\n`yaw` 或 `yas` | 复制一个词和复制一个句子，即使光标不在词首和句首也没关系\n`d` | 删除（剪切）在可视模式下选中的文本。\n`d$` 或 `D` | 删除（剪切）当前位置到行尾的内容。\n`d[n]w` | 删除（剪切）1(n)个单词\n`d[n]l` | 删除（剪切）光标右边1(n)个字符。\n`d[n]h` | 删除（剪切）光标左边1(n)个字符。\n`d0` | 删除（剪切）当前位置到行首的内容\n`[n] dd` | 删除（剪切）1(n)行。\n`d1G` 或 `dgg` | 剪切光标以上的所有行。\n`dG` | 剪切光标以下的所有行。\n`daw` 或 `das` |剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。\n`p` | 在光标之后粘贴。\n`P` | 在光标之前粘贴\n\n\n# 3. 总结\n如果能够熟练掌握以上命令，那么在使用vim编辑文件时的效率至少能提升5倍以上。真的不是夸大其词。如果是常用linux那么vim基本命令将是不可或缺的。等你熟练运用的时候就会知道我所言非虚。\n\n加油吧。\n\n\n\n\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。","source":"_posts/linux/Vim详解.md","raw":"---\ntitle: Vim详解\ndate: 2019-07-10 11:57:00\ntags:\n    - Linux\n    - Vim\ncategories: \n    - Linux\nnotshow: true\n---\n# 1.前言\n一直觉得linux相比于windows系统不知好用了多少倍，第一是linux的`terminal`终端，第二是linux安装软件太方便了，所以我个人对于linux简直是爱不释手。不过现在Windows10好像也引入了终端吧。而且德国等好几个国家也在从Windows系统切换到linux系统，足以说明了linux的强大。毕竟我们在用git等工具的时候可不想在去安装什么git工具。直接几个命令搞定的事情不是很好嘛。\n<!-- more -->\n对于会linux的同学来说，vim的使用更是家常便饭了，所以提高vim的编辑效率是很有必要的。比较如果一篇文章很长我们不可能通过上下左右去移动光标到我们想要的位置，对吧。\n\n# 2.Vim介绍及快捷键\n## 2.1 vim的几种模式\nvim总共有四种模式，首次打开处于正常模式中。\n\n- 正常模式(Normal-mode)\n启动vim后默认处于正常模式。不论位于什么模式，按下`esc`键(有时需要按两下）都会进入正常模式。\n\n- 插入模式(Insert-mode)\n在正常模式中按下`i`,`I`,`a`,`A`等键，会进入插入模式。现在只用记住按`i`键会进行插入模式。在插入模式中，击键时会写入相应的字符。\n\n- 命令模式(Command-mode)\n在正常模式中，按下`:`（英文冒号）键，会进入命令模式。在命令模式中可以执行一些输入并执行一些vim或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。\n\n常用的命令有：`:q`（退出）、`:q!`（强制退出不保存）、`:w`（保存）、`:wq`（保存并退出）。\n\n- 可视模式(Visual-mode)\n在正常模式中按下`v`, `V`, `Ctrl`+`v`，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。\n\n我们比较常用的一般是在正常模式，插入模式，命令模式中切换，可视模式其实用到的比较少的。\n\n## 2.2 Vim快捷键\n### 2.2.1 启动vim命令（test为文件）\n命令 | 描述 | 举例\n:---- | :---- | :----\n`vim -r file` | 恢复上次异常退出的文件 | `vim -r test`\n`vim -R file` | 以只读的方式打开文件，但可以强制保存 | `vim -R test`\n`vim -M file` | 以只读的方式打开文件，不可以强制保存 | `vim -M test`\n`vim + file` | 从文件的末尾开始 | `vim + test`\n`vim +num file` | 从第num行开始 | `vim +4 test`\n`vim +/string file` | 打开file，并将光标停留在第一个找到的string的行首 | `vim +/string file`\n\n### 2.2.2 文档操作命令\n命令 | 描述 \n:---- | :---- \n`:set nu` | 显示行号\n`:set nonu` | 不显示行号\n`:q` | 退出，如果有修改不能退出\n`:q!` | 强制退出，但不保存\n`:w` | 保存\n`:wq` 或 `ZZ` 或 `:x` | 保存并退出\n`:saveas newfile.txt` | 另存为新的文件newfile.txt\n`:f` 或 `control` +`g`| 显示文档名，是否修改，和光标处于第几行\n`:e` | 重新加载当前文档，如果有修改则失败，必须保存或丢弃\n`:e!` | 重新加载当前文档，并丢弃已做的改动\n\n### 2.2.3 光标移动(所有操作命令都是在正常模式下)\n命令 | 描述 \n:---- | :---- \n`h` 或 `Backspace`键 | 左移一个字符 可配合数字使用 如: `2h`\n`l` 或 `space` | 右移一个字符 可配合数字使用 如: `3l`\n`j` | 下移一行\n`k` | 上移一行\n`gj` | 移动到一段内的下一行\n`gk` | 移动到一段内的上一行\n`+` 或 `Enter` | 把光标移至下一行第一个非空白字符\n`-` | 把光标移至上一行第一个非空白字符\n`w` | 前移一个单词，光标停在下一个单词开头\n`e` | 前移一个单词，光标停在下一个单词末尾\n`W` | 移动下一个单词开头，但忽略一些标点\n`E` | 移动到下一个单词末尾，如果词尾有标点，则移动到标点\n`b` | 后移一个单词，光标停在上一个单词开头\n`B` | 移动到上一个单词开头，忽略一些标点\n`ge` | 后移一个单词，光标停在上一个单词末尾\n`gE` | 同`ge` ，不过单词包含单词相邻的标点\n`(` 或 `{` | 向前移动到段落开头\n`)` 或 `}`| 向后移动到段落末尾\n`0` | 移动到行首\n`g0` | 移到光标所在屏幕行行首，针对一行太长的情况\n`^` | 移动到本行第一个非空白字符\n`g^` | 移动到当前屏幕行第一个非空字符处，针对一行太长的情况\n`$` | 移动到行尾\n`g$` | 移动光标所在屏幕行行尾\n`H` | 把光标移到屏幕最顶端一行\n`M` | 把光标移到屏幕中间一行\n`L` | 把光标移到屏幕最底端一行\n`gg` | 移动到文件头部\n`G` | 移动到文件尾部\n`nG` | 移动到文件第n行\n\n### 2.2.4 翻屏\n命令 | 描述 \n:---- | :---- \n`ctrl` + `f` | 下翻一屏\n`ctrl` + `b` | 上翻一屏\n`ctrl` + `d` | 下翻半屏\n`ctrl` + `u` | 上翻半屏\n`ctrl` + `e` | 向下滚动一行\n`ctrl` + `y` | 向上滚动一行\n`n%` | 到文件n%的位置\n`zz` | 将当前行移动到屏幕中央\n`zt` | 将当前行移动到屏幕顶端\n`zb` | 将当前行移动到屏幕底端\n\n\n### 2.2.5 查找\n命令 | 描述 \n:---- | :---- \n`/内容` | 在后面的文本中查找`内容`，`n`向后查找下一个，`N`向前查找下一个\n`?内容` | 在前面的文本中查找`内容`，`n`向后查找下一个，`N`向前查找下一个\n`/内容/+number` | 将光标停在包含`内容`的行后面第number行上，`n`向后查找下一个，`N`向前查找下一个\n`/内容/-number` | 将光标停在包含`内容`的行前面第number行上，`n`向后查找下一个，`N`向前查找下一个\n\n### 2.2.6 替换\n命令 | 描述 \n:---- | :---- \n`:s/old/new` | 用new替换当前行第一个old\n`:s/old/new/g` | 用new替换当前行所有的old\n`:n1,n2s/old/new/g` | 用new替换文件n1行到n2行所有的old\n`:%s/old/new/g` | 用new替换文件中所有的old\n`:%s/^/xxx/g` | 在每一行的行首插入xxx，^表示行首\n`:%s/$/xxx/g` | 在每一行的行尾插入xxx，$表示行尾\n\n所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。\n\n### 2.2.7 撤销与重做\n命令 | 描述 \n:---- | :---- \n`[n] u` | 取消一(n)个改动\n`:undo 5` | 撤销5个改变\n`:undolist` | 你的撤销历史\n`ctrl + r` | 重做最后的改动\n`U` | 取消当前行中所有的改动\n`:earlier 5m` | 回到5分钟前 \n`:later 30s` | 前进30秒 \n\n### 2.2.8 剪切，复制和粘贴\n命令 | 描述 \n:---- | :---- \n`[n]x` | 剪切光标右边n个字符，相当于d[n]l\n`[n]X` | 剪切光标左边n个字符，相当于d[n]h\n`yy` 或 `Y` | 复制整行文本\n`y[n]w` | 复制一(n)个词\n`y[n]l` | 复制光标右边1(n)个字符\n`y[n]h` | 复制光标左边1(n)个字符\n`y$` | 从光标当前位置复制到行尾\n`y0` | 从光标当前位置复制到行首\n`y1G` 或 `ygg` | 复制光标以上的所有行\n`yG` | 复制光标以下的所有行\n`yaw` 或 `yas` | 复制一个词和复制一个句子，即使光标不在词首和句首也没关系\n`d` | 删除（剪切）在可视模式下选中的文本。\n`d$` 或 `D` | 删除（剪切）当前位置到行尾的内容。\n`d[n]w` | 删除（剪切）1(n)个单词\n`d[n]l` | 删除（剪切）光标右边1(n)个字符。\n`d[n]h` | 删除（剪切）光标左边1(n)个字符。\n`d0` | 删除（剪切）当前位置到行首的内容\n`[n] dd` | 删除（剪切）1(n)行。\n`d1G` 或 `dgg` | 剪切光标以上的所有行。\n`dG` | 剪切光标以下的所有行。\n`daw` 或 `das` |剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。\n`p` | 在光标之后粘贴。\n`P` | 在光标之前粘贴\n\n\n# 3. 总结\n如果能够熟练掌握以上命令，那么在使用vim编辑文件时的效率至少能提升5倍以上。真的不是夸大其词。如果是常用linux那么vim基本命令将是不可或缺的。等你熟练运用的时候就会知道我所言非虚。\n\n加油吧。\n\n\n\n\n\n\n>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。","slug":"linux/Vim详解","published":1,"updated":"2019-09-05T03:26:38.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck38agcp00018jfus9b7hdwch","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>一直觉得linux相比于windows系统不知好用了多少倍，第一是linux的<code>terminal</code>终端，第二是linux安装软件太方便了，所以我个人对于linux简直是爱不释手。不过现在Windows10好像也引入了终端吧。而且德国等好几个国家也在从Windows系统切换到linux系统，足以说明了linux的强大。毕竟我们在用git等工具的时候可不想在去安装什么git工具。直接几个命令搞定的事情不是很好嘛。</p>\n<a id=\"more\"></a>\n<p>对于会linux的同学来说，vim的使用更是家常便饭了，所以提高vim的编辑效率是很有必要的。比较如果一篇文章很长我们不可能通过上下左右去移动光标到我们想要的位置，对吧。</p>\n<h1 id=\"2-Vim介绍及快捷键\"><a href=\"#2-Vim介绍及快捷键\" class=\"headerlink\" title=\"2.Vim介绍及快捷键\"></a>2.Vim介绍及快捷键</h1><h2 id=\"2-1-vim的几种模式\"><a href=\"#2-1-vim的几种模式\" class=\"headerlink\" title=\"2.1 vim的几种模式\"></a>2.1 vim的几种模式</h2><p>vim总共有四种模式，首次打开处于正常模式中。</p>\n<ul>\n<li><p>正常模式(Normal-mode)<br>启动vim后默认处于正常模式。不论位于什么模式，按下<code>esc</code>键(有时需要按两下）都会进入正常模式。</p>\n</li>\n<li><p>插入模式(Insert-mode)<br>在正常模式中按下<code>i</code>,<code>I</code>,<code>a</code>,<code>A</code>等键，会进入插入模式。现在只用记住按<code>i</code>键会进行插入模式。在插入模式中，击键时会写入相应的字符。</p>\n</li>\n<li><p>命令模式(Command-mode)<br>在正常模式中，按下<code>:</code>（英文冒号）键，会进入命令模式。在命令模式中可以执行一些输入并执行一些vim或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。</p>\n</li>\n</ul>\n<p>常用的命令有：<code>:q</code>（退出）、<code>:q!</code>（强制退出不保存）、<code>:w</code>（保存）、<code>:wq</code>（保存并退出）。</p>\n<ul>\n<li>可视模式(Visual-mode)<br>在正常模式中按下<code>v</code>, <code>V</code>, <code>Ctrl</code>+<code>v</code>，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</li>\n</ul>\n<p>我们比较常用的一般是在正常模式，插入模式，命令模式中切换，可视模式其实用到的比较少的。</p>\n<h2 id=\"2-2-Vim快捷键\"><a href=\"#2-2-Vim快捷键\" class=\"headerlink\" title=\"2.2 Vim快捷键\"></a>2.2 Vim快捷键</h2><h3 id=\"2-2-1-启动vim命令（test为文件）\"><a href=\"#2-2-1-启动vim命令（test为文件）\" class=\"headerlink\" title=\"2.2.1 启动vim命令（test为文件）\"></a>2.2.1 启动vim命令（test为文件）</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>vim -r file</code></td>\n<td align=\"left\">恢复上次异常退出的文件</td>\n<td align=\"left\"><code>vim -r test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim -R file</code></td>\n<td align=\"left\">以只读的方式打开文件，但可以强制保存</td>\n<td align=\"left\"><code>vim -R test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim -M file</code></td>\n<td align=\"left\">以只读的方式打开文件，不可以强制保存</td>\n<td align=\"left\"><code>vim -M test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim + file</code></td>\n<td align=\"left\">从文件的末尾开始</td>\n<td align=\"left\"><code>vim + test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim +num file</code></td>\n<td align=\"left\">从第num行开始</td>\n<td align=\"left\"><code>vim +4 test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim +/string file</code></td>\n<td align=\"left\">打开file，并将光标停留在第一个找到的string的行首</td>\n<td align=\"left\"><code>vim +/string file</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2-文档操作命令\"><a href=\"#2-2-2-文档操作命令\" class=\"headerlink\" title=\"2.2.2 文档操作命令\"></a>2.2.2 文档操作命令</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:set nu</code></td>\n<td align=\"left\">显示行号</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:set nonu</code></td>\n<td align=\"left\">不显示行号</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:q</code></td>\n<td align=\"left\">退出，如果有修改不能退出</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:q!</code></td>\n<td align=\"left\">强制退出，但不保存</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:w</code></td>\n<td align=\"left\">保存</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:wq</code> 或 <code>ZZ</code> 或 <code>:x</code></td>\n<td align=\"left\">保存并退出</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:saveas newfile.txt</code></td>\n<td align=\"left\">另存为新的文件newfile.txt</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:f</code> 或 <code>control</code> +<code>g</code></td>\n<td align=\"left\">显示文档名，是否修改，和光标处于第几行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:e</code></td>\n<td align=\"left\">重新加载当前文档，如果有修改则失败，必须保存或丢弃</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:e!</code></td>\n<td align=\"left\">重新加载当前文档，并丢弃已做的改动</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-3-光标移动-所有操作命令都是在正常模式下\"><a href=\"#2-2-3-光标移动-所有操作命令都是在正常模式下\" class=\"headerlink\" title=\"2.2.3 光标移动(所有操作命令都是在正常模式下)\"></a>2.2.3 光标移动(所有操作命令都是在正常模式下)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>h</code> 或 <code>Backspace</code>键</td>\n<td align=\"left\">左移一个字符 可配合数字使用 如: <code>2h</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>l</code> 或 <code>space</code></td>\n<td align=\"left\">右移一个字符 可配合数字使用 如: <code>3l</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>j</code></td>\n<td align=\"left\">下移一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>k</code></td>\n<td align=\"left\">上移一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gj</code></td>\n<td align=\"left\">移动到一段内的下一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gk</code></td>\n<td align=\"left\">移动到一段内的上一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>+</code> 或 <code>Enter</code></td>\n<td align=\"left\">把光标移至下一行第一个非空白字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-</code></td>\n<td align=\"left\">把光标移至上一行第一个非空白字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>w</code></td>\n<td align=\"left\">前移一个单词，光标停在下一个单词开头</td>\n</tr>\n<tr>\n<td align=\"left\"><code>e</code></td>\n<td align=\"left\">前移一个单词，光标停在下一个单词末尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>W</code></td>\n<td align=\"left\">移动下一个单词开头，但忽略一些标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>E</code></td>\n<td align=\"left\">移动到下一个单词末尾，如果词尾有标点，则移动到标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>b</code></td>\n<td align=\"left\">后移一个单词，光标停在上一个单词开头</td>\n</tr>\n<tr>\n<td align=\"left\"><code>B</code></td>\n<td align=\"left\">移动到上一个单词开头，忽略一些标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ge</code></td>\n<td align=\"left\">后移一个单词，光标停在上一个单词末尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gE</code></td>\n<td align=\"left\">同<code>ge</code> ，不过单词包含单词相邻的标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>(</code> 或 <code>{</code></td>\n<td align=\"left\">向前移动到段落开头</td>\n</tr>\n<tr>\n<td align=\"left\"><code>)</code> 或 <code>}</code></td>\n<td align=\"left\">向后移动到段落末尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>0</code></td>\n<td align=\"left\">移动到行首</td>\n</tr>\n<tr>\n<td align=\"left\"><code>g0</code></td>\n<td align=\"left\">移到光标所在屏幕行行首，针对一行太长的情况</td>\n</tr>\n<tr>\n<td align=\"left\"><code>^</code></td>\n<td align=\"left\">移动到本行第一个非空白字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>g^</code></td>\n<td align=\"left\">移动到当前屏幕行第一个非空字符处，针对一行太长的情况</td>\n</tr>\n<tr>\n<td align=\"left\"><code>$</code></td>\n<td align=\"left\">移动到行尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>g$</code></td>\n<td align=\"left\">移动光标所在屏幕行行尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>H</code></td>\n<td align=\"left\">把光标移到屏幕最顶端一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>M</code></td>\n<td align=\"left\">把光标移到屏幕中间一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>L</code></td>\n<td align=\"left\">把光标移到屏幕最底端一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gg</code></td>\n<td align=\"left\">移动到文件头部</td>\n</tr>\n<tr>\n<td align=\"left\"><code>G</code></td>\n<td align=\"left\">移动到文件尾部</td>\n</tr>\n<tr>\n<td align=\"left\"><code>nG</code></td>\n<td align=\"left\">移动到文件第n行</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-4-翻屏\"><a href=\"#2-2-4-翻屏\" class=\"headerlink\" title=\"2.2.4 翻屏\"></a>2.2.4 翻屏</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>ctrl</code> + <code>f</code></td>\n<td align=\"left\">下翻一屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>b</code></td>\n<td align=\"left\">上翻一屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>d</code></td>\n<td align=\"left\">下翻半屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>u</code></td>\n<td align=\"left\">上翻半屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>e</code></td>\n<td align=\"left\">向下滚动一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>y</code></td>\n<td align=\"left\">向上滚动一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>n%</code></td>\n<td align=\"left\">到文件n%的位置</td>\n</tr>\n<tr>\n<td align=\"left\"><code>zz</code></td>\n<td align=\"left\">将当前行移动到屏幕中央</td>\n</tr>\n<tr>\n<td align=\"left\"><code>zt</code></td>\n<td align=\"left\">将当前行移动到屏幕顶端</td>\n</tr>\n<tr>\n<td align=\"left\"><code>zb</code></td>\n<td align=\"left\">将当前行移动到屏幕底端</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-5-查找\"><a href=\"#2-2-5-查找\" class=\"headerlink\" title=\"2.2.5 查找\"></a>2.2.5 查找</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>/内容</code></td>\n<td align=\"left\">在后面的文本中查找<code>内容</code>，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n<tr>\n<td align=\"left\"><code>?内容</code></td>\n<td align=\"left\">在前面的文本中查找<code>内容</code>，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n<tr>\n<td align=\"left\"><code>/内容/+number</code></td>\n<td align=\"left\">将光标停在包含<code>内容</code>的行后面第number行上，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n<tr>\n<td align=\"left\"><code>/内容/-number</code></td>\n<td align=\"left\">将光标停在包含<code>内容</code>的行前面第number行上，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-6-替换\"><a href=\"#2-2-6-替换\" class=\"headerlink\" title=\"2.2.6 替换\"></a>2.2.6 替换</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:s/old/new</code></td>\n<td align=\"left\">用new替换当前行第一个old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:s/old/new/g</code></td>\n<td align=\"left\">用new替换当前行所有的old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:n1,n2s/old/new/g</code></td>\n<td align=\"left\">用new替换文件n1行到n2行所有的old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:%s/old/new/g</code></td>\n<td align=\"left\">用new替换文件中所有的old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:%s/^/xxx/g</code></td>\n<td align=\"left\">在每一行的行首插入xxx，^表示行首</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:%s/$/xxx/g</code></td>\n<td align=\"left\">在每一行的行尾插入xxx，$表示行尾</td>\n</tr>\n</tbody></table>\n<p>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</p>\n<h3 id=\"2-2-7-撤销与重做\"><a href=\"#2-2-7-撤销与重做\" class=\"headerlink\" title=\"2.2.7 撤销与重做\"></a>2.2.7 撤销与重做</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>[n] u</code></td>\n<td align=\"left\">取消一(n)个改动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:undo 5</code></td>\n<td align=\"left\">撤销5个改变</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:undolist</code></td>\n<td align=\"left\">你的撤销历史</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl + r</code></td>\n<td align=\"left\">重做最后的改动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>U</code></td>\n<td align=\"left\">取消当前行中所有的改动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:earlier 5m</code></td>\n<td align=\"left\">回到5分钟前</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:later 30s</code></td>\n<td align=\"left\">前进30秒</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-8-剪切，复制和粘贴\"><a href=\"#2-2-8-剪切，复制和粘贴\" class=\"headerlink\" title=\"2.2.8 剪切，复制和粘贴\"></a>2.2.8 剪切，复制和粘贴</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>[n]x</code></td>\n<td align=\"left\">剪切光标右边n个字符，相当于d[n]l</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[n]X</code></td>\n<td align=\"left\">剪切光标左边n个字符，相当于d[n]h</td>\n</tr>\n<tr>\n<td align=\"left\"><code>yy</code> 或 <code>Y</code></td>\n<td align=\"left\">复制整行文本</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y[n]w</code></td>\n<td align=\"left\">复制一(n)个词</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y[n]l</code></td>\n<td align=\"left\">复制光标右边1(n)个字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y[n]h</code></td>\n<td align=\"left\">复制光标左边1(n)个字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y$</code></td>\n<td align=\"left\">从光标当前位置复制到行尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y0</code></td>\n<td align=\"left\">从光标当前位置复制到行首</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y1G</code> 或 <code>ygg</code></td>\n<td align=\"left\">复制光标以上的所有行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>yG</code></td>\n<td align=\"left\">复制光标以下的所有行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>yaw</code> 或 <code>yas</code></td>\n<td align=\"left\">复制一个词和复制一个句子，即使光标不在词首和句首也没关系</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d</code></td>\n<td align=\"left\">删除（剪切）在可视模式下选中的文本。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d$</code> 或 <code>D</code></td>\n<td align=\"left\">删除（剪切）当前位置到行尾的内容。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d[n]w</code></td>\n<td align=\"left\">删除（剪切）1(n)个单词</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d[n]l</code></td>\n<td align=\"left\">删除（剪切）光标右边1(n)个字符。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d[n]h</code></td>\n<td align=\"left\">删除（剪切）光标左边1(n)个字符。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d0</code></td>\n<td align=\"left\">删除（剪切）当前位置到行首的内容</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[n] dd</code></td>\n<td align=\"left\">删除（剪切）1(n)行。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d1G</code> 或 <code>dgg</code></td>\n<td align=\"left\">剪切光标以上的所有行。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>dG</code></td>\n<td align=\"left\">剪切光标以下的所有行。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>daw</code> 或 <code>das</code></td>\n<td align=\"left\">剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>p</code></td>\n<td align=\"left\">在光标之后粘贴。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>P</code></td>\n<td align=\"left\">在光标之前粘贴</td>\n</tr>\n</tbody></table>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p>如果能够熟练掌握以上命令，那么在使用vim编辑文件时的效率至少能提升5倍以上。真的不是夸大其词。如果是常用linux那么vim基本命令将是不可或缺的。等你熟练运用的时候就会知道我所言非虚。</p>\n<p>加油吧。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h1><p>一直觉得linux相比于windows系统不知好用了多少倍，第一是linux的<code>terminal</code>终端，第二是linux安装软件太方便了，所以我个人对于linux简直是爱不释手。不过现在Windows10好像也引入了终端吧。而且德国等好几个国家也在从Windows系统切换到linux系统，足以说明了linux的强大。毕竟我们在用git等工具的时候可不想在去安装什么git工具。直接几个命令搞定的事情不是很好嘛。</p>","more":"<p>对于会linux的同学来说，vim的使用更是家常便饭了，所以提高vim的编辑效率是很有必要的。比较如果一篇文章很长我们不可能通过上下左右去移动光标到我们想要的位置，对吧。</p>\n<h1 id=\"2-Vim介绍及快捷键\"><a href=\"#2-Vim介绍及快捷键\" class=\"headerlink\" title=\"2.Vim介绍及快捷键\"></a>2.Vim介绍及快捷键</h1><h2 id=\"2-1-vim的几种模式\"><a href=\"#2-1-vim的几种模式\" class=\"headerlink\" title=\"2.1 vim的几种模式\"></a>2.1 vim的几种模式</h2><p>vim总共有四种模式，首次打开处于正常模式中。</p>\n<ul>\n<li><p>正常模式(Normal-mode)<br>启动vim后默认处于正常模式。不论位于什么模式，按下<code>esc</code>键(有时需要按两下）都会进入正常模式。</p>\n</li>\n<li><p>插入模式(Insert-mode)<br>在正常模式中按下<code>i</code>,<code>I</code>,<code>a</code>,<code>A</code>等键，会进入插入模式。现在只用记住按<code>i</code>键会进行插入模式。在插入模式中，击键时会写入相应的字符。</p>\n</li>\n<li><p>命令模式(Command-mode)<br>在正常模式中，按下<code>:</code>（英文冒号）键，会进入命令模式。在命令模式中可以执行一些输入并执行一些vim或插件提供的指令，就像在shell里一样。这些指令包括设置环境、文件操作、调用某个功能等等。</p>\n</li>\n</ul>\n<p>常用的命令有：<code>:q</code>（退出）、<code>:q!</code>（强制退出不保存）、<code>:w</code>（保存）、<code>:wq</code>（保存并退出）。</p>\n<ul>\n<li>可视模式(Visual-mode)<br>在正常模式中按下<code>v</code>, <code>V</code>, <code>Ctrl</code>+<code>v</code>，可以进入可视模式。可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。</li>\n</ul>\n<p>我们比较常用的一般是在正常模式，插入模式，命令模式中切换，可视模式其实用到的比较少的。</p>\n<h2 id=\"2-2-Vim快捷键\"><a href=\"#2-2-Vim快捷键\" class=\"headerlink\" title=\"2.2 Vim快捷键\"></a>2.2 Vim快捷键</h2><h3 id=\"2-2-1-启动vim命令（test为文件）\"><a href=\"#2-2-1-启动vim命令（test为文件）\" class=\"headerlink\" title=\"2.2.1 启动vim命令（test为文件）\"></a>2.2.1 启动vim命令（test为文件）</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n<th align=\"left\">举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>vim -r file</code></td>\n<td align=\"left\">恢复上次异常退出的文件</td>\n<td align=\"left\"><code>vim -r test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim -R file</code></td>\n<td align=\"left\">以只读的方式打开文件，但可以强制保存</td>\n<td align=\"left\"><code>vim -R test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim -M file</code></td>\n<td align=\"left\">以只读的方式打开文件，不可以强制保存</td>\n<td align=\"left\"><code>vim -M test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim + file</code></td>\n<td align=\"left\">从文件的末尾开始</td>\n<td align=\"left\"><code>vim + test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim +num file</code></td>\n<td align=\"left\">从第num行开始</td>\n<td align=\"left\"><code>vim +4 test</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>vim +/string file</code></td>\n<td align=\"left\">打开file，并将光标停留在第一个找到的string的行首</td>\n<td align=\"left\"><code>vim +/string file</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2-文档操作命令\"><a href=\"#2-2-2-文档操作命令\" class=\"headerlink\" title=\"2.2.2 文档操作命令\"></a>2.2.2 文档操作命令</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:set nu</code></td>\n<td align=\"left\">显示行号</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:set nonu</code></td>\n<td align=\"left\">不显示行号</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:q</code></td>\n<td align=\"left\">退出，如果有修改不能退出</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:q!</code></td>\n<td align=\"left\">强制退出，但不保存</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:w</code></td>\n<td align=\"left\">保存</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:wq</code> 或 <code>ZZ</code> 或 <code>:x</code></td>\n<td align=\"left\">保存并退出</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:saveas newfile.txt</code></td>\n<td align=\"left\">另存为新的文件newfile.txt</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:f</code> 或 <code>control</code> +<code>g</code></td>\n<td align=\"left\">显示文档名，是否修改，和光标处于第几行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:e</code></td>\n<td align=\"left\">重新加载当前文档，如果有修改则失败，必须保存或丢弃</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:e!</code></td>\n<td align=\"left\">重新加载当前文档，并丢弃已做的改动</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-3-光标移动-所有操作命令都是在正常模式下\"><a href=\"#2-2-3-光标移动-所有操作命令都是在正常模式下\" class=\"headerlink\" title=\"2.2.3 光标移动(所有操作命令都是在正常模式下)\"></a>2.2.3 光标移动(所有操作命令都是在正常模式下)</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>h</code> 或 <code>Backspace</code>键</td>\n<td align=\"left\">左移一个字符 可配合数字使用 如: <code>2h</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>l</code> 或 <code>space</code></td>\n<td align=\"left\">右移一个字符 可配合数字使用 如: <code>3l</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>j</code></td>\n<td align=\"left\">下移一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>k</code></td>\n<td align=\"left\">上移一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gj</code></td>\n<td align=\"left\">移动到一段内的下一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gk</code></td>\n<td align=\"left\">移动到一段内的上一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>+</code> 或 <code>Enter</code></td>\n<td align=\"left\">把光标移至下一行第一个非空白字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>-</code></td>\n<td align=\"left\">把光标移至上一行第一个非空白字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>w</code></td>\n<td align=\"left\">前移一个单词，光标停在下一个单词开头</td>\n</tr>\n<tr>\n<td align=\"left\"><code>e</code></td>\n<td align=\"left\">前移一个单词，光标停在下一个单词末尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>W</code></td>\n<td align=\"left\">移动下一个单词开头，但忽略一些标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>E</code></td>\n<td align=\"left\">移动到下一个单词末尾，如果词尾有标点，则移动到标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>b</code></td>\n<td align=\"left\">后移一个单词，光标停在上一个单词开头</td>\n</tr>\n<tr>\n<td align=\"left\"><code>B</code></td>\n<td align=\"left\">移动到上一个单词开头，忽略一些标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ge</code></td>\n<td align=\"left\">后移一个单词，光标停在上一个单词末尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gE</code></td>\n<td align=\"left\">同<code>ge</code> ，不过单词包含单词相邻的标点</td>\n</tr>\n<tr>\n<td align=\"left\"><code>(</code> 或 <code>{</code></td>\n<td align=\"left\">向前移动到段落开头</td>\n</tr>\n<tr>\n<td align=\"left\"><code>)</code> 或 <code>}</code></td>\n<td align=\"left\">向后移动到段落末尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>0</code></td>\n<td align=\"left\">移动到行首</td>\n</tr>\n<tr>\n<td align=\"left\"><code>g0</code></td>\n<td align=\"left\">移到光标所在屏幕行行首，针对一行太长的情况</td>\n</tr>\n<tr>\n<td align=\"left\"><code>^</code></td>\n<td align=\"left\">移动到本行第一个非空白字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>g^</code></td>\n<td align=\"left\">移动到当前屏幕行第一个非空字符处，针对一行太长的情况</td>\n</tr>\n<tr>\n<td align=\"left\"><code>$</code></td>\n<td align=\"left\">移动到行尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>g$</code></td>\n<td align=\"left\">移动光标所在屏幕行行尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>H</code></td>\n<td align=\"left\">把光标移到屏幕最顶端一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>M</code></td>\n<td align=\"left\">把光标移到屏幕中间一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>L</code></td>\n<td align=\"left\">把光标移到屏幕最底端一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>gg</code></td>\n<td align=\"left\">移动到文件头部</td>\n</tr>\n<tr>\n<td align=\"left\"><code>G</code></td>\n<td align=\"left\">移动到文件尾部</td>\n</tr>\n<tr>\n<td align=\"left\"><code>nG</code></td>\n<td align=\"left\">移动到文件第n行</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-4-翻屏\"><a href=\"#2-2-4-翻屏\" class=\"headerlink\" title=\"2.2.4 翻屏\"></a>2.2.4 翻屏</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>ctrl</code> + <code>f</code></td>\n<td align=\"left\">下翻一屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>b</code></td>\n<td align=\"left\">上翻一屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>d</code></td>\n<td align=\"left\">下翻半屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>u</code></td>\n<td align=\"left\">上翻半屏</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>e</code></td>\n<td align=\"left\">向下滚动一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl</code> + <code>y</code></td>\n<td align=\"left\">向上滚动一行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>n%</code></td>\n<td align=\"left\">到文件n%的位置</td>\n</tr>\n<tr>\n<td align=\"left\"><code>zz</code></td>\n<td align=\"left\">将当前行移动到屏幕中央</td>\n</tr>\n<tr>\n<td align=\"left\"><code>zt</code></td>\n<td align=\"left\">将当前行移动到屏幕顶端</td>\n</tr>\n<tr>\n<td align=\"left\"><code>zb</code></td>\n<td align=\"left\">将当前行移动到屏幕底端</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-5-查找\"><a href=\"#2-2-5-查找\" class=\"headerlink\" title=\"2.2.5 查找\"></a>2.2.5 查找</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>/内容</code></td>\n<td align=\"left\">在后面的文本中查找<code>内容</code>，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n<tr>\n<td align=\"left\"><code>?内容</code></td>\n<td align=\"left\">在前面的文本中查找<code>内容</code>，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n<tr>\n<td align=\"left\"><code>/内容/+number</code></td>\n<td align=\"left\">将光标停在包含<code>内容</code>的行后面第number行上，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n<tr>\n<td align=\"left\"><code>/内容/-number</code></td>\n<td align=\"left\">将光标停在包含<code>内容</code>的行前面第number行上，<code>n</code>向后查找下一个，<code>N</code>向前查找下一个</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-6-替换\"><a href=\"#2-2-6-替换\" class=\"headerlink\" title=\"2.2.6 替换\"></a>2.2.6 替换</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>:s/old/new</code></td>\n<td align=\"left\">用new替换当前行第一个old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:s/old/new/g</code></td>\n<td align=\"left\">用new替换当前行所有的old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:n1,n2s/old/new/g</code></td>\n<td align=\"left\">用new替换文件n1行到n2行所有的old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:%s/old/new/g</code></td>\n<td align=\"left\">用new替换文件中所有的old</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:%s/^/xxx/g</code></td>\n<td align=\"left\">在每一行的行首插入xxx，^表示行首</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:%s/$/xxx/g</code></td>\n<td align=\"left\">在每一行的行尾插入xxx，$表示行尾</td>\n</tr>\n</tbody></table>\n<p>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s/old/new/gc，加上i则忽略大小写(ignore)。</p>\n<h3 id=\"2-2-7-撤销与重做\"><a href=\"#2-2-7-撤销与重做\" class=\"headerlink\" title=\"2.2.7 撤销与重做\"></a>2.2.7 撤销与重做</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>[n] u</code></td>\n<td align=\"left\">取消一(n)个改动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:undo 5</code></td>\n<td align=\"left\">撤销5个改变</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:undolist</code></td>\n<td align=\"left\">你的撤销历史</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ctrl + r</code></td>\n<td align=\"left\">重做最后的改动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>U</code></td>\n<td align=\"left\">取消当前行中所有的改动</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:earlier 5m</code></td>\n<td align=\"left\">回到5分钟前</td>\n</tr>\n<tr>\n<td align=\"left\"><code>:later 30s</code></td>\n<td align=\"left\">前进30秒</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-8-剪切，复制和粘贴\"><a href=\"#2-2-8-剪切，复制和粘贴\" class=\"headerlink\" title=\"2.2.8 剪切，复制和粘贴\"></a>2.2.8 剪切，复制和粘贴</h3><table>\n<thead>\n<tr>\n<th align=\"left\">命令</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>[n]x</code></td>\n<td align=\"left\">剪切光标右边n个字符，相当于d[n]l</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[n]X</code></td>\n<td align=\"left\">剪切光标左边n个字符，相当于d[n]h</td>\n</tr>\n<tr>\n<td align=\"left\"><code>yy</code> 或 <code>Y</code></td>\n<td align=\"left\">复制整行文本</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y[n]w</code></td>\n<td align=\"left\">复制一(n)个词</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y[n]l</code></td>\n<td align=\"left\">复制光标右边1(n)个字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y[n]h</code></td>\n<td align=\"left\">复制光标左边1(n)个字符</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y$</code></td>\n<td align=\"left\">从光标当前位置复制到行尾</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y0</code></td>\n<td align=\"left\">从光标当前位置复制到行首</td>\n</tr>\n<tr>\n<td align=\"left\"><code>y1G</code> 或 <code>ygg</code></td>\n<td align=\"left\">复制光标以上的所有行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>yG</code></td>\n<td align=\"left\">复制光标以下的所有行</td>\n</tr>\n<tr>\n<td align=\"left\"><code>yaw</code> 或 <code>yas</code></td>\n<td align=\"left\">复制一个词和复制一个句子，即使光标不在词首和句首也没关系</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d</code></td>\n<td align=\"left\">删除（剪切）在可视模式下选中的文本。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d$</code> 或 <code>D</code></td>\n<td align=\"left\">删除（剪切）当前位置到行尾的内容。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d[n]w</code></td>\n<td align=\"left\">删除（剪切）1(n)个单词</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d[n]l</code></td>\n<td align=\"left\">删除（剪切）光标右边1(n)个字符。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d[n]h</code></td>\n<td align=\"left\">删除（剪切）光标左边1(n)个字符。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d0</code></td>\n<td align=\"left\">删除（剪切）当前位置到行首的内容</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[n] dd</code></td>\n<td align=\"left\">删除（剪切）1(n)行。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>d1G</code> 或 <code>dgg</code></td>\n<td align=\"left\">剪切光标以上的所有行。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>dG</code></td>\n<td align=\"left\">剪切光标以下的所有行。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>daw</code> 或 <code>das</code></td>\n<td align=\"left\">剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>p</code></td>\n<td align=\"left\">在光标之后粘贴。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>P</code></td>\n<td align=\"left\">在光标之前粘贴</td>\n</tr>\n</tbody></table>\n<h1 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3. 总结\"></a>3. 总结</h1><p>如果能够熟练掌握以上命令，那么在使用vim编辑文件时的效率至少能提升5倍以上。真的不是夸大其词。如果是常用linux那么vim基本命令将是不可或缺的。等你熟练运用的时候就会知道我所言非虚。</p>\n<p>加油吧。</p>\n<blockquote>\n<p>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。</p>\n</blockquote>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck38agcn20001jfusgeu8a1um","category_id":"ck38agcn60003jfus5224e1l8","_id":"ck38agcna0006jfus3fy2hsdc"},{"post_id":"ck38agcoi000ajfus0yojhg74","category_id":"ck38agcok000cjfus1av5gw1d","_id":"ck38agcor000njfusb2mzdhqo"},{"post_id":"ck38agcop000kjfus8zev1ek8","category_id":"ck38agcok000cjfus1av5gw1d","_id":"ck38agcot000sjfusbn7md34s"},{"post_id":"ck38agcoj000bjfus6bufbp4z","category_id":"ck38agcok000cjfus1av5gw1d","_id":"ck38agcou000wjfusgh8f44hr"},{"post_id":"ck38agcok000ejfus5amwcovt","category_id":"ck38agcok000cjfus1av5gw1d","_id":"ck38agcov000yjfusf9kqbfmj"},{"post_id":"ck38agcol000fjfusdt246ukq","category_id":"ck38agcot000tjfus90ly0mlz","_id":"ck38agcox0015jfusazo5c46q"},{"post_id":"ck38agcom000gjfus7d836ndl","category_id":"ck38agcov000zjfusgl4gdrfz","_id":"ck38agcp1001ajfus25a30gck"},{"post_id":"ck38agcoq000ljfus2j65eiy9","category_id":"ck38agcot000tjfus90ly0mlz","_id":"ck38agcp1001cjfus7uem3rhs"},{"post_id":"ck38agcor000qjfusbd4w3w7i","category_id":"ck38agcp10019jfusc0e0dgw8","_id":"ck38agcp2001gjfus4lx6ce04"},{"post_id":"ck38agcos000rjfus1pmq4ts1","category_id":"ck38agcp1001djfus0rvxfngi","_id":"ck38agcp3001njfusc737aekz"},{"post_id":"ck38agcou000vjfus2kht2mdn","category_id":"ck38agcp1001djfus0rvxfngi","_id":"ck38agcp3001rjfuscjv00dxk"},{"post_id":"ck38agcou000xjfusbovqbhwe","category_id":"ck38agcp1001djfus0rvxfngi","_id":"ck38agcp4001vjfus61i6451d"},{"post_id":"ck38agcov0011jfush1gsal8n","category_id":"ck38agcp1001djfus0rvxfngi","_id":"ck38agcp5001yjfus074leba4"},{"post_id":"ck38agcow0013jfus4xvee4rf","category_id":"ck38agcp4001ujfusb7qh5rm8","_id":"ck38agcp50022jfus1hr27mer"},{"post_id":"ck38agcp00018jfus9b7hdwch","category_id":"ck38agcp5001zjfusagsj0oga","_id":"ck38agcp60025jfus6msmg06b"}],"PostTag":[{"post_id":"ck38agcn20001jfusgeu8a1um","tag_id":"ck38agcn70004jfus11naby4c","_id":"ck38agcna0007jfus3qa4d5mc"},{"post_id":"ck38agcn20001jfusgeu8a1um","tag_id":"ck38agcn90005jfusf8uxc5ye","_id":"ck38agcnb0008jfus5ez30tqp"},{"post_id":"ck38agcoi000ajfus0yojhg74","tag_id":"ck38agcok000djfus0mlsb1rk","_id":"ck38agcop000jjfus1lwwfke1"},{"post_id":"ck38agcoj000bjfus6bufbp4z","tag_id":"ck38agcok000djfus0mlsb1rk","_id":"ck38agcor000pjfus1js5975z"},{"post_id":"ck38agcok000ejfus5amwcovt","tag_id":"ck38agcor000ojfus903m3uae","_id":"ck38agcow0012jfus96k58ovo"},{"post_id":"ck38agcok000ejfus5amwcovt","tag_id":"ck38agcok000djfus0mlsb1rk","_id":"ck38agcox0014jfushlypdnj2"},{"post_id":"ck38agcol000fjfusdt246ukq","tag_id":"ck38agcov0010jfus0lv42usx","_id":"ck38agcp1001fjfuscyhp15s5"},{"post_id":"ck38agcol000fjfusdt246ukq","tag_id":"ck38agcox0017jfus4agnbjb3","_id":"ck38agcp2001hjfus2h5l5aqn"},{"post_id":"ck38agcol000fjfusdt246ukq","tag_id":"ck38agcp1001bjfushru57nmd","_id":"ck38agcp2001kjfus5pejhksq"},{"post_id":"ck38agcom000gjfus7d836ndl","tag_id":"ck38agcp1001ejfus9cj9eku8","_id":"ck38agcp2001ljfushoy456lc"},{"post_id":"ck38agcop000kjfus8zev1ek8","tag_id":"ck38agcok000djfus0mlsb1rk","_id":"ck38agcp3001pjfus2xef7hiw"},{"post_id":"ck38agcop000kjfus8zev1ek8","tag_id":"ck38agcp2001jjfus6pwef7fr","_id":"ck38agcp4001sjfusbeo70ouc"},{"post_id":"ck38agcoq000ljfus2j65eiy9","tag_id":"ck38agcp3001ojfusdo6dfngb","_id":"ck38agcp5001xjfusdkmog9ev"},{"post_id":"ck38agcoq000ljfus2j65eiy9","tag_id":"ck38agcp4001tjfusgki6d4b5","_id":"ck38agcp50020jfuse03ebxp6"},{"post_id":"ck38agcor000qjfusbd4w3w7i","tag_id":"ck38agcp4001wjfushbmy56cb","_id":"ck38agcp60024jfusgyo50x8c"},{"post_id":"ck38agcor000qjfusbd4w3w7i","tag_id":"ck38agcp50021jfusb2kj04q4","_id":"ck38agcp60026jfus1bn44kno"},{"post_id":"ck38agcos000rjfus1pmq4ts1","tag_id":"ck38agcp50023jfus435rffa7","_id":"ck38agcp60029jfushg5s2nu1"},{"post_id":"ck38agcos000rjfus1pmq4ts1","tag_id":"ck38agcp60027jfusfwtg5lhf","_id":"ck38agcp7002ajfus31hd2h3c"},{"post_id":"ck38agcou000vjfus2kht2mdn","tag_id":"ck38agcp50023jfus435rffa7","_id":"ck38agcp7002djfus8lia5ti1"},{"post_id":"ck38agcou000vjfus2kht2mdn","tag_id":"ck38agcp7002bjfus080db99p","_id":"ck38agcp7002ejfushywae8os"},{"post_id":"ck38agcou000xjfusbovqbhwe","tag_id":"ck38agcp50023jfus435rffa7","_id":"ck38agcp8002ijfus3grp3iqm"},{"post_id":"ck38agcou000xjfusbovqbhwe","tag_id":"ck38agcp7002fjfusb1d6hhym","_id":"ck38agcp8002jjfus5eiig9gh"},{"post_id":"ck38agcou000xjfusbovqbhwe","tag_id":"ck38agcp8002gjfus6p2gcwk8","_id":"ck38agcp9002ljfus5vfgf373"},{"post_id":"ck38agcov0011jfush1gsal8n","tag_id":"ck38agcp50023jfus435rffa7","_id":"ck38agcp9002ojfus8wtf605s"},{"post_id":"ck38agcov0011jfush1gsal8n","tag_id":"ck38agcp8002kjfusdhc34yeq","_id":"ck38agcp9002pjfusc01ib5lb"},{"post_id":"ck38agcov0011jfush1gsal8n","tag_id":"ck38agcp9002mjfus90e23t6m","_id":"ck38agcpa002rjfusd1ihhwjz"},{"post_id":"ck38agcow0013jfus4xvee4rf","tag_id":"ck38agcp9002njfus6vgl935d","_id":"ck38agcpa002tjfus1oaohwx4"},{"post_id":"ck38agcow0013jfus4xvee4rf","tag_id":"ck38agcp9002qjfus1iev5sby","_id":"ck38agcpa002ujfus245z60yq"},{"post_id":"ck38agcp00018jfus9b7hdwch","tag_id":"ck38agcpa002sjfusaquq8ghy","_id":"ck38agcpa002wjfusfpkq2uzt"},{"post_id":"ck38agcp00018jfus9b7hdwch","tag_id":"ck38agcpa002vjfus4jv32xwm","_id":"ck38agcpa002xjfusakcc0v9m"}],"Tag":[{"name":"RabbitMQ","_id":"ck38agcn70004jfus11naby4c"},{"name":"消息队列","_id":"ck38agcn90005jfusf8uxc5ye"},{"name":"docker","_id":"ck38agcok000djfus0mlsb1rk"},{"name":"es","_id":"ck38agcor000ojfus903m3uae"},{"name":"Bean映射","_id":"ck38agcov0010jfus0lv42usx"},{"name":"Orika","_id":"ck38agcox0017jfus4agnbjb3"},{"name":"Java","_id":"ck38agcp1001bjfushru57nmd"},{"name":"Git","_id":"ck38agcp1001ejfus9cj9eku8"},{"name":"mysql","_id":"ck38agcp2001jjfus6pwef7fr"},{"name":"Java8","_id":"ck38agcp3001ojfusdo6dfngb"},{"name":"stream","_id":"ck38agcp4001tjfusgki6d4b5"},{"name":"Maven","_id":"ck38agcp4001wjfushbmy56cb"},{"name":"Nexus","_id":"ck38agcp50021jfusb2kj04q4"},{"name":"JVM","_id":"ck38agcp50023jfus435rffa7"},{"name":"JVM内存结构","_id":"ck38agcp60027jfusfwtg5lhf"},{"name":"工具","_id":"ck38agcp7002bjfus080db99p"},{"name":"GC","_id":"ck38agcp7002fjfusb1d6hhym"},{"name":"垃圾回收","_id":"ck38agcp8002gjfus6p2gcwk8"},{"name":"内存泄露","_id":"ck38agcp8002kjfusdhc34yeq"},{"name":"实战","_id":"ck38agcp9002mjfus90e23t6m"},{"name":"JMeter","_id":"ck38agcp9002njfus6vgl935d"},{"name":"测试","_id":"ck38agcp9002qjfus1iev5sby"},{"name":"Linux","_id":"ck38agcpa002sjfusaquq8ghy"},{"name":"Vim","_id":"ck38agcpa002vjfus4jv32xwm"}]}}