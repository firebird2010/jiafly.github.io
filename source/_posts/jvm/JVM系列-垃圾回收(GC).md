---
title: JVM系列-垃圾回收(GC)
date: 2019-05-27 12:00:00
tags:
    - JVM
    - GC
    - 垃圾回收
categories:
    - JVM
notshow: true
---
# 1.GC概述
一说到GC我们就很容易的联想到了Java，并把它当做是Java的附属。其实不然，GC的历史早在1960年的Lisp语言上就被使用，所以它的产生比Java还早，只能说Java借鉴了这种技术，并且有更多的实现算法。
<!-- more -->
## 1.1 什么是GC
**GC**(Garbage Collection) 从字面意思上看就是`垃圾收集`的意思。这里的垃圾也就是在系统运行过程中所产生的一些已经无用的对象，而这些无用的对象是占据着一点的内存空间的，如果这些对象不及时被释放掉，长此以往，就会导致内存用完，也就是内存溢出。垃圾回收就是保证这些无用的对象能够及时的被回收，保证系统的正常运行。在Java中GC的作用的对象主要是堆和永久区的无用对象。

## 1.2 GC的优点
在C和C++语言中主要是由程序员手动去管理内存释放垃圾的回收，但是在Java语言则实现了许多垃圾回收算法，JVM能够自动回收无用对象，而不需要有Javaer手动去操作。这样大大提升了我们在写代码时候的效率，因为不需要过多的去考虑内存的使用情况了，注意：这里是`不需要过多`而不是不需要考虑，对于Java进阶者来说JVM的调优也是相当重要的。

# 2.对象已死？
我们都知道无用的对象将会被GC，但是如何确定一个对象是无用对象呢，在这里Java主要有三种方法。
- **引用计数法**
- **可达性分析算法**
- **回收方法区**

## 2.1 引用计数法
引用计数法是垃圾回收器的早期策略。在这个方法中堆中的每个对象都有一个计数，当被引用时计数+1 当失去一个引用时就+1。任何一个引用计数为0的对象都会被垃圾回收。

这种算法也存在两个问题:
- 频繁的对对象计数+1或者-1操作，影响性能
- 循环引用问题
    例如:当一个对象A被根节点R引用，然后A又被B引用，B被C引用，C又被A引用，这样ABC三个对象就是循环引用，A的引用计数为2 当根节点不再引用A的时候 A对象其实在内存中也没什么作用了，但是此时A的引用计数还是1，不可能被回收，所以内存就得不到释放。

## 2.2 可达性分析法
可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。

在Java语言中，可作为GC Root的对象包括下面几种：
- a.虚拟机栈中引用的对象（栈帧中的本地变量表）
- b.方法区中类静态属性引用的对象  
- c.方法区中常量引用的对象 
- d.本地方法栈中JNI（Native方法）引用的对象 

即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。
- **第一次标记**
如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记
- **第二次标记**
第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。

第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。

## 2.3 回收方法区
方法区存储内容是否需要回收的判断和上面介绍的两种方法是不一样的。

方法区主要回收的内容有：废弃`常量`和`无用的类`。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：
- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用。即:无法在任何地方通过反射访问该类的方法

# 3.GC算法
关于垃圾回收的算法在java中主要有一下四种，这四种也是各有优缺点，所以对于不同的对象收集也是采用了不同的算法实现。
- **标记-清除算法**
- **标记-整理算法**
- **复制算法**
- **分代收集算法**

## 3.1 标记-清除算法
### 3.1.1 介绍
标记-清除算法是现代垃圾回收算法的思想基础。

标记-清除算法的做法是在堆内存即将耗尽的时候，就会停止整个程序（也被成为stop the world），然后进行两个阶段的操作:标记阶段和清除阶段。
- **标记**
标记的过程其实就是，遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
- **清除**
清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。

### 3.1.2 优缺点
- **效率问题**
因为(**标记**)需要遍历堆中的所有对象，而且(**清除**)在GC的时候会暂停整个程序，所以效率比较低。
- **空间问题**
标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

## 3.2 复制算法
### 3.2.1 介绍
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

目前商用虚拟机大都使用这一算法回收新生代。将内存划分为一个较大的 Eden 区和两块较小的 Survivor。在HotSpot虚拟机中 Eden：Survivor = 8：1
### 3.2.2 优缺点
- 优点
    - 该算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指 
针，按顺序分配内存即可，实现简单，运行高效。
- 缺点
    - 可用的内存空间仅仅只有原内存空间的一半，也就是说有一半的内存空间被浪费。  

## 3.3 标记-整理算法
### 3.3.1 介绍
在复制算法中如果该内存区域对象存活率较高的话，就需要频繁的复制操作，效率非常低下（比如老年代中的对内存区域）这时候`标记-整理算法`就适合用于这种存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化，使得空闲空间连续。和标记-清除算法一样，标记-整理算法也分为两个阶段。
- **标记** 
遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象。
- **整理** 
将所有的存活对象移动到内存的一端。之后，清理边界外所有的空间。

### 3.3.2 优缺点
- 优点
    - 堆利用效率高
    - 无碎片
    - 对象顺序未变

## 3.4 分代收集算法
### 3.4.1 介绍
当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为`新生代`和`老年代`，这样就可以根据各个年代的特点采用最适合的收集算法。在**新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法只需要付出少量存活对象的复制成本就可以完成**。而**老年代中因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收**。`方法区永久代`，回收方法和`老年代`相同。


# 4.STW(stop-the-world)
STW是Java中一种全局暂停的现象。`全局停顿`是指所有Java代码停止，native代码可以执行，但不能和JVM交互，STW多半由于GC引起的。例如:
- Dump线程
- 死锁检查
- 堆Dump

## 4.1 GC时为什么会有STW？
就像我们在聚会的时候，有个保洁进到房间里打扫卫生，刚打扫完又有新的垃圾会扔在地上，房间就永远都打扫不干净。除非我们聚会结束没有人了，这时候打扫才不会产生新的垃圾。同理JVM也是这样，如果想要GC所有的垃圾就会有全局的停顿，以保障所有的垃圾都会被回收。

## 4.2 STW的危害
- 长时间服务停止，没有响应
- 遇到HA系统(双机集群系统)，可能引起主备切换，严重危害生产环境。

# 5.结语
JVM对于javaer进阶是有着非常重要的作用的，而GC可以说是JVM中比较重要的一块了，掌握GC也有利于我们能更加明确的了解JVM。从而在我们以后的工作中，能够考虑到关于内存回收，不在让内存成为我们程序运行的瓶颈。


一起加油吧。



